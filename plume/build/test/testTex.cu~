#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

const int width = 80;
const int height = 60;

// texture<float, 2, cudaReadModeElementType> tex;
texture<float4, 3, cudaReadModeElementType> noiseTex;
cudaArray *noiseArray;

__global__ void
transformKernel( float* g_odata, int width, int height)//, float theta) 
{
    // calculate normalized texture coordinates
    unsigned int x = blockIdx.x*blockDim.x + threadIdx.x;
    unsigned int y = blockIdx.y*blockDim.y + threadIdx.y;
     uint index =  threadIdx.x;
//     if (index >= width*height) return;
  
    g_odata[index] =  tex3D(noiseTex, 11, 2,1).w; 
}

//Round a / b to nearest higher integer value
uint iDivUp(uint a, uint b){
  return (a % b != 0) ? (a / b + 1) : (a / b);
}

// compute grid and thread block size for a given number of elements
void computeGridSize(uint n, uint blockSize, uint &numBlocks, uint &numThreads)
{
  numThreads = min(blockSize, n);
  numBlocks = iDivUp(n, numThreads);
}
// create 3D texture containing random values
void create3DTexture(int w, int h, int d)
{
    cudaExtent size = make_cudaExtent(w, h, d);
    uint elements = (uint) size.width*size.height*size.depth;

    float *volumeData = (float *)malloc(elements*4*sizeof(float));
    float *ptr = volumeData;
    for(uint i=0; i<elements; i++) {
        *ptr++ = drand48();//*2.0f-1.0f;
        *ptr++ = drand48();//*2.0f-1.0f;
        *ptr++ = drand48();//*2.0f-1.0f;
        *ptr++ = drand48();//*2.0f-1.0f;
    }


    cudaChannelFormatDesc channelDesc = cudaCreateChannelDesc<float4>();
    cudaMalloc3DArray(&noiseArray, &channelDesc, size) ;

    cudaMemcpy3DParms copyParams = { 0 };
    copyParams.srcPtr   = make_cudaPitchedPtr((void*)volumeData, size.width*sizeof(float4), size.width, size.height);
    copyParams.dstArray = noiseArray;
    copyParams.extent   = size;
    copyParams.kind     = cudaMemcpyHostToDevice;
    cudaMemcpy3D(&copyParams);

    free(volumeData);

    // set texture parameters
    noiseTex.normalized = true;                      // access with normalized texture coordinates
    noiseTex.filterMode = cudaFilterModeLinear;      // linear interpolation
    noiseTex.addressMode[0] = cudaAddressModeWrap;   // wrap texture coordinates
    noiseTex.addressMode[1] = cudaAddressModeWrap;
    noiseTex.addressMode[2] = cudaAddressModeWrap;

    // bind array to 3D texture
     cudaBindTextureToArray(noiseTex, noiseArray, channelDesc) ;
}
int main()
{
  // allocate device memory for result
  float* h_data = (float *)malloc(width*height*4*sizeof(float)); 
//   for(int i=0; i<width*height; i++) 
//   {
//     h_data[i] = 1.f/(i+1);
//   }
   
  create3DTexture(width,height,1);
  uint size = width*height*sizeof(float);
  float* d_data = NULL;
  cudaMalloc( (void**) &d_data, size) ;  
  
  uint numThreads, numBlocks;
  computeGridSize(width*height, 256, numBlocks, numThreads);
  printf("%d, %d\n", numBlocks, numThreads);

  
  // warmup
  transformKernel<<< numBlocks, numThreads >>>( d_data, width, height);//, angle);
  
  cudaMemcpy(h_data,  d_data, size, cudaMemcpyDeviceToHost);  
  
  for(int i=0; i<100; i++) 
  {
//     printf("this is:%d x=%f, y=%f, z=%f\n", i, h_data[i].wind.x, h_data[i].wind.y, h_data[i].wind.z);    
    printf("this is:%d x=%f, y=%f, z=%f\n", i, h_data[i] , h_data[i], h_data[i] );    
  }
  
  cudaFree(d_data);
//   cudaFreeArray(cu_array);
}