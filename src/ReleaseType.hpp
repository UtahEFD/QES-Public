//
//  ReleaseType.hpp
//  
//  This class represents a generic particle release type. The idea is to make other classes that inherit from this class
//  that are the specific release types, that make it easy to set the desired particle information for a given release type
//
//  Created by Loren Atwood on 01/25/20.
//

#pragma once


#include <cmath>


#include "util/ParseInterface.h"


enum ParticleReleaseType {
    perTimeStep,
    perSecond,
    instantaneous
};


class ReleaseType : public ParseInterface
{
protected:

    
public:

    // this is the particle release type actually used by everything. If it is not set by a specialized constructor,
    //  it needs to be set by a call to the setReleaseType function. Since parseInterface likely uses a string input,
    //  sources generated by parseInterface instead of by a specialized constructor need to call setReleaseType() within parseInterface()
    ParticleReleaseType parReleaseType;
    
    // might need to add another variable for the total number of available particles,
    //  or have a checking function that compares numParticles with totalNumParticles.
    //  might also need to change the inheritance structure for ParticleReleaseType
    int m_parPerTimestep;
    double m_releaseStartTime;
    double m_releaseEndTime;
    int m_numPar;
    
    
    // default constructor
    ReleaseType()
    {
    }
    
    // destructor
    virtual ~ReleaseType()
    {
    }



    // each releaseType needs to overload this function with their own version.
    // This allows differences in the input types for each releaseType to be handled by parseInterface()
    // or by specialized constructors. The = 0 at the end should force each inheriting class to require their own version of this function
    virtual void parseValues() = 0;

    // this should be called for each source individually by the dispersion class
    virtual void calcReleaseInfo(const double& timestep, const double& simDur) = 0;


    // this should be called for each source after calcReleaseInfo is called for each source, individually by the dispersion class
    // should this be virtual? The idea is that I want it to stay as this function no matter what ReleaseType is chosen
    virtual void checkReleaseInfo(const double& timestep, const double& simDur)
    {
        if( m_parPerTimestep <= 0 )
        {
            std::cerr << "ERROR (ReleaseType::checkReleaseInfo): input m_parPerTimestep is <= 0!";
            std::cerr << " m_parPerTimestep = \"" << m_parPerTimestep << "\"" << std::endl;
            exit(1);
        }
        if( m_releaseStartTime < 0 )
        {
            std::cerr << "ERROR (ReleaseType::checkReleaseInfo): input m_releaseStartTime is < 0!";
            std::cerr << " m_releaseStartTime = \"" << m_releaseStartTime << "\"" << std::endl;
            exit(1);
        }
        if( m_releaseEndTime > simDur )
        {
            std::cerr << "ERROR (ReleaseType::checkReleaseInfo): input m_releaseEndTime is > input simDur!";
            std::cerr << " m_releaseEndTime = \"" << m_releaseEndTime << "\", simDur = \"" << simDur << "\"" << std::endl;
            exit(1);
        }
        if( m_releaseEndTime < m_releaseStartTime )
        {
            std::cerr << "ERROR (ReleaseType::checkReleaseInfo): input m_releaseEndTime is < input m_releaseStartTime!";
            std::cerr << " m_releaseStartTime = \"" << m_releaseStartTime << "\", m_releaseEndTime = \"" << m_releaseEndTime << "\"" << std::endl;
            exit(1);
        }

        // this one is a bit trickier to check. Specifically the way the number of timesteps for a given release 
        //  is calculated needs to be watched carefully to make sure it is consistent throughout the program
        double releaseDur = m_releaseEndTime - m_releaseStartTime;
        if( parReleaseType == ParticleReleaseType::instantaneous )
        {
            if( releaseDur != 0)
            {
                std::cerr << "ERROR (ReleaseType::checkReleaseInfo): input ParticleReleaseType is instantaneous but input m_releaseStartTime does not equal m_releaseEndTime!";
                std::cerr << " m_releaseStartTime = \"" << m_releaseStartTime << "\", m_releaseEndTime = \"" << m_releaseEndTime << "\"" << std::endl;
                exit(1);
            }
            if( m_numPar != m_parPerTimestep )
            {
                std::cerr << "ERROR (ReleaseType::checkReleaseInfo): input ParticleReleaseType is instantaneous but input m_numPar does not equal input m_parPerTimestep!";
                std::cerr << " m_numPar = \"" << m_numPar << "\", m_parPerTimestep = \"" << m_parPerTimestep << "\"" << std::endl;
                exit(1);
            }
        } else
        {
            // Again, the way the number of timesteps for a given release 
            //  is calculated needs to be watched carefully to make sure it is consistent throughout the program
            int releaseSteps = std::ceil(releaseDur/timestep);
            if( releaseSteps == 0 )
            {
                std::cerr << "ERROR (ReleaseType::checkReleaseInfo): input ParticleReleaseType is not instantaneous but calculated releaseSteps is zero!";
                std::cerr << " releaseDur = \"" << releaseDur << "\", timestep = \"" << timestep << "\"" << std::endl;
                exit(1);
            }
            if( m_parPerTimestep*releaseSteps != m_numPar )
            {
                std::cerr << "ERROR (ReleaseType::checkReleaseInfo): calculated particles for release does not match input m_numPar!";
                std::cerr << " m_parPerTimestep = \"" << m_parPerTimestep << "\", releaseSteps = \"" << releaseSteps 
                        << "\", m_numPar = \"" << m_numPar << "\"" << std::endl;
                exit(1);
            }
        }

    }



};
