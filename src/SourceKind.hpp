//
//  SourceKind.hpp
//  
//  This class represents a generic source
//
//  Created by Jeremy Gibbs on 03/28/19.
//

#pragma once

#include "util/ParseInterface.h"
#include "particle.hpp"

#include "ReleaseType.hpp"
#include "ReleaseType_perTimeStep.hpp"
//#include "ReleaseType_perSecond.hpp"
#include "ReleaseType_instantaneous.hpp"


enum SourceShape {
    point,
    line,
    circle,
    cube,
    fullDomain
};

class SourceKind : public ParseInterface
{
protected:

    // these are expected to be set by parseInterface() in each source, with a call to setReleaseType() to set the m_rType using this variable.
    // there's got to be a better way to do this with the interface function, and I just am not understanding yet
    std::vector<ReleaseType*> rType_tmp;
    
    
public:


    // this is a pointer to the release type, which is chosen by parseInterface() by each source
    // this data structure holds information like the total number of particles to be released by the source, the number of particles to release
    // per time for each source, and the start and end times to be releasing from the source.
    ReleaseType* m_rType;

    // this needs set by parseInterface() in each source generated from input files, 
    //  and set each specialized constructor for each source generated via specialized constructor
    SourceShape m_sShape;
    

    // default constructor
    SourceKind()
    {
    }

    // destructor
    virtual ~SourceKind()
    {
    }


    // this function lets you take a string version of the release type and convert it to the enum data type
    // useful for processing inputs from an xml file that use strings instead of the enum version of the ParticleReleaseTypes
    void setReleaseType()
    {
                // now if the number of release types is not 1, there was a problem, need to quit with an error
        if( rType_tmp.size() == 0 )
        {
            std::cerr << "ERROR (SourceKind::setReleaseType): there was no input releaseType!" << std::endl;
            exit(1);
        }
        if( rType_tmp.size() > 1 )
        {
            std::cerr << "ERROR (SourceKind::setReleaseType): there was more than one input releaseType!" << std::endl;
            exit(1);
        }

        // seems like the number of release types is 1, so now set the actual public release type to be the one that we have
        m_rType = rType_tmp.at(0);

    }


    // each source needs to overload this function with their own version. This allows differences in the input types for each source to be handled by parseInterface()
    // or by specialized constructors. The = 0 at the end should force each inheriting class to require their own version of this function
    virtual void parseValues() = 0;


    // this is for checking the metadata. Sources generated by parse interface need this called manually. Sources generated by specialized constructors
    //  could run this function automatically at constructor time. I'm thinking of requiring this to be called manually for all sources
    //  as it may be handy to check the total available number of particles with the number of particles desired for each source.
    virtual void checkMetaData(const double& domainXstart, const double& domainXend, 
                               const double& domainYstart, const double& domainYend,
                               const double& domainZstart, const double& domainZend) = 0;
    

    // pure virtual function - enforces that the derived MUST define
    // this function
    //
    // This function appends particles to the provided vector of
    // particles...
    // 
    // This function could return the number of particles emitted or
    // 0 if some error. 
    // do something with all the new particles
    // the = 0 at the end should require each inheriting class to require their own version of this function
    virtual int emitParticles(const float dt, const float currTime, std::vector<particle>& emittedParticles) = 0;
    
    // HOW THIS Could be used
    // 
    // std::vector<pointInfo> nextSetOfParticles;
    // ...
    // nextSetOfParticles.clear();  // empty
    // for (all sources, source) {
    // int numParticles = source->emitParticles( nextSetOfParticles );
    // std::cout << "Emitting " << numParticles << " particles." << std::endl;
    // }
    //
    // could also use this output int for returning error messages, kind of the like the exit success or exit failure return methods.

};
