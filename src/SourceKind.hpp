//
//  Source.hpp
//  
//  This class represents a generic source
//
//  Created by Jeremy Gibbs on 03/28/19.
//

#pragma once

#include "util/ParseInterface.h"
#include "particle.hpp"


enum ParticleReleaseType {
    perTimeStep,
    perSecond,
    instantaneous
};

enum SourceShape {
    point,
    line,
    circle,
    cube,
    fullDomain
};

class SourceKind : public ParseInterface
{
protected:

    // might need to add another variable for the total number of available particles,
    //  or have a checking function that compares numParticles with totalNumParticles.
    //  might also need to change the inheritance structure for ParticleReleaseType
    int m_numParticles;

    // this is the particle release type actually used by everything. If it is not set by a specialized constructor,
    //  it needs to be set by a call to the setReleaseType function. Since parseInterface likely uses a string input,
    //  sources generated by parseInterface instead of by a specialized constructor need to call setReleaseType() within parseInterface()
    ParticleReleaseType m_rType;

    // this needs set by parseInterface() in each source generated from input files, 
    //  and set each specialized constructor for each source generated via specialized constructor
    SourceShape m_sShape;

    // this is expected to be set by parseInterface() in each source, with a call to setReleaseType() to set the m_rType using this variable.
    //  Not really needed if building a source from a specialized constructor.
    // Type checking comparisons to determine functions to use for a given source type should use m_rType, not this variable.
    std::string inputReleaseType;
    
    // Might need other variables too
    // int releaseStartTime, releaseEndTime;
    
public:

    // default constructor
    SourceKind()
        : m_numParticles( 100 ), m_rType( perTimeStep )
    {
    }

    // specialized constructor -- all things that are common to all
    // sources, num particles, the release type
    SourceKind( int numParticles, ParticleReleaseType rtype )
        : m_numParticles( numParticles ), m_rType( rtype )
    {
    }
    
    // destructor
    virtual ~SourceKind()
    {
    }

  int getNumParticles() {
    return m_numParticles;
  }

    // this function lets you take a string version of the release type and convert it to the enum data type
    // useful for processing inputs from an xml file that use strings instead of the enum version of the ParticleReleaseTypes
    void setReleaseType(std::string releaseType)
    {
        if( releaseType == "perTimeStep" )
        {
            m_rType = ParticleReleaseType::perTimeStep;
        } else if( releaseType == "perSecond" )
        {
            m_rType = ParticleReleaseType::perSecond;
        } else if( releaseType == "instantaneous" )
        {
            m_rType = ParticleReleaseType::instantaneous;
        } else
        {
            std::cerr << "ERROR (SourceKind::setReleaseType): input releaseType is not a valid ParticleReleaseType! releaseType = \"" << releaseType 
                    << "\". Available release types are \"perTimeStep\", \"perSecond\", \"instantaneous\"." << std::endl;
            exit(1);
        }
    }

    // each source needs to overload this function with their own version. This allows differences in the input types for each source to be handled by parseInterface()
    // or by specialized constructors. The = 0 at the end should force each inheriting class to require their own version of this function
    virtual void parseValues() = 0;


    // this is for checking the metadata. Sources generated by parse interface need this called manually. Sources generated by specialized constructors
    //  could run this function automatically at constructor time. I'm thinking of requiring this to be called manually for all sources
    //  as it may be handy to check the total available number of particles with the number of particles desired for each source.
    virtual void checkMetaData(const double& domainXstart, const double& domainXend, 
                               const double& domainYstart, const double& domainYend,
                               const double& domainZstart, const double& domainZend) = 0;
    

    // pure virtual function - enforces that the derived MUST define
    // this function
    //
    // This function appends particles to the provided vector of
    // particles...
    // 
    // This function could return the number of particles emitted or
    // 0 if some error. 
    // do something with all the new particles
    // the = 0 at the end should require each inheriting class to require their own version of this function
    virtual int emitParticles(const float dt, const float currTime, std::vector<particle>& emittedParticles) = 0;
    
    // HOW THIS Could be used
    // 
    // std::vector<pointInfo> nextSetOfParticles;
    // ...
    // nextSetOfParticles.clear();  // empty
    // for (all sources, source) {
    // int numParticles = source->emitParticles( nextSetOfParticles );
    // std::cout << "Emitting " << numParticles << " particles." << std::endl;
    // }
    //
    // could also use this output int for returning error messages, kind of the like the exit success or exit failure return methods.

};
