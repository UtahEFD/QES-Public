<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUDA Urb: ParseInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUDA Urb
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classParseInterface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ParseInterface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="src_2util_2ParseInterface_8h_source.html">ParseInterface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ParseInterface:</div>
<div class="dyncontent">
<div class="center"><img src="classParseInterface__inherit__graph.png" border="0" usemap="#ParseInterface_inherit__map" alt="Inheritance graph"/></div>
<map name="ParseInterface_inherit__map" id="ParseInterface_inherit__map">
<area shape="rect" id="node2" href="classA.html" title="A" alt="" coords="216,5,255,32"/>
<area shape="rect" id="node3" href="classB.html" title="B" alt="" coords="216,56,255,83"/>
<area shape="rect" id="node4" href="classBuilding.html" title="Building" alt="" coords="201,107,269,133"/>
<area shape="rect" id="node7" href="classBuildings.html" title="Buildings" alt="" coords="198,157,273,184"/>
<area shape="rect" id="node8" href="classC.html" title="C" alt="" coords="216,208,255,235"/>
<area shape="rect" id="node9" href="classD.html" title="D" alt="" coords="216,259,255,285"/>
<area shape="rect" id="node10" href="classFileOptions.html" title="FileOptions" alt="" coords="191,309,279,336"/>
<area shape="rect" id="node11" href="classGeneralInputData.html" title="GeneralInputData" alt="" coords="173,360,297,387"/>
<area shape="rect" id="node12" href="classMetParams.html" title="MetParams" alt="" coords="191,411,280,437"/>
<area shape="rect" id="node13" href="classP.html" title="P" alt="" coords="216,461,255,488"/>
<area shape="rect" id="node16" href="classRoot.html" title="Root" alt="" coords="210,512,261,539"/>
<area shape="rect" id="node17" href="classSensor.html" title="Sensor" alt="" coords="204,563,267,589"/>
<area shape="rect" id="node18" href="classSimulationParameters.html" title="SimulationParameters" alt="" coords="160,613,311,640"/>
<area shape="rect" id="node19" href="classTerrain.html" title="Terrain" alt="" coords="204,664,267,691"/>
<area shape="rect" id="node20" href="classTriangle.html" title="Triangle" alt="" coords="201,715,269,741"/>
<area shape="rect" id="node21" href="classURBInputData.html" title="URBInputData" alt="" coords="181,765,289,792"/>
<area shape="rect" id="node22" href="classVector3.html" title="Vector3\&lt; T \&gt;" alt="" coords="186,816,285,843"/>
<area shape="rect" id="node23" href="classVector3.html" title="Vector3\&lt; float \&gt;" alt="" coords="177,867,293,893"/>
<area shape="rect" id="node24" href="classVector3.html" title="Vector3\&lt; int \&gt;" alt="" coords="183,917,288,944"/>
<area shape="rect" id="node25" href="classX.html" title="X" alt="" coords="216,968,255,995"/>
<area shape="rect" id="node5" href="classNonPolyBuilding.html" title="NonPolyBuilding" alt="" coords="359,107,477,133"/>
<area shape="rect" id="node6" href="classRectangularBuilding.html" title="RectangularBuilding" alt="" coords="525,107,664,133"/>
<area shape="rect" id="node14" href="classP1.html" title="P1" alt="" coords="399,436,437,463"/>
<area shape="rect" id="node15" href="classP2.html" title="P2" alt="" coords="399,487,437,513"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ParseInterface:</div>
<div class="dyncontent">
<div class="center"><img src="classParseInterface__coll__graph.png" border="0" usemap="#ParseInterface_coll__map" alt="Collaboration graph"/></div>
<map name="ParseInterface_coll__map" id="ParseInterface_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86b7469a47ed83434a55ca1974a7287e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86b7469a47ed83434a55ca1974a7287e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a86b7469a47ed83434a55ca1974a7287e">parsePrimitive</a> (bool isReq, T &amp;val, const std::string tag)</td></tr>
<tr class="separator:a86b7469a47ed83434a55ca1974a7287e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d16b9baf79eb34c63914159798dc1eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d16b9baf79eb34c63914159798dc1eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a0d16b9baf79eb34c63914159798dc1eb">parseMultiPrimitives</a> (bool isReq, std::vector&lt; T &gt; &amp;vals, const std::string tag)</td></tr>
<tr class="separator:a0d16b9baf79eb34c63914159798dc1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289c74beb3acea103f9864f2225bce00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a289c74beb3acea103f9864f2225bce00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a289c74beb3acea103f9864f2225bce00">parseElement</a> (bool isReq, T *&amp;ele, const std::string tag)</td></tr>
<tr class="separator:a289c74beb3acea103f9864f2225bce00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9ff3a3139e6939cb7b0c8612d4a609"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca9ff3a3139e6939cb7b0c8612d4a609"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#aca9ff3a3139e6939cb7b0c8612d4a609">parseMultiElements</a> (bool isReq, std::vector&lt; T *&gt; &amp;eles, const std::string tag)</td></tr>
<tr class="separator:aca9ff3a3139e6939cb7b0c8612d4a609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24b31d7ffc3029b8a7a67f986ab414f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename... ARGS&gt; </td></tr>
<tr class="memitem:af24b31d7ffc3029b8a7a67f986ab414f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#af24b31d7ffc3029b8a7a67f986ab414f">parsePolymorph</a> (bool isReq, T *&amp;ele, <a class="el" href="classX.html">X</a> poly, ARGS... args)</td></tr>
<tr class="separator:af24b31d7ffc3029b8a7a67f986ab414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eddda17bca991a068b171fb6949bce8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X &gt; </td></tr>
<tr class="memitem:a3eddda17bca991a068b171fb6949bce8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a3eddda17bca991a068b171fb6949bce8">parsePolymorph</a> (bool isReq, T *&amp;ele, <a class="el" href="classX.html">X</a> poly)</td></tr>
<tr class="separator:a3eddda17bca991a068b171fb6949bce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab742098ba7badf016388bd10b32fb1ee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename... ARGS&gt; </td></tr>
<tr class="memitem:ab742098ba7badf016388bd10b32fb1ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#ab742098ba7badf016388bd10b32fb1ee">parseMultiPolymorphs</a> (bool isReq, std::vector&lt; T *&gt; &amp;eles, <a class="el" href="classX.html">X</a> poly, ARGS... args)</td></tr>
<tr class="separator:ab742098ba7badf016388bd10b32fb1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1afd8bdd00110808e3c42320556544"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X &gt; </td></tr>
<tr class="memitem:a3d1afd8bdd00110808e3c42320556544"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a3d1afd8bdd00110808e3c42320556544">parseMultiPolymorphs</a> (bool isReq, std::vector&lt; T *&gt; &amp;eles, <a class="el" href="classX.html">X</a> poly)</td></tr>
<tr class="separator:a3d1afd8bdd00110808e3c42320556544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c8afbe5369965c8855491bb3f75668"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60c8afbe5369965c8855491bb3f75668"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a60c8afbe5369965c8855491bb3f75668">parseTaglessValues</a> (std::vector&lt; T &gt; &amp;eles)</td></tr>
<tr class="separator:a60c8afbe5369965c8855491bb3f75668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca32108192ba0997c9e5a78189b0cbc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#afca32108192ba0997c9e5a78189b0cbc">parseValues</a> ()=0</td></tr>
<tr class="separator:afca32108192ba0997c9e5a78189b0cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba3a44090e2bebeb485457ea4c743a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ba3a44090e2bebeb485457ea4c743a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a2ba3a44090e2bebeb485457ea4c743a8">parsePrimative</a> (bool isReq, T &amp;val, const std::string tag)</td></tr>
<tr class="separator:a2ba3a44090e2bebeb485457ea4c743a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ffc29634def5ea16a7a30998cc15f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6ffc29634def5ea16a7a30998cc15f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#ab6ffc29634def5ea16a7a30998cc15f8">parseMultiPrimatives</a> (bool isReq, std::vector&lt; T &gt; &amp;vals, const std::string tag)</td></tr>
<tr class="separator:ab6ffc29634def5ea16a7a30998cc15f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289c74beb3acea103f9864f2225bce00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a289c74beb3acea103f9864f2225bce00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a289c74beb3acea103f9864f2225bce00">parseElement</a> (bool isReq, T *&amp;ele, const std::string tag)</td></tr>
<tr class="separator:a289c74beb3acea103f9864f2225bce00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9ff3a3139e6939cb7b0c8612d4a609"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca9ff3a3139e6939cb7b0c8612d4a609"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#aca9ff3a3139e6939cb7b0c8612d4a609">parseMultiElements</a> (bool isReq, std::vector&lt; T *&gt; &amp;eles, const std::string tag)</td></tr>
<tr class="separator:aca9ff3a3139e6939cb7b0c8612d4a609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24b31d7ffc3029b8a7a67f986ab414f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename... ARGS&gt; </td></tr>
<tr class="memitem:af24b31d7ffc3029b8a7a67f986ab414f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#af24b31d7ffc3029b8a7a67f986ab414f">parsePolymorph</a> (bool isReq, T *&amp;ele, <a class="el" href="classX.html">X</a> poly, ARGS... args)</td></tr>
<tr class="separator:af24b31d7ffc3029b8a7a67f986ab414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eddda17bca991a068b171fb6949bce8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X &gt; </td></tr>
<tr class="memitem:a3eddda17bca991a068b171fb6949bce8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a3eddda17bca991a068b171fb6949bce8">parsePolymorph</a> (bool isReq, T *&amp;ele, <a class="el" href="classX.html">X</a> poly)</td></tr>
<tr class="separator:a3eddda17bca991a068b171fb6949bce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab742098ba7badf016388bd10b32fb1ee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename... ARGS&gt; </td></tr>
<tr class="memitem:ab742098ba7badf016388bd10b32fb1ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#ab742098ba7badf016388bd10b32fb1ee">parseMultiPolymorphs</a> (bool isReq, std::vector&lt; T *&gt; &amp;eles, <a class="el" href="classX.html">X</a> poly, ARGS... args)</td></tr>
<tr class="separator:ab742098ba7badf016388bd10b32fb1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1afd8bdd00110808e3c42320556544"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X &gt; </td></tr>
<tr class="memitem:a3d1afd8bdd00110808e3c42320556544"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a3d1afd8bdd00110808e3c42320556544">parseMultiPolymorphs</a> (bool isReq, std::vector&lt; T *&gt; &amp;eles, <a class="el" href="classX.html">X</a> poly)</td></tr>
<tr class="separator:a3d1afd8bdd00110808e3c42320556544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c8afbe5369965c8855491bb3f75668"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60c8afbe5369965c8855491bb3f75668"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a60c8afbe5369965c8855491bb3f75668">parseTaglessValues</a> (std::vector&lt; T &gt; &amp;eles)</td></tr>
<tr class="separator:a60c8afbe5369965c8855491bb3f75668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca32108192ba0997c9e5a78189b0cbc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#afca32108192ba0997c9e5a78189b0cbc">parseValues</a> ()=0</td></tr>
<tr class="separator:afca32108192ba0997c9e5a78189b0cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba3a44090e2bebeb485457ea4c743a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ba3a44090e2bebeb485457ea4c743a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a2ba3a44090e2bebeb485457ea4c743a8">parsePrimative</a> (bool isReq, T &amp;val, const std::string tag)</td></tr>
<tr class="separator:a2ba3a44090e2bebeb485457ea4c743a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ffc29634def5ea16a7a30998cc15f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6ffc29634def5ea16a7a30998cc15f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#ab6ffc29634def5ea16a7a30998cc15f8">parseMultiPrimatives</a> (bool isReq, std::vector&lt; T &gt; &amp;vals, const std::string tag)</td></tr>
<tr class="separator:ab6ffc29634def5ea16a7a30998cc15f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289c74beb3acea103f9864f2225bce00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a289c74beb3acea103f9864f2225bce00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a289c74beb3acea103f9864f2225bce00">parseElement</a> (bool isReq, T *&amp;ele, const std::string tag)</td></tr>
<tr class="separator:a289c74beb3acea103f9864f2225bce00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9ff3a3139e6939cb7b0c8612d4a609"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca9ff3a3139e6939cb7b0c8612d4a609"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#aca9ff3a3139e6939cb7b0c8612d4a609">parseMultiElements</a> (bool isReq, std::vector&lt; T *&gt; &amp;eles, const std::string tag)</td></tr>
<tr class="separator:aca9ff3a3139e6939cb7b0c8612d4a609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24b31d7ffc3029b8a7a67f986ab414f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename... ARGS&gt; </td></tr>
<tr class="memitem:af24b31d7ffc3029b8a7a67f986ab414f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#af24b31d7ffc3029b8a7a67f986ab414f">parsePolymorph</a> (bool isReq, T *&amp;ele, <a class="el" href="classX.html">X</a> poly, ARGS... args)</td></tr>
<tr class="separator:af24b31d7ffc3029b8a7a67f986ab414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eddda17bca991a068b171fb6949bce8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X &gt; </td></tr>
<tr class="memitem:a3eddda17bca991a068b171fb6949bce8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a3eddda17bca991a068b171fb6949bce8">parsePolymorph</a> (bool isReq, T *&amp;ele, <a class="el" href="classX.html">X</a> poly)</td></tr>
<tr class="separator:a3eddda17bca991a068b171fb6949bce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab742098ba7badf016388bd10b32fb1ee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X , typename... ARGS&gt; </td></tr>
<tr class="memitem:ab742098ba7badf016388bd10b32fb1ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#ab742098ba7badf016388bd10b32fb1ee">parseMultiPolymorphs</a> (bool isReq, std::vector&lt; T *&gt; &amp;eles, <a class="el" href="classX.html">X</a> poly, ARGS... args)</td></tr>
<tr class="separator:ab742098ba7badf016388bd10b32fb1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1afd8bdd00110808e3c42320556544"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X &gt; </td></tr>
<tr class="memitem:a3d1afd8bdd00110808e3c42320556544"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a3d1afd8bdd00110808e3c42320556544">parseMultiPolymorphs</a> (bool isReq, std::vector&lt; T *&gt; &amp;eles, <a class="el" href="classX.html">X</a> poly)</td></tr>
<tr class="separator:a3d1afd8bdd00110808e3c42320556544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c8afbe5369965c8855491bb3f75668"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60c8afbe5369965c8855491bb3f75668"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a60c8afbe5369965c8855491bb3f75668">parseTaglessValues</a> (std::vector&lt; T &gt; &amp;eles)</td></tr>
<tr class="separator:a60c8afbe5369965c8855491bb3f75668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca32108192ba0997c9e5a78189b0cbc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#afca32108192ba0997c9e5a78189b0cbc">parseValues</a> ()=0</td></tr>
<tr class="separator:afca32108192ba0997c9e5a78189b0cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a47a3d184a3746c20169383e867e85d3a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a47a3d184a3746c20169383e867e85d3a">parseTree</a> (pt::ptree t, <a class="el" href="classURBInputData.html">URBInputData</a> *&amp;UID)</td></tr>
<tr class="separator:a47a3d184a3746c20169383e867e85d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40785f4b5636c69df24784ba151716ac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a40785f4b5636c69df24784ba151716ac">parseTree</a> (pt::ptree t, <a class="el" href="classRoot.html">Root</a> *&amp;root)</td></tr>
<tr class="separator:a40785f4b5636c69df24784ba151716ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a82d1495a227ed4fa757935c2843a8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a90a82d1495a227ed4fa757935c2843a8">parseTree</a> (pt::ptree t, <a class="el" href="classRoot.html">Root</a> *&amp;root)</td></tr>
<tr class="separator:a90a82d1495a227ed4fa757935c2843a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af983d932c4a708ffeba59fe71b46c2dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#af983d932c4a708ffeba59fe71b46c2dc">setTree</a> (pt::ptree t)</td></tr>
<tr class="separator:af983d932c4a708ffeba59fe71b46c2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000ce4b52a192d2a7d0bfeaeb38fc358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a000ce4b52a192d2a7d0bfeaeb38fc358">setParents</a> (std::string s)</td></tr>
<tr class="separator:a000ce4b52a192d2a7d0bfeaeb38fc358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af983d932c4a708ffeba59fe71b46c2dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#af983d932c4a708ffeba59fe71b46c2dc">setTree</a> (pt::ptree t)</td></tr>
<tr class="separator:af983d932c4a708ffeba59fe71b46c2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000ce4b52a192d2a7d0bfeaeb38fc358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a000ce4b52a192d2a7d0bfeaeb38fc358">setParents</a> (std::string s)</td></tr>
<tr class="separator:a000ce4b52a192d2a7d0bfeaeb38fc358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af983d932c4a708ffeba59fe71b46c2dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#af983d932c4a708ffeba59fe71b46c2dc">setTree</a> (pt::ptree t)</td></tr>
<tr class="separator:af983d932c4a708ffeba59fe71b46c2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000ce4b52a192d2a7d0bfeaeb38fc358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParseInterface.html#a000ce4b52a192d2a7d0bfeaeb38fc358">setParents</a> (std::string s)</td></tr>
<tr class="separator:a000ce4b52a192d2a7d0bfeaeb38fc358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0da456d91cbfd2fdc59c67b525b1b578"><td class="memItemLeft" align="right" valign="top"><a id="a0da456d91cbfd2fdc59c67b525b1b578"></a>
pt::ptree&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b></td></tr>
<tr class="separator:a0da456d91cbfd2fdc59c67b525b1b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d43a4cf288733ceec9478ab7c55193"><td class="memItemLeft" align="right" valign="top"><a id="a67d43a4cf288733ceec9478ab7c55193"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>treeParents</b></td></tr>
<tr class="separator:a67d43a4cf288733ceec9478ab7c55193"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is a generic object from which all classes that can be parsed from an XML file will inherit from. This class contains methods to simplify the parsing process and obscure the complecations of the boost library. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a289c74beb3acea103f9864f2225bce00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289c74beb3acea103f9864f2225bce00">&#9670;&nbsp;</a></span>parseElement() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseElement </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for an element with the tag of "tag". Once it is found, that element will be parsed and the completed element will be returned. this is a template function, so the type of the value that is taken in and found are flexible. If the value is unable to be found, "val" will not be updated. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">ele</td><td>the element that is being parsed and updated </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the element we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a289c74beb3acea103f9864f2225bce00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289c74beb3acea103f9864f2225bce00">&#9670;&nbsp;</a></span>parseElement() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseElement </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for an element with the tag of "tag". Once it is found, that element will be parsed and the completed element will be returned. this is a template function, so the type of the value that is taken in and found are flexible. If the value is unable to be found, "val" will not be updated. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">ele</td><td>the element that is being parsed and updated </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the element we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a289c74beb3acea103f9864f2225bce00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289c74beb3acea103f9864f2225bce00">&#9670;&nbsp;</a></span>parseElement() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseElement </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for an element with the tag of "tag". Once it is found, that element will be parsed and the completed element will be returned. this is a template function, so the type of the value that is taken in and found are flexible. If the value is unable to be found, "val" will not be updated. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">ele</td><td>the element that is being parsed and updated </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the element we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca9ff3a3139e6939cb7b0c8612d4a609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9ff3a3139e6939cb7b0c8612d4a609">&#9670;&nbsp;</a></span>parseMultiElements() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiElements </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for all elements with the tag of "tag". Once it is found, that element will be parsed and the completed element will be returned. this is a template function, so the type of the value that is taken in and found are flexible. This will return all instances of a certain tag, this means it can have 0..* elements. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">eles</td><td>the vector to be filled with found elements </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the elements we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca9ff3a3139e6939cb7b0c8612d4a609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9ff3a3139e6939cb7b0c8612d4a609">&#9670;&nbsp;</a></span>parseMultiElements() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiElements </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for all elements with the tag of "tag". Once it is found, that element will be parsed and the completed element will be returned. this is a template function, so the type of the value that is taken in and found are flexible. This will return all instances of a certain tag, this means it can have 0..* elements. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">eles</td><td>the vector to be filled with found elements </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the elements we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca9ff3a3139e6939cb7b0c8612d4a609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9ff3a3139e6939cb7b0c8612d4a609">&#9670;&nbsp;</a></span>parseMultiElements() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiElements </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for all elements with the tag of "tag". Once it is found, that element will be parsed and the completed element will be returned. this is a template function, so the type of the value that is taken in and found are flexible. This will return all instances of a certain tag, this means it can have 0..* elements. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">eles</td><td>the vector to be filled with found elements </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the elements we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab742098ba7badf016388bd10b32fb1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab742098ba7badf016388bd10b32fb1ee">&#9670;&nbsp;</a></span>parseMultiPolymorphs() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiPolymorphs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursive This function takes in a vector of elements and a list of polymorphs. This function will check the current ptree for all of the provided polymorphs. All instances of the polymorphs in the current tree are created through parsing and then added to the vector. This function is a variadic template, which means it can take in any number of objects each with their own type. However, this code is expecting each type to be a variation of a polymorph and as so, this calls functions and uses variables specific to the polymorph structure. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">eles</td><td>a list of elements that will be updated </td></tr>
    <tr><td class="paramname">poly</td><td>the current polymorph we are looking for in the xml </td></tr>
    <tr><td class="paramname">ARGS</td><td>subsequent polymorphs to check in case the current is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab742098ba7badf016388bd10b32fb1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab742098ba7badf016388bd10b32fb1ee">&#9670;&nbsp;</a></span>parseMultiPolymorphs() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiPolymorphs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursive This function takes in a vector of elements and a list of polymorphs. This function will check the current ptree for all of the provided polymorphs. All instances of the polymorphs in the current tree are created through parsing and then added to the vector. This function is a variadic template, which means it can take in any number of objects each with their own type. However, this code is expecting each type to be a variation of a polymorph and as so, this calls functions and uses variables specific to the polymorph structure. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">eles</td><td>a list of elements that will be updated </td></tr>
    <tr><td class="paramname">poly</td><td>the current polymorph we are looking for in the xml </td></tr>
    <tr><td class="paramname">ARGS</td><td>subsequent polymorphs to check in case the current is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab742098ba7badf016388bd10b32fb1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab742098ba7badf016388bd10b32fb1ee">&#9670;&nbsp;</a></span>parseMultiPolymorphs() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiPolymorphs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursive This function takes in a vector of elements and a list of polymorphs. This function will check the current ptree for all of the provided polymorphs. All instances of the polymorphs in the current tree are created through parsing and then added to the vector. This function is a variadic template, which means it can take in any number of objects each with their own type. However, this code is expecting each type to be a variation of a polymorph and as so, this calls functions and uses variables specific to the polymorph structure. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">eles</td><td>a list of elements that will be updated </td></tr>
    <tr><td class="paramname">poly</td><td>the current polymorph we are looking for in the xml </td></tr>
    <tr><td class="paramname">ARGS</td><td>subsequent polymorphs to check in case the current is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d1afd8bdd00110808e3c42320556544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1afd8bdd00110808e3c42320556544">&#9670;&nbsp;</a></span>parseMultiPolymorphs() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiPolymorphs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classA.html">A</a> base case for the recursive version of this function </p>

</div>
</div>
<a id="a3d1afd8bdd00110808e3c42320556544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1afd8bdd00110808e3c42320556544">&#9670;&nbsp;</a></span>parseMultiPolymorphs() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiPolymorphs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classA.html">A</a> base case for the recursive version of this function </p>

</div>
</div>
<a id="a3d1afd8bdd00110808e3c42320556544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1afd8bdd00110808e3c42320556544">&#9670;&nbsp;</a></span>parseMultiPolymorphs() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiPolymorphs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T *&gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classA.html">A</a> base case for the recursive version of this function </p>

</div>
</div>
<a id="ab6ffc29634def5ea16a7a30998cc15f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ffc29634def5ea16a7a30998cc15f8">&#9670;&nbsp;</a></span>parseMultiPrimatives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiPrimatives </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for all elements with the tag of "tag". When one is found, it adds the value to a vector. this is a template function, so the type of the value that is taken in and found are flexible. This will return all instances of a certain tag, this means it can have 0..* values. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">vals</td><td>the vector to be filled with found values </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the values we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6ffc29634def5ea16a7a30998cc15f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ffc29634def5ea16a7a30998cc15f8">&#9670;&nbsp;</a></span>parseMultiPrimatives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiPrimatives </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for all elements with the tag of "tag". When one is found, it adds the value to a vector. this is a template function, so the type of the value that is taken in and found are flexible. This will return all instances of a certain tag, this means it can have 0..* values. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">vals</td><td>the vector to be filled with found values </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the values we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d16b9baf79eb34c63914159798dc1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d16b9baf79eb34c63914159798dc1eb">&#9670;&nbsp;</a></span>parseMultiPrimitives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseMultiPrimitives </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for all elements with the tag of "tag". When one is found, it adds the value to a vector. this is a template function, so the type of the value that is taken in and found are flexible. This will return all instances of a certain tag, this means it can have 0..* values. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">vals</td><td>the vector to be filled with found values </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the values we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af24b31d7ffc3029b8a7a67f986ab414f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24b31d7ffc3029b8a7a67f986ab414f">&#9670;&nbsp;</a></span>parsePolymorph() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parsePolymorph </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursive This function takes in an element and a list of polymorphs. This function will check the current ptree for all of the provided polymorphs. Once one of the polymorphs is found, an element of that type is created over ele and it's information is parsed out of the tree. This function is a variadic template, which means it can take in any number of objects each with their own type. However, this code is expecting each type to be a variation of a polymorph and as so, this calls functions and uses variables specific to the polymorph structure. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">ele</td><td>the element that will be updated </td></tr>
    <tr><td class="paramname">poly</td><td>the current polymorph we are looking for in the xml </td></tr>
    <tr><td class="paramname">ARGS</td><td>subsequent polymorphs to check in case the current is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af24b31d7ffc3029b8a7a67f986ab414f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24b31d7ffc3029b8a7a67f986ab414f">&#9670;&nbsp;</a></span>parsePolymorph() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parsePolymorph </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursive This function takes in an element and a list of polymorphs. This function will check the current ptree for all of the provided polymorphs. Once one of the polymorphs is found, an element of that type is created over ele and it's information is parsed out of the tree. This function is a variadic template, which means it can take in any number of objects each with their own type. However, this code is expecting each type to be a variation of a polymorph and as so, this calls functions and uses variables specific to the polymorph structure. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">ele</td><td>the element that will be updated </td></tr>
    <tr><td class="paramname">poly</td><td>the current polymorph we are looking for in the xml </td></tr>
    <tr><td class="paramname">ARGS</td><td>subsequent polymorphs to check in case the current is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af24b31d7ffc3029b8a7a67f986ab414f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24b31d7ffc3029b8a7a67f986ab414f">&#9670;&nbsp;</a></span>parsePolymorph() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X , typename... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parsePolymorph </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursive This function takes in an element and a list of polymorphs. This function will check the current ptree for all of the provided polymorphs. Once one of the polymorphs is found, an element of that type is created over ele and it's information is parsed out of the tree. This function is a variadic template, which means it can take in any number of objects each with their own type. However, this code is expecting each type to be a variation of a polymorph and as so, this calls functions and uses variables specific to the polymorph structure. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">ele</td><td>the element that will be updated </td></tr>
    <tr><td class="paramname">poly</td><td>the current polymorph we are looking for in the xml </td></tr>
    <tr><td class="paramname">ARGS</td><td>subsequent polymorphs to check in case the current is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3eddda17bca991a068b171fb6949bce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eddda17bca991a068b171fb6949bce8">&#9670;&nbsp;</a></span>parsePolymorph() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parsePolymorph </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classA.html">A</a> base case for the recursive version of this function </p>

</div>
</div>
<a id="a3eddda17bca991a068b171fb6949bce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eddda17bca991a068b171fb6949bce8">&#9670;&nbsp;</a></span>parsePolymorph() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parsePolymorph </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classA.html">A</a> base case for the recursive version of this function </p>

</div>
</div>
<a id="a3eddda17bca991a068b171fb6949bce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eddda17bca991a068b171fb6949bce8">&#9670;&nbsp;</a></span>parsePolymorph() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parsePolymorph </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classX.html">X</a>&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classA.html">A</a> base case for the recursive version of this function </p>

</div>
</div>
<a id="a2ba3a44090e2bebeb485457ea4c743a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba3a44090e2bebeb485457ea4c743a8">&#9670;&nbsp;</a></span>parsePrimative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parsePrimative </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for an element with the tag of "tag". Once it is found, it returns the value. this is a template function, so the type of the value that is taken in and found are flexible. If the value is unable to be found, "val" will not be updated. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">val</td><td>the value that is being updated </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the value we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ba3a44090e2bebeb485457ea4c743a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba3a44090e2bebeb485457ea4c743a8">&#9670;&nbsp;</a></span>parsePrimative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parsePrimative </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for an element with the tag of "tag". Once it is found, it returns the value. this is a template function, so the type of the value that is taken in and found are flexible. If the value is unable to be found, "val" will not be updated. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">val</td><td>the value that is being updated </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the value we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86b7469a47ed83434a55ca1974a7287e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b7469a47ed83434a55ca1974a7287e">&#9670;&nbsp;</a></span>parsePrimitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parsePrimitive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses the current node of the tree and searches for an element with the tag of "tag". Once it is found, it returns the value. this is a template function, so the type of the value that is taken in and found are flexible. If the value is unable to be found, "val" will not be updated. If this variable is required and not found, an exception will be thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReq</td><td>if this variable is required or not </td></tr>
    <tr><td class="paramname">val</td><td>the value that is being updated </td></tr>
    <tr><td class="paramname">tag</td><td>the tagline in the xml of the value we are searching for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60c8afbe5369965c8855491bb3f75668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c8afbe5369965c8855491bb3f75668">&#9670;&nbsp;</a></span>parseTaglessValues() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseTaglessValues </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will parse out a list of values that do not have tags associated with the values. Keep in mind, if this function is being called, the values can not be optional, this should only be used to parse a specific data structure. This is a template function, whatever type is put in will be parsed out. note: the type must have an overload for &gt;&gt; with input streams. </p>

</div>
</div>
<a id="a60c8afbe5369965c8855491bb3f75668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c8afbe5369965c8855491bb3f75668">&#9670;&nbsp;</a></span>parseTaglessValues() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseTaglessValues </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will parse out a list of values that do not have tags associated with the values. Keep in mind, if this function is being called, the values can not be optional, this should only be used to parse a specific data structure. This is a template function, whatever type is put in will be parsed out. note: the type must have an overload for &gt;&gt; with input streams. </p>

</div>
</div>
<a id="a60c8afbe5369965c8855491bb3f75668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c8afbe5369965c8855491bb3f75668">&#9670;&nbsp;</a></span>parseTaglessValues() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseTaglessValues </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will parse out a list of values that do not have tags associated with the values. Keep in mind, if this function is being called, the values can not be optional, this should only be used to parse a specific data structure. This is a template function, whatever type is put in will be parsed out. note: the type must have an overload for &gt;&gt; with input streams. </p>

</div>
</div>
<a id="a47a3d184a3746c20169383e867e85d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a3d184a3746c20169383e867e85d3a">&#9670;&nbsp;</a></span>parseTree() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseTree </td>
          <td>(</td>
          <td class="paramtype">pt::ptree&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classURBInputData.html">URBInputData</a> *&amp;&#160;</td>
          <td class="paramname"><em>UID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes in an <a class="el" href="classURBInputData.html">URBInputData</a> variable and uses it as the base to parse the ptree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UID</td><td>the object that will serve as the base level of the xml parser </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40785f4b5636c69df24784ba151716ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40785f4b5636c69df24784ba151716ac">&#9670;&nbsp;</a></span>parseTree() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::parseTree </td>
          <td>(</td>
          <td class="paramtype">pt::ptree&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRoot.html">Root</a> *&amp;&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes in a root variable and uses it as the base to parse the ptree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the object that will serve as the base level of the xml parser </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90a82d1495a227ed4fa757935c2843a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a82d1495a227ed4fa757935c2843a8">&#9670;&nbsp;</a></span>parseTree() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ParseInterface::parseTree </td>
          <td>(</td>
          <td class="paramtype">pt::ptree&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRoot.html">Root</a> *&amp;&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes in a root variable and uses it as the base to parse the ptree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the object that will serve as the base level of the xml parser </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afca32108192ba0997c9e5a78189b0cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca32108192ba0997c9e5a78189b0cbc">&#9670;&nbsp;</a></span>parseValues() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ParseInterface::parseValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function This is where we select what values we want to parse out of the xml file by calling the parseX functions above. </p>

<p>Implemented in <a class="el" href="classP2.html#a3b8928a6e7dda94f06dab603420cd8c7">P2</a>, <a class="el" href="classSimulationParameters.html#a306c6d373794f5186beec9026f56845c">SimulationParameters</a>, <a class="el" href="classRectangularBuilding.html#adbc6b832c817fc06f9bc2e51561a7e81">RectangularBuilding</a>, <a class="el" href="classSimulationParameters.html#a306c6d373794f5186beec9026f56845c">SimulationParameters</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; T &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; float &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; int &gt;</a>, <a class="el" href="classTriangle.html#a3b08ac99b202202bf7dbf2504da91ba1">Triangle</a>, <a class="el" href="classP1.html#aea4d99ff4e45862292d2dbb83ec32363">P1</a>, <a class="el" href="classURBInputData.html#a3fea38ec8d574eb8e5c9ee5f1ad53636">URBInputData</a>, <a class="el" href="classSensor.html#a570a911466a9fd98894f7c2f2abaf103">Sensor</a>, <a class="el" href="classMetParams.html#ad40706e0668d5e0248f39cc3a480b0af">MetParams</a>, <a class="el" href="classNonPolyBuilding.html#ace133756e0233d75b434fec5273b4414">NonPolyBuilding</a>, <a class="el" href="classBuildings.html#a97851dd190977ba999ecb1f50481c400">Buildings</a>, <a class="el" href="classX.html#a0d0aabf7efbe8356894613e58b736216">X</a>, <a class="el" href="classFileOptions.html#aca2f6304ed7d1fdde5c6c392d7fd11b9">FileOptions</a>, <a class="el" href="classGeneralInputData.html#a674714bd018eea1a601ae9c4b8212c4a">GeneralInputData</a>, <a class="el" href="classTerrain.html#a4258f6f5195a3be6c7afa3e4f03bd227">Terrain</a>, <a class="el" href="classB.html#abf3989a414e46fb5dd4bd15a279008ab">B</a>, <a class="el" href="classBuilding.html#a7782e7933a009fcfee4d186e62d34b43">Building</a>, <a class="el" href="classC.html#a7f8b8fa8187ab2f50ca999ae9a1687d7">C</a>, <a class="el" href="classA.html#a71896ec8a87fd03a725668c503ec64e7">A</a>, <a class="el" href="classD.html#afd52a3aa7a7e9047386deb6aeb796b2a">D</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; T &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; float &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; int &gt;</a>, <a class="el" href="classRoot.html#ade0eb65da55fa8c045a76bcf1fb16009">Root</a>, and <a class="el" href="classRoot.html#ade0eb65da55fa8c045a76bcf1fb16009">Root</a>.</p>

</div>
</div>
<a id="afca32108192ba0997c9e5a78189b0cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca32108192ba0997c9e5a78189b0cbc">&#9670;&nbsp;</a></span>parseValues() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ParseInterface::parseValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function This is where we select what values we want to parse out of the xml file by calling the parseX functions above. </p>

<p>Implemented in <a class="el" href="classP2.html#a3b8928a6e7dda94f06dab603420cd8c7">P2</a>, <a class="el" href="classSimulationParameters.html#a306c6d373794f5186beec9026f56845c">SimulationParameters</a>, <a class="el" href="classRectangularBuilding.html#adbc6b832c817fc06f9bc2e51561a7e81">RectangularBuilding</a>, <a class="el" href="classSimulationParameters.html#a306c6d373794f5186beec9026f56845c">SimulationParameters</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; T &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; float &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; int &gt;</a>, <a class="el" href="classTriangle.html#a3b08ac99b202202bf7dbf2504da91ba1">Triangle</a>, <a class="el" href="classP1.html#aea4d99ff4e45862292d2dbb83ec32363">P1</a>, <a class="el" href="classURBInputData.html#a3fea38ec8d574eb8e5c9ee5f1ad53636">URBInputData</a>, <a class="el" href="classSensor.html#a570a911466a9fd98894f7c2f2abaf103">Sensor</a>, <a class="el" href="classMetParams.html#ad40706e0668d5e0248f39cc3a480b0af">MetParams</a>, <a class="el" href="classNonPolyBuilding.html#ace133756e0233d75b434fec5273b4414">NonPolyBuilding</a>, <a class="el" href="classBuildings.html#a97851dd190977ba999ecb1f50481c400">Buildings</a>, <a class="el" href="classX.html#a0d0aabf7efbe8356894613e58b736216">X</a>, <a class="el" href="classFileOptions.html#aca2f6304ed7d1fdde5c6c392d7fd11b9">FileOptions</a>, <a class="el" href="classGeneralInputData.html#a674714bd018eea1a601ae9c4b8212c4a">GeneralInputData</a>, <a class="el" href="classTerrain.html#a4258f6f5195a3be6c7afa3e4f03bd227">Terrain</a>, <a class="el" href="classB.html#abf3989a414e46fb5dd4bd15a279008ab">B</a>, <a class="el" href="classBuilding.html#a7782e7933a009fcfee4d186e62d34b43">Building</a>, <a class="el" href="classC.html#a7f8b8fa8187ab2f50ca999ae9a1687d7">C</a>, <a class="el" href="classA.html#a71896ec8a87fd03a725668c503ec64e7">A</a>, <a class="el" href="classD.html#afd52a3aa7a7e9047386deb6aeb796b2a">D</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; T &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; float &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; int &gt;</a>, <a class="el" href="classRoot.html#ade0eb65da55fa8c045a76bcf1fb16009">Root</a>, and <a class="el" href="classRoot.html#ade0eb65da55fa8c045a76bcf1fb16009">Root</a>.</p>

</div>
</div>
<a id="afca32108192ba0997c9e5a78189b0cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca32108192ba0997c9e5a78189b0cbc">&#9670;&nbsp;</a></span>parseValues() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ParseInterface::parseValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function This is where we select what values we want to parse out of the xml file by calling the parseX functions above. </p>

<p>Implemented in <a class="el" href="classP2.html#a3b8928a6e7dda94f06dab603420cd8c7">P2</a>, <a class="el" href="classSimulationParameters.html#a306c6d373794f5186beec9026f56845c">SimulationParameters</a>, <a class="el" href="classRectangularBuilding.html#adbc6b832c817fc06f9bc2e51561a7e81">RectangularBuilding</a>, <a class="el" href="classSimulationParameters.html#a306c6d373794f5186beec9026f56845c">SimulationParameters</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; T &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; float &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; int &gt;</a>, <a class="el" href="classTriangle.html#a3b08ac99b202202bf7dbf2504da91ba1">Triangle</a>, <a class="el" href="classP1.html#aea4d99ff4e45862292d2dbb83ec32363">P1</a>, <a class="el" href="classURBInputData.html#a3fea38ec8d574eb8e5c9ee5f1ad53636">URBInputData</a>, <a class="el" href="classSensor.html#a570a911466a9fd98894f7c2f2abaf103">Sensor</a>, <a class="el" href="classMetParams.html#ad40706e0668d5e0248f39cc3a480b0af">MetParams</a>, <a class="el" href="classNonPolyBuilding.html#ace133756e0233d75b434fec5273b4414">NonPolyBuilding</a>, <a class="el" href="classBuildings.html#a97851dd190977ba999ecb1f50481c400">Buildings</a>, <a class="el" href="classX.html#a0d0aabf7efbe8356894613e58b736216">X</a>, <a class="el" href="classFileOptions.html#aca2f6304ed7d1fdde5c6c392d7fd11b9">FileOptions</a>, <a class="el" href="classGeneralInputData.html#a674714bd018eea1a601ae9c4b8212c4a">GeneralInputData</a>, <a class="el" href="classTerrain.html#a4258f6f5195a3be6c7afa3e4f03bd227">Terrain</a>, <a class="el" href="classB.html#abf3989a414e46fb5dd4bd15a279008ab">B</a>, <a class="el" href="classBuilding.html#a7782e7933a009fcfee4d186e62d34b43">Building</a>, <a class="el" href="classC.html#a7f8b8fa8187ab2f50ca999ae9a1687d7">C</a>, <a class="el" href="classA.html#a71896ec8a87fd03a725668c503ec64e7">A</a>, <a class="el" href="classD.html#afd52a3aa7a7e9047386deb6aeb796b2a">D</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; T &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; float &gt;</a>, <a class="el" href="classVector3.html#a15a1271a3ba4497ca95cc4dd66481f9e">Vector3&lt; int &gt;</a>, <a class="el" href="classRoot.html#ade0eb65da55fa8c045a76bcf1fb16009">Root</a>, and <a class="el" href="classRoot.html#ade0eb65da55fa8c045a76bcf1fb16009">Root</a>.</p>

</div>
</div>
<a id="a000ce4b52a192d2a7d0bfeaeb38fc358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000ce4b52a192d2a7d0bfeaeb38fc358">&#9670;&nbsp;</a></span>setParents() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::setParents </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sets the string of parent tags </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string of parent tags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a000ce4b52a192d2a7d0bfeaeb38fc358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000ce4b52a192d2a7d0bfeaeb38fc358">&#9670;&nbsp;</a></span>setParents() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::setParents </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sets the string of parent tags </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string of parent tags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a000ce4b52a192d2a7d0bfeaeb38fc358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000ce4b52a192d2a7d0bfeaeb38fc358">&#9670;&nbsp;</a></span>setParents() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::setParents </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sets the string of parent tags </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string of parent tags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af983d932c4a708ffeba59fe71b46c2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af983d932c4a708ffeba59fe71b46c2dc">&#9670;&nbsp;</a></span>setTree() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::setTree </td>
          <td>(</td>
          <td class="paramtype">pt::ptree&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This sets the tree of this object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>tree to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af983d932c4a708ffeba59fe71b46c2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af983d932c4a708ffeba59fe71b46c2dc">&#9670;&nbsp;</a></span>setTree() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::setTree </td>
          <td>(</td>
          <td class="paramtype">pt::ptree&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This sets the tree of this object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>tree to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af983d932c4a708ffeba59fe71b46c2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af983d932c4a708ffeba59fe71b46c2dc">&#9670;&nbsp;</a></span>setTree() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParseInterface::setTree </td>
          <td>(</td>
          <td class="paramtype">pt::ptree&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This sets the tree of this object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>tree to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/behnam/CUDA-URB/src/util/<a class="el" href="src_2util_2ParseInterface_8h_source.html">ParseInterface.h</a></li>
<li>/home/behnam/CUDA-URB/src/util/ParseInterface.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
