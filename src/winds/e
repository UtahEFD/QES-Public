Building.h: * This file is part of QES-Winds
Building.h: * GPL-3.0 License
Building.h: * QES-Winds is free software: you can redistribute it and/or modify
Building.h: * QES-Winds is distributed in the hope that it will be useful,
Building.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Building.h:  /** index of start and end of building in stair-step method */
Building.h:  /** index of start and end of building in cut-cell method */
Building.h:  float small_dimension; /**< Smaller of the height (H) and the effective cross-wind width (Weff) */
Building.h:  float long_dimension; /**< Larger of the height (H) and the effective cross-wind width (Weff) */
Buildings.h: * This file is part of QES-Winds
Buildings.h: * GPL-3.0 License
Buildings.h: * QES-Winds is free software: you can redistribute it and/or modify
Buildings.h: * QES-Winds is distributed in the hope that it will be useful,
Buildings.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
BVH.cpp: * This file is part of QES-Winds
BVH.cpp: * GPL-3.0 License
BVH.cpp: * QES-Winds is free software: you can redistribute it and/or modify
BVH.cpp: * QES-Winds is distributed in the hope that it will be useful,
BVH.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
BVH.cpp:        lMid = (l[j]->xmin + l[j]->xmax) / 2.0f;
BVH.cpp:        rMid = (r[k]->xmin + r[k]->xmax) / 2.0f;
BVH.cpp:        lMid = (l[j]->ymin + l[j]->ymax) / 2.0f;
BVH.cpp:        rMid = (r[k]->ymin + r[k]->ymax) / 2.0f;
BVH.cpp:    xmin = GETMIN(l->xmin, r->xmin);
BVH.cpp:    xmax = GETMAX(l->xmax, r->xmax);
BVH.cpp:    ymin = GETMIN(l->ymin, r->ymin);
BVH.cpp:    ymax = GETMAX(l->ymax, r->ymax);
BVH.cpp:    zmin = GETMIN(l->zmin, r->zmin);
BVH.cpp:    zmax = GETMAX(l->zmax, r->zmax);
BVH.cpp:    xmin = l->xmin;
BVH.cpp:    xmax = l->xmax;
BVH.cpp:    ymin = l->ymin;
BVH.cpp:    ymax = l->ymax;
BVH.cpp:    zmin = l->zmin;
BVH.cpp:    zmax = l->zmax;
BVH.cpp:  t->getBoundaries(xmin, xmax, ymin, ymax, zmin, zmax);
BVH.cpp:    xmin = leftBox->xmin;
BVH.cpp:    xmax = leftBox->xmax;
BVH.cpp:    ymin = leftBox->ymin;
BVH.cpp:    ymax = leftBox->ymax;
BVH.cpp:    zmin = leftBox->zmin;
BVH.cpp:    zmax = leftBox->zmax;
BVH.cpp:    xmin = GETMIN(leftBox->xmin, rightBox->xmin);
BVH.cpp:    xmax = GETMAX(leftBox->xmax, rightBox->xmax);
BVH.cpp:    ymin = GETMIN(leftBox->ymin, rightBox->ymin);
BVH.cpp:    ymax = GETMAX(leftBox->ymax, rightBox->ymax);
BVH.cpp:    zmin = GETMIN(leftBox->zmin, rightBox->zmin);
BVH.cpp:    zmax = GETMAX(leftBox->zmax, rightBox->zmax);
BVH.cpp:  xmin = GETMIN(leftBox->xmin, rightBox->xmin);
BVH.cpp:  xmax = GETMAX(leftBox->xmax, rightBox->xmax);
BVH.cpp:  ymin = GETMIN(leftBox->ymin, rightBox->ymin);
BVH.cpp:  ymax = GETMAX(leftBox->ymax, rightBox->ymax);
BVH.cpp:  zmin = GETMIN(leftBox->zmin, rightBox->zmin);
BVH.cpp:  zmax = GETMAX(leftBox->zmax, rightBox->zmax);
BVH.cpp:    return tri->getHeightTo(x, y);
BVH.cpp:    float toL = -1.0f, toR = -1.0f;
BVH.cpp:    if (leftBox && leftBox->xmin <= x && leftBox->xmax >= x && leftBox->ymin <= y && leftBox->ymax >= y)
BVH.cpp:      toL = leftBox->heightToTri(x, y);
BVH.cpp:    if (rightBox && rightBox->xmin <= x && rightBox->xmax >= x && rightBox->ymin <= y && rightBox->ymax >= y)
BVH.cpp:      toR = rightBox->heightToTri(x, y);
BVH.cpp:    tMinX = aX * (xmin - originX);
BVH.cpp:    tMaxX = aX * (xmax - originX);
BVH.cpp:    tMinX = aX * (xmax - originX);
BVH.cpp:    tMaxX = aX * (xmin - originX);
BVH.cpp:    tMinY = aY * (ymin - originY);
BVH.cpp:    tMaxY = aY * (ymax - originY);
BVH.cpp:    tMinY = aY * (ymax - originY);
BVH.cpp:    tMaxY = aY * (ymin - originY);
BVH.cpp:    tMinZ = aZ * (zmin - originZ);
BVH.cpp:    tMaxZ = aZ * (zmax - originZ);
BVH.cpp:    tMinZ = aZ * (zmax - originZ);
BVH.cpp:    tMaxZ = aZ * (zmin - originZ);
BVH.cpp:    return tri->rayTriangleIntersect(ray, rec, t0, t1);
BVH.cpp:      leftHit = leftBox->rayHit(ray, lrec);
BVH.cpp:      rightHit = rightBox->rayHit(ray, rrec);
BVH.h: * This file is part of QES-Winds
BVH.h: * GPL-3.0 License
BVH.h: * QES-Winds is free software: you can redistribute it and/or modify
BVH.h: * QES-Winds is distributed in the hope that it will be useful,
BVH.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
BVH.h:   * Takes a point in the xy-plane and finds what Triangle is directly above
BVH.h:   * @param x x-position
BVH.h:   * @param y y-position
Canopy.cpp: * This file is part of QES-Winds
Canopy.cpp: * GPL-3.0 License
Canopy.cpp: * QES-Winds is free software: you can redistribute it and/or modify
Canopy.cpp: * QES-Winds is distributed in the hope that it will be useful,
Canopy.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Canopy.cpp:  wakeFlag = WID->canopies->wakeFlag;
Canopy.cpp:  nx_canopy = WGD->nx - 1;
Canopy.cpp:  ny_canopy = WGD->ny - 1;
Canopy.cpp:  nz_canopy = WGD->nz - 1;
Canopy.cpp:  // number of cell cell-center elements (2D)
Canopy.cpp:  // number of cell cell-center elements (3D)
Canopy.cpp:  // Resize the canopy-related vectors
Canopy.cpp:  wake_u_defect.resize(WGD->numcell_face, 0.0);
Canopy.cpp:  wake_v_defect.resize(WGD->numcell_face, 0.0);
Canopy.cpp:  if (WID->canopies->SHPData) {
Canopy.cpp:    WID->canopies->SHPData->getLocalDomain(shpDomainSize);
Canopy.cpp:    WID->canopies->SHPData->getMinExtent(minExtent);
Canopy.cpp:    if (WID->simParams->UTMx != 0.0 && WID->simParams->UTMy != 0.0) {
Canopy.cpp:      minExtent[0] -= (minExtent[0] - WID->simParams->UTMx);
Canopy.cpp:      minExtent[1] -= (minExtent[1] - WID->simParams->UTMy);
Canopy.cpp:    for (auto pIdx = 0u; pIdx < WID->canopies->SHPData->m_polygons.size(); pIdx++) {
Canopy.cpp:      for (auto lIdx = 0u; lIdx < WID->canopies->SHPData->m_polygons[pIdx].size(); lIdx++) {
Canopy.cpp:        WID->canopies->SHPData->m_polygons[pIdx][lIdx].x_poly -= minExtent[0];
Canopy.cpp:        WID->canopies->SHPData->m_polygons[pIdx][lIdx].y_poly -= minExtent[1];
Canopy.cpp:      if (WID->simParams->DTE_heightField && WID->simParams->DTE_mesh) {
Canopy.cpp:      for (auto lIdx = 0u; lIdx < WID->canopies->SHPData->m_polygons[pIdx].size(); lIdx++) {
Canopy.cpp:        WID->canopies->SHPData->m_polygons[pIdx][lIdx].x_poly += WID->simParams->halo_x;
Canopy.cpp:        WID->canopies->SHPData->m_polygons[pIdx][lIdx].y_poly += WID->simParams->halo_y;
Canopy.cpp:      allCanopiesV.push_back(new CanopyIsolatedTree(WID->canopies->SHPData->m_polygons[pIdx],
Canopy.cpp:                                                    WID->canopies->SHPData->m_features["H"][pIdx],
Canopy.cpp:                                                    WID->canopies->SHPData->m_features["D"][pIdx],
Canopy.cpp:                                                    WID->canopies->SHPData->m_features["LAI"][pIdx],
Canopy.cpp:      allCanopiesV[cId]->setPolyBuilding(WGD);
Canopy.cpp:      allCanopiesV[cId]->setCellFlags(WID, WGD, cId);
Canopy.cpp:      effective_height.push_back(allCanopiesV[cId]->height_eff);
Canopy.cpp:  for (size_t i = 0; i < WID->canopies->canopies.size(); i++) {
Canopy.cpp:    allCanopiesV.push_back(WID->canopies->canopies[i]);
Canopy.cpp:    for (auto pIdx = 0u; pIdx < allCanopiesV[cId]->polygonVertices.size(); pIdx++) {
Canopy.cpp:      allCanopiesV[cId]->polygonVertices[pIdx].x_poly += WID->simParams->halo_x;
Canopy.cpp:      allCanopiesV[cId]->polygonVertices[pIdx].y_poly += WID->simParams->halo_y;
Canopy.cpp:    allCanopiesV[cId]->setPolyBuilding(WGD);
Canopy.cpp:    allCanopiesV[cId]->setCellFlags(WID, WGD, cId);
Canopy.cpp:    effective_height.push_back(allCanopiesV[cId]->height_eff);
Canopy.cpp:  std::chrono::duration<float> elapsed_cut = canopysetup_finish - canopysetup_start;
Canopy.cpp:    //allBuildingsV[building_id[i]]->canopyVegetation(this, building_id[i]);
Canopy.cpp:    allCanopiesV[canopy_id[i]]->canopyVegetation(WGD, canopy_id[i]);
Canopy.cpp:      //allBuildingsV[building_id[i]]->canopyVegetation(this, building_id[i]);
Canopy.cpp:      allCanopiesV[canopy_id[i]]->canopyWake(WGD, canopy_id[i]);
Canopy.cpp:      WGD->u0[id] *= (1. - wake_u_defect[id]);
Canopy.cpp:      WGD->v0[id] *= (1. - wake_v_defect[id]);
Canopy.cpp:        int icell_3d = i + j * nx_canopy + (canopy_top_index[icell_2d] - 1) * nx_canopy * ny_canopy;
Canopy.cpp:                                             WGD->vk,
Canopy.cpp:        // std::cout << "WGD->vk:" << WGD->vk << "\n";
Canopy.cpp:        // std::cout << "WGD->canopy_atten[icell_cent]:" << WGD->canopy_atten[icell_cent] << "\n";
Canopy.cpp:        // Local variable - not being used by anything... so
Canopy.cpp:        // float u_H = (WGD->canopy_ustar[id]/WGD->vk)*
Canopy.cpp:        //  log((WGD->canopy_top[id]-WGD->canopy_d[id])/WGD->canopy_z0[id]);
Canopy.cpp:        for (auto k = 1; k < WGD->nz - 1; k++) {
Canopy.cpp:          int icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
Canopy.cpp:          float z_rel = WGD->z[k] - WGD->terrain[icell_2d];
Canopy.cpp:          if (WGD->z[k] < canopy_base[icell_2d]) {
Canopy.cpp:          } else if (WGD->z[k] < canopy_top[icell_2d]) {
Canopy.cpp:                  || canopy_atten_coeff[icell_3d - nx_canopy * ny_canopy] != canopy_atten_coeff[icell_3d]) {
Canopy.cpp:                if (canopy_atten_coeff[icell_3d - nx_canopy * ny_canopy] > 0) {
Canopy.cpp:                  avg_atten += canopy_atten_coeff[icell_3d - nx_canopy * ny_canopy];
Canopy.cpp:              veg_vel_frac = log((canopy_top[icell_2d] - canopy_d[icell_2d])/
Canopy.cpp:                                 canopy_z0[icell_2d])*exp(avg_atten*((WGD->z[k]/canopy_top[icell_2d])-1))/
Canopy.cpp:                  log(WGD->z[k]/canopy_z0[icell_2d]);
Canopy.cpp:              veg_vel_frac = log((canopy_height[icell_2d] - canopy_d[icell_2d]) / canopy_z0[icell_2d])
Canopy.cpp:                             * exp(avg_atten * ((z_rel / canopy_height[icell_2d]) - 1)) / log(z_rel / canopy_z0[icell_2d]);
Canopy.cpp:              WGD->u0[icell_face] *= veg_vel_frac;
Canopy.cpp:              WGD->v0[icell_face] *= veg_vel_frac;
Canopy.cpp:              if (j < WGD->ny - 2) {
Canopy.cpp:                  WGD->v0[icell_face + WGD->nx] *= veg_vel_frac;
Canopy.cpp:              if (i < WGD->nx - 2) {
Canopy.cpp:                  WGD->u0[icell_face + 1] *= veg_vel_frac;
Canopy.cpp:            veg_vel_frac = log((z_rel - canopy_d[icell_2d]) / canopy_z0[icell_2d]) / log(z_rel / canopy_z0[icell_2d]);
Canopy.cpp:            WGD->u0[icell_face] *= veg_vel_frac;
Canopy.cpp:            WGD->v0[icell_face] *= veg_vel_frac;
Canopy.cpp:            if (j < WGD->ny - 2) {
Canopy.cpp:                WGD->v0[icell_face + WGD->nx] *= veg_vel_frac;
Canopy.cpp:            if (i < WGD->nx - 2) {
Canopy.cpp:                WGD->u0[icell_face + 1] *= veg_vel_frac;
Canopy.cpp:        }// end of for(auto k=1; k < WGD->nz-1; k++)
Canopy.cpp:        for (auto k = canopy_top_index[id]; k < WGD->nz - 2; k++) {
Canopy.cpp:          if (canopy_top[id] + canopy_height[id] < WGD->z[k + 1])
Canopy.cpp:        if (k_top > WGD->nz - 1) {
Canopy.cpp:          k_top = WGD->nz - 1;
Canopy.cpp:          int icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
Canopy.cpp:          local_mag = sqrt(pow(WGD->u0[icell_face], 2.0) + pow(WGD->v0[icell_face], 2.0));
Canopy.cpp:          y = log(WGD->z[k] - WGD->terrain[i + j * (WGD->nx - 1)]);
Canopy.cpp:        canopy_ustar[id] = WGD->vk * (((counter * sum_x_sq) - pow(sum_x, 2.0)) / ((counter * sum_xy) - (sum_x * sum_y)));
Canopy.cpp:        canopy_z0[id] = exp(ym - ((WGD->vk / canopy_ustar[id])) * xm);
Canopy.cpp:  uhc = (ustar / vk) * (log((canopy_top - d1) / z0) + psi_m);
Canopy.cpp:  fi = ((canopy_atten * uhc * vk) / ustar) - canopy_top / (canopy_top - d1);
Canopy.cpp:      uhc = (ustar / vk) * (log((canopy_top - d) / z0) + psi_m);
Canopy.cpp:      fnew = ((canopy_atten * uhc * vk) / ustar) - canopy_top / (canopy_top - d);
Canopy.cpp:  // log[(H-d)/z0] = H/[a(H-d)]
Canopy.cpp:  // d2 max displacement possible - canopy top
Canopy.cpp:      f = log((canopy_top - d) / z0) - (canopy_top / (canopy_atten * (canopy_top - d)));
Canopy.cpp:    effective_height_R.resize(allCanopiesV.size() - allCanopiesV.size() / 2);
Canopy.cpp:    tree_id_R.resize(allCanopiesV.size() - allCanopiesV.size() / 2);
Canopy.cpp:    allCanopiesV_R.resize(allCanopiesV.size() - allCanopiesV.size() / 2);
CanopyElement.cpp:  building_cent_x = 0.0;// x-coordinate of the centroid of the building
CanopyElement.cpp:  building_cent_y = 0.0;// y-coordinate of the centroid of the building
CanopyElement.cpp:  for (auto i = 0; i < polygonVertices.size() - 1; i++) {
CanopyElement.cpp:  building_cent_x /= polygonVertices.size() - 1;
CanopyElement.cpp:  building_cent_y /= polygonVertices.size() - 1;
CanopyElement.cpp:  i_building_cent = std::round(building_cent_x / WGD->dx) - 1;// Index of building centroid in x-direction
CanopyElement.cpp:  j_building_cent = std::round(building_cent_y / WGD->dy) - 1;// Index of building centroid in y-direction
CanopyElement.cpp:  i_start = x_min / WGD->dx;// Index of canopy start location in x-direction
CanopyElement.cpp:  i_end = x_max / WGD->dx + 1;// Index of canopy end location in x-direction
CanopyElement.cpp:  j_start = y_min / WGD->dy;// Index of canopy end location in y-direction
CanopyElement.cpp:  j_end = y_max / WGD->dy + 1;// Index of canopy start location in y-direction
CanopyElement.cpp:  i_start = x_min / WGD->dx;// Index of canopy start location in x-direction
CanopyElement.cpp:  i_end = x_max / WGD->dx + 1;// Index of canopy end location in x-direction
CanopyElement.cpp:  j_start = y_min / WGD->dy;// Index of canopy end location in y-direction
CanopyElement.cpp:  j_end = y_max / WGD->dy + 1;// Index of canopy start location in y-direction
CanopyElement.cpp:  // size of the canopy array -> with ghost cell before and after (hence +2)
CanopyElement.cpp:  nx_canopy = (i_end - i_start - 1) + 2;
CanopyElement.cpp:  ny_canopy = (j_end - j_start - 1) + 2;
CanopyElement.cpp:  // number of cell cell-center elements (2D)
CanopyElement.cpp:  // Resize the canopy-related vectors
CanopyElement.cpp:  canopy_top_index.resize(numcell_cent_2d, -1);
CanopyElement.cpp:  // Based on Wm. Randolph Franklin, "PNPOLY - Point Inclusion in Polygon Test"
CanopyElement.cpp:    float y_cent = (j + 0.5) * WGD->dy;
CanopyElement.cpp:      float x_cent = (i + 0.5) * WGD->dx;
CanopyElement.cpp:      while (vert_id < polygonVertices.size() - 1) {
CanopyElement.cpp:          ray_intersect = (y_cent - polygonVertices[vert_id].y_poly) / (polygonVertices[vert_id + 1].y_poly - polygonVertices[vert_id].y_poly);
CanopyElement.cpp:          if (x_cent < (polygonVertices[vert_id].x_poly + ray_intersect * (polygonVertices[vert_id + 1].x_poly - polygonVertices[vert_id].x_poly))) {
CanopyElement.cpp:        int icell_cent_2d = i + j * (WGD->nx - 1);
CanopyElement.cpp:        int icell_canopy_2d = (i + 1 - i_start) + (j + 1 - j_start) * nx_canopy;
CanopyElement.cpp:        for (size_t k = 0; k < WGD->z.size() - 1; k++) {
CanopyElement.cpp:          int icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyElement.cpp:          if (WGD->icellflag[icell_cent] == 2) {
CanopyElement.cpp:          } else if (WGD->icellflag[icell_cent] == 0) {
CanopyElement.cpp:          // Define start index of the canopy in z-direction
CanopyElement.cpp:          if (WGD->terrain[icell_cent_2d] + base_height > WGD->z_face[k]
CanopyElement.cpp:              && WGD->terrain[icell_cent_2d] + base_height <= WGD->z_face[k + 1]) {
CanopyElement.cpp:            canopy_bot[icell_canopy_2d] = WGD->terrain[icell_cent_2d] + base_height;
CanopyElement.cpp:            canopy_base[icell_canopy_2d] = WGD->z_face[k - 1];
CanopyElement.cpp:          // Define end index of the canopy in z-direction
CanopyElement.cpp:          if (WGD->terrain[icell_cent_2d] + H >= WGD->z_face[k]
CanopyElement.cpp:              && WGD->terrain[icell_cent_2d] + H < WGD->z_face[k + 1]) {
CanopyElement.cpp:            canopy_top[icell_canopy_2d] = WGD->terrain[icell_cent_2d] + H;
CanopyElement.cpp:          WGD->icellflag[icell_cent] = getCellFlagCanopy();
CanopyElement.cpp:          WGD->ibuilding_flag[icell_cent] = building_number;
CanopyElement.cpp:        // Define hieght of the canopy base in z-direction
CanopyElement.cpp:        canopy_height[icell_canopy_2d] = canopy_top[icell_canopy_2d] - canopy_bot[icell_canopy_2d];
CanopyElement.cpp:            int icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
CanopyElement.cpp:            if( WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
CanopyElement.cpp:                WGD->icellflag[icell_cent] = getCellFlagCanopy();
CanopyElement.cpp:                WGD->ibuilding_flag[icell_cent] = building_number;
CanopyElement.cpp:    // Define start/end index of the canopy in z-direction
CanopyElement.cpp:    k_start = WGD->nz;
CanopyElement.cpp:    // number of point in z -> + 2 (1 ghost below, 1 ghost above)
CanopyElement.cpp:  // number of cell-center elements (3D)
CanopyElement.cpp:        int icell_3d = i + j * nx_canopy + (canopy_top_index[icell_2d] - 1) * nx_canopy * ny_canopy;
CanopyElement.cpp:                                             WGD->vk,
CanopyElement.cpp:        // std::cout << "WGD->vk:" << WGD->vk << "\n";
CanopyElement.cpp:        // std::cout << "WGD->canopy_atten[icell_cent]:" << WGD->canopy_atten[icell_cent] << "\n";
CanopyElement.cpp:        // Local variable - not being used by anything... so
CanopyElement.cpp:        // float u_H = (WGD->canopy_ustar[id]/WGD->vk)*
CanopyElement.cpp:        //  log((WGD->canopy_top[id]-WGD->canopy_d[id])/WGD->canopy_z0[id]);
CanopyElement.cpp:        for (auto k = 1; k < WGD->nz - 1; k++) {
CanopyElement.cpp:          int icell_face = (i - 1 + i_start) + (j - 1 + j_start) * WGD->nx + k * WGD->nx * WGD->ny;
CanopyElement.cpp:          float z_rel = WGD->z[k] - canopy_base[icell_2d];
CanopyElement.cpp:          if (WGD->z[k] < canopy_base[icell_2d]) {
CanopyElement.cpp:          } else if (WGD->z[k] < canopy_top[icell_2d]) {
CanopyElement.cpp:                  || canopy_atten[icell_3d - nx_canopy * ny_canopy] != canopy_atten[icell_3d]) {
CanopyElement.cpp:                if (canopy_atten[icell_3d - nx_canopy * ny_canopy] > 0) {
CanopyElement.cpp:                  avg_atten += canopy_atten[icell_3d - nx_canopy * ny_canopy];
CanopyElement.cpp:              veg_vel_frac = log((canopy_top[icell_2d] - canopy_d[icell_2d])/
CanopyElement.cpp:                                 canopy_z0[icell_2d])*exp(avg_atten*((WGD->z[k]/canopy_top[icell_2d])-1))/
CanopyElement.cpp:                  log(WGD->z[k]/canopy_z0[icell_2d]);
CanopyElement.cpp:              veg_vel_frac = log((canopy_height[icell_2d] - canopy_d[icell_2d]) / canopy_z0[icell_2d])
CanopyElement.cpp:                             * exp(avg_atten * ((z_rel / canopy_height[icell_2d]) - 1)) / log(z_rel / canopy_z0[icell_2d]);
CanopyElement.cpp:              WGD->u0[icell_face] *= veg_vel_frac;
CanopyElement.cpp:              WGD->v0[icell_face] *= veg_vel_frac;
CanopyElement.cpp:              if (j - 1 + j_start < WGD->ny - 2) {
CanopyElement.cpp:                  WGD->v0[icell_face + WGD->nx] *= veg_vel_frac;
CanopyElement.cpp:              if (i - 1 + i_start < WGD->nx - 2) {
CanopyElement.cpp:                  WGD->u0[icell_face + 1] *= veg_vel_frac;
CanopyElement.cpp:            veg_vel_frac = log((z_rel - canopy_d[icell_2d]) / canopy_z0[icell_2d]) / log(z_rel / canopy_z0[icell_2d]);
CanopyElement.cpp:            WGD->u0[icell_face] *= veg_vel_frac;
CanopyElement.cpp:            WGD->v0[icell_face] *= veg_vel_frac;
CanopyElement.cpp:            if (j - 1 + j_start < WGD->ny - 2) {
CanopyElement.cpp:                WGD->v0[icell_face + WGD->nx] *= veg_vel_frac;
CanopyElement.cpp:            if (i - 1 + i_start < WGD->nx - 2) {
CanopyElement.cpp:                WGD->u0[icell_face + 1] *= veg_vel_frac;
CanopyElement.cpp:        }// end of for(auto k=1; k < WGD->nz-1; k++)
CanopyElement.cpp:  uhc = (ustar / vk) * (log((canopy_top - d1) / z0) + psi_m);
CanopyElement.cpp:  fi = ((canopy_atten * uhc * vk) / ustar) - canopy_top / (canopy_top - d1);
CanopyElement.cpp:      uhc = (ustar / vk) * (log((canopy_top - d) / z0) + psi_m);
CanopyElement.cpp:      fnew = ((canopy_atten * uhc * vk) / ustar) - canopy_top / (canopy_top - d);
CanopyElement.cpp:  // log[(H-d)/z0] = H/[a(H-d)]
CanopyElement.cpp:  // d2 max displacement possible - canopy top
CanopyElement.cpp:      f = log((canopy_top - d) / z0) - (canopy_top / (canopy_atten * (canopy_top - d)));
CanopyElement.h: * This file is part of QES-Winds
CanopyElement.h: * GPL-3.0 License
CanopyElement.h: * QES-Winds is free software: you can redistribute it and/or modify
CanopyElement.h: * QES-Winds is distributed in the hope that it will be useful,
CanopyElement.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Canopy.h: * This file is part of QES-Winds
Canopy.h: * GPL-3.0 License
Canopy.h: * QES-Winds is free software: you can redistribute it and/or modify
Canopy.h: * QES-Winds is distributed in the hope that it will be useful,
Canopy.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
CanopyHomogeneous.cpp: * This file is part of QES-Winds
CanopyHomogeneous.cpp: * GPL-3.0 License
CanopyHomogeneous.cpp: * QES-Winds is free software: you can redistribute it and/or modify
CanopyHomogeneous.cpp: * QES-Winds is distributed in the hope that it will be useful,
CanopyHomogeneous.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
CanopyHomogeneous.cpp:  // Based on Wm. Randolph Franklin, "PNPOLY - Point Inclusion in Polygon Test"
CanopyHomogeneous.cpp:    float y_cent = (j + 0.5) * WGD->dy;
CanopyHomogeneous.cpp:      float x_cent = (i + 0.5) * WGD->dx;
CanopyHomogeneous.cpp:      while (vert_id < polygonVertices.size() - 1) {
CanopyHomogeneous.cpp:          ray_intersect = (y_cent - polygonVertices[vert_id].y_poly) / (polygonVertices[vert_id + 1].y_poly - polygonVertices[vert_id].y_poly);
CanopyHomogeneous.cpp:          if (x_cent < (polygonVertices[vert_id].x_poly + ray_intersect * (polygonVertices[vert_id + 1].x_poly - polygonVertices[vert_id].x_poly))) {
CanopyHomogeneous.cpp:        int icell_2d = i + j * (WGD->nx - 1);
CanopyHomogeneous.cpp:        if (WGD->icellflag_footprint[icell_2d] == 0) {
CanopyHomogeneous.cpp:          // a  building exist here -> skip
CanopyHomogeneous.cpp:          WGD->icellflag_footprint[icell_2d] = getCellFlagCanopy();
CanopyHomogeneous.cpp:          // Define start index of the canopy in z-direction
CanopyHomogeneous.cpp:          for (size_t k = 1u; k < WGD->z.size(); k++) {
CanopyHomogeneous.cpp:            if (WGD->terrain[icell_2d] + base_height <= WGD->z[k]) {
CanopyHomogeneous.cpp:              WGD->canopy->canopy_bot_index[icell_2d] = k;
CanopyHomogeneous.cpp:              WGD->canopy->canopy_bot[icell_2d] = WGD->terrain[icell_2d] + base_height;
CanopyHomogeneous.cpp:              WGD->canopy->canopy_base[icell_2d] = WGD->z_face[k - 1];
CanopyHomogeneous.cpp:          // Define end index of the canopy in z-direction
CanopyHomogeneous.cpp:          for (size_t k = 0u; k < WGD->z.size(); k++) {
CanopyHomogeneous.cpp:            if (WGD->terrain[icell_2d] + H < WGD->z[k + 1]) {
CanopyHomogeneous.cpp:              WGD->canopy->canopy_top_index[icell_2d] = k + 1;
CanopyHomogeneous.cpp:              WGD->canopy->canopy_top[icell_2d] = WGD->terrain[icell_2d] + H;
CanopyHomogeneous.cpp:          WGD->canopy->canopy_height[icell_2d] = WGD->canopy->canopy_top[icell_2d] - WGD->canopy->canopy_bot[icell_2d];
CanopyHomogeneous.cpp:          for (auto k = WGD->canopy->canopy_bot_index[icell_2d]; k < WGD->canopy->canopy_top_index[icell_2d]; k++) {
CanopyHomogeneous.cpp:            int icell_3d = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyHomogeneous.cpp:            if (WGD->icellflag[icell_3d] != 0 && WGD->icellflag[icell_3d] != 2) {
CanopyHomogeneous.cpp:              WGD->icellflag[icell_3d] = getCellFlagCanopy();
CanopyHomogeneous.cpp:              WGD->canopy->canopy_atten_coeff[icell_3d] = attenuationCoeff;
CanopyHomogeneous.cpp:              WGD->canopy->icanopy_flag[icell_3d] = tree_id;
CanopyHomogeneous.cpp:    k_start = WGD->nz - 1;
CanopyHomogeneous.cpp:      if (WGD->canopy->canopy_bot_index[canopy_cell2D[k]] < k_start)
CanopyHomogeneous.cpp:        k_start = WGD->canopy->canopy_bot_index[canopy_cell2D[k]];
CanopyHomogeneous.cpp:      if (WGD->canopy->canopy_top_index[canopy_cell2D[k]] > k_end)
CanopyHomogeneous.cpp:        k_end = WGD->canopy->canopy_top_index[canopy_cell2D[k]];
CanopyHomogeneous.cpp:    if (WGD->canopy->canopy_top[icell_2d] > 0) {
CanopyHomogeneous.cpp:      int j = (int)((icell_2d) / (WGD->nx - 1));
CanopyHomogeneous.cpp:      int i = icell_2d - j * (WGD->nx - 1);
CanopyHomogeneous.cpp:      int icell_cent_top = icell_2d + (WGD->canopy->canopy_top_index[icell_2d] - 1) * (WGD->nx - 1) * (WGD->ny - 1);
CanopyHomogeneous.cpp:      WGD->canopy->canopy_d[icell_2d] = canopyBisection(WGD->canopy->canopy_ustar[icell_2d],
CanopyHomogeneous.cpp:                                                        WGD->canopy->canopy_z0[icell_2d],
CanopyHomogeneous.cpp:                                                        WGD->canopy->canopy_height[icell_2d],
CanopyHomogeneous.cpp:                                                        WGD->canopy->canopy_atten_coeff[icell_cent_top],
CanopyHomogeneous.cpp:                                                        WGD->vk,
CanopyHomogeneous.cpp:      // std::cout << "WGD->vk:" << WGD->vk << "\n";
CanopyHomogeneous.cpp:      // std::cout << "WGD->canopy_atten[icell_cent]:" << WGD->canopy_atten[icell_cent] << "\n";
CanopyHomogeneous.cpp:      if (WGD->canopy->canopy_d[icell_2d] == 10000) {
CanopyHomogeneous.cpp:                  << WGD->canopy->canopy_ustar[icell_2d] << " "
CanopyHomogeneous.cpp:                  << WGD->canopy->canopy_z0[icell_2d] << " "
CanopyHomogeneous.cpp:                  << WGD->canopy->canopy_atten_coeff[icell_cent_top] << std::endl;
CanopyHomogeneous.cpp:        WGD->canopy->canopy_d[icell_2d] = canopySlopeMatch(WGD->canopy->canopy_z0[icell_2d],
CanopyHomogeneous.cpp:                                                           WGD->canopy->canopy_height[icell_2d],
CanopyHomogeneous.cpp:                                                           WGD->canopy->canopy_atten_coeff[icell_cent_top]);
CanopyHomogeneous.cpp:      // Local variable - not being used by anything... so
CanopyHomogeneous.cpp:      // float u_H = (WGD->canopy_ustar[id]/WGD->vk)*
CanopyHomogeneous.cpp:      //  log((WGD->canopy_top[id]-WGD->canopy_d[id])/WGD->canopy_z0[id]);
CanopyHomogeneous.cpp:      for (auto k = 1; k < WGD->nz - 1; k++) {
CanopyHomogeneous.cpp:        int icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
CanopyHomogeneous.cpp:        int icell_cent = icell_2d + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyHomogeneous.cpp:        float z_rel = WGD->z[k] - WGD->z[WGD->terrain_id[icell_2d]];
CanopyHomogeneous.cpp:          // below the terrain -> skip
CanopyHomogeneous.cpp:        } else if (z_rel < WGD->canopy->canopy_height[icell_2d]) {
CanopyHomogeneous.cpp:          avg_atten = WGD->canopy->canopy_atten_coeff[icell_cent];
CanopyHomogeneous.cpp:          // FM -> calculate averaged attenuation coef. (TO BE TESTE)
CanopyHomogeneous.cpp:          if (WGD->canopy->canopy_atten_coeff[icell_cent + nx_canopy * ny_canopy] != WGD->canopy->canopy_atten_coeff[icell_cent]
CanopyHomogeneous.cpp:              || WGD->canopy->canopy_atten_coeff[icell_cent - nx_canopy * ny_canopy] != WGD->canopy->canopy_atten_coeff[icell_cent]) {
CanopyHomogeneous.cpp:            if (WGD->canopy->canopy_atten_coeff[icell_cent + nx_canopy * ny_canopy] > 0) {
CanopyHomogeneous.cpp:              avg_atten += WGD->canopy->canopy_atten_coeff[icell_cent + nx_canopy * ny_canopy];
CanopyHomogeneous.cpp:            if (WGD->canopy->canopy_atten_coeff[icell_cent - nx_canopy * ny_canopy] > 0) {
CanopyHomogeneous.cpp:              avg_atten += WGD->canopy->canopy_atten_coeff[icell_cent - nx_canopy * ny_canopy];
CanopyHomogeneous.cpp:          veg_vel_frac = log((WGD->canopy->canopy_height[icell_2d] - WGD->canopy->canopy_d[icell_2d]) / WGD->canopy->canopy_z0[icell_2d])
CanopyHomogeneous.cpp:                         * exp(avg_atten * ((z_rel / WGD->canopy->canopy_height[icell_2d]) - 1)) / log(z_rel / WGD->canopy->canopy_z0[icell_2d]);
CanopyHomogeneous.cpp:          WGD->u0[icell_face] *= veg_vel_frac;
CanopyHomogeneous.cpp:          WGD->v0[icell_face] *= veg_vel_frac;
CanopyHomogeneous.cpp:          if (i < WGD->nx - 2) {
CanopyHomogeneous.cpp:            if (WGD->canopy->canopy_top[icell_2d + 1] == 0.0) {
CanopyHomogeneous.cpp:              WGD->u0[icell_face + 1] *= veg_vel_frac;
CanopyHomogeneous.cpp:          if (j < WGD->ny - 2) {
CanopyHomogeneous.cpp:            if (WGD->canopy->canopy_top[icell_2d + (WGD->nx - 1)] == 0.0) {
CanopyHomogeneous.cpp:              WGD->v0[icell_face + WGD->nx] *= veg_vel_frac;
CanopyHomogeneous.cpp:          veg_vel_frac = log((z_rel - WGD->canopy->canopy_d[icell_2d]) / WGD->canopy->canopy_z0[icell_2d])
CanopyHomogeneous.cpp:                         / log(z_rel / WGD->canopy->canopy_z0[icell_2d]);
CanopyHomogeneous.cpp:          WGD->u0[icell_face] *= veg_vel_frac;
CanopyHomogeneous.cpp:          WGD->v0[icell_face] *= veg_vel_frac;
CanopyHomogeneous.cpp:          if (i < WGD->nx - 2) {
CanopyHomogeneous.cpp:            if (WGD->canopy->canopy_top[icell_2d + 1] == 0.0) {
CanopyHomogeneous.cpp:              WGD->u0[icell_face + 1] *= veg_vel_frac;
CanopyHomogeneous.cpp:          if (j < WGD->ny - 2) {
CanopyHomogeneous.cpp:            if (WGD->canopy->canopy_top[icell_2d + (WGD->nx - 1)] == 0.0) {
CanopyHomogeneous.cpp:              WGD->v0[icell_face + WGD->nx] *= veg_vel_frac;
CanopyHomogeneous.cpp:      }// end of for(auto k=1; k < WGD->nz-1; k++)
CanopyHomogeneous.h: * This file is part of QES-Winds
CanopyHomogeneous.h: * GPL-3.0 License
CanopyHomogeneous.h: * QES-Winds is free software: you can redistribute it and/or modify
CanopyHomogeneous.h: * QES-Winds is distributed in the hope that it will be useful,
CanopyHomogeneous.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
CanopyHomogeneous.h:      polygonVertices[1].x_poly = x_start - W * sin(canopy_rotation);
CanopyHomogeneous.h:      std::cerr << "[ERROR] Homogeneous canopy ill-defined" << std::endl;
CanopyIsolatedTree.cpp: * This file is part of QES-Winds
CanopyIsolatedTree.cpp: * GPL-3.0 License
CanopyIsolatedTree.cpp: * QES-Winds is free software: you can redistribute it and/or modify
CanopyIsolatedTree.cpp: * QES-Winds is distributed in the hope that it will be useful,
CanopyIsolatedTree.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
CanopyIsolatedTree.cpp:  // Based on Wm. Randolph Franklin, "PNPOLY - Point Inclusion in Polygon Test"
CanopyIsolatedTree.cpp:    float y_cent = (j + 0.5) * WGD->dy;
CanopyIsolatedTree.cpp:      float x_cent = (i + 0.5) * WGD->dx;
CanopyIsolatedTree.cpp:      while (vert_id < polygonVertices.size() - 1) {
CanopyIsolatedTree.cpp:          ray_intersect = (y_cent - polygonVertices[vert_id].y_poly) / (polygonVertices[vert_id + 1].y_poly - polygonVertices[vert_id].y_poly);
CanopyIsolatedTree.cpp:          if (x_cent < (polygonVertices[vert_id].x_poly + ray_intersect * (polygonVertices[vert_id + 1].x_poly - polygonVertices[vert_id].x_poly))) {
CanopyIsolatedTree.cpp:        int icell_2d = i + j * (WGD->nx - 1);
CanopyIsolatedTree.cpp:        if (WGD->icellflag_footprint[icell_2d] == 0) {
CanopyIsolatedTree.cpp:          // a  building exist here -> skip
CanopyIsolatedTree.cpp:          // Define start index of the canopy in z-direction
CanopyIsolatedTree.cpp:          for (size_t k = 1u; k < WGD->z.size(); k++) {
CanopyIsolatedTree.cpp:            if (WGD->terrain[icell_2d] + base_height <= WGD->z[k]) {
CanopyIsolatedTree.cpp:              WGD->canopy->canopy_bot_index[icell_2d] = k;
CanopyIsolatedTree.cpp:              WGD->canopy->canopy_bot[icell_2d] = WGD->terrain[icell_2d] + base_height;
CanopyIsolatedTree.cpp:              WGD->canopy->canopy_base[icell_2d] = WGD->z_face[k - 1];
CanopyIsolatedTree.cpp:          // Define end index of the canopy in z-direction
CanopyIsolatedTree.cpp:          for (size_t k = 0u; k < WGD->z.size(); k++) {
CanopyIsolatedTree.cpp:            if (WGD->terrain[icell_2d] + H < WGD->z[k + 1]) {
CanopyIsolatedTree.cpp:              WGD->canopy->canopy_top_index[icell_2d] = k + 1;
CanopyIsolatedTree.cpp:              WGD->canopy->canopy_top[icell_2d] = WGD->terrain[icell_2d] + H;
CanopyIsolatedTree.cpp:          WGD->icellflag_footprint[icell_2d] = getCellFlagCanopy();
CanopyIsolatedTree.cpp:          WGD->canopy->canopy_height[icell_2d] = WGD->canopy->canopy_top[icell_2d] - WGD->canopy->canopy_bot[icell_2d];
CanopyIsolatedTree.cpp:          for (auto k = WGD->canopy->canopy_bot_index[icell_2d]; k < WGD->canopy->canopy_top_index[icell_2d]; k++) {
CanopyIsolatedTree.cpp:            int icell_3d = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyIsolatedTree.cpp:            if (WGD->icellflag[icell_3d] != 0 && WGD->icellflag[icell_3d] != 2) {
CanopyIsolatedTree.cpp:              WGD->icellflag[icell_3d] = getCellFlagCanopy();
CanopyIsolatedTree.cpp:              WGD->canopy->canopy_atten_coeff[icell_3d] = 0.5 * LAI;
CanopyIsolatedTree.cpp:              WGD->canopy->icanopy_flag[icell_3d] = tree_id;
CanopyIsolatedTree.cpp:    k_start = WGD->nz - 1;
CanopyIsolatedTree.cpp:      if (WGD->canopy->canopy_bot_index[canopy_cell2D[k]] < k_start)
CanopyIsolatedTree.cpp:        k_start = WGD->canopy->canopy_bot_index[canopy_cell2D[k]];
CanopyIsolatedTree.cpp:      if (WGD->canopy->canopy_top_index[canopy_cell2D[k]] > k_end)
CanopyIsolatedTree.cpp:        k_end = WGD->canopy->canopy_top_index[canopy_cell2D[k]];
CanopyIsolatedTree.cpp:  if (ceil(1.5 * k_end) > WGD->nz - 1) {
CanopyIsolatedTree.cpp:    if (WGD->canopy->canopy_top[icell_2d] > 0) {
CanopyIsolatedTree.cpp:      int j = (int)((icell_2d) / (WGD->nx - 1));
CanopyIsolatedTree.cpp:      int i = icell_2d - j * (WGD->nx - 1);
CanopyIsolatedTree.cpp:      int icell_3d = icell_2d + (WGD->canopy->canopy_top_index[icell_2d] - 1) * (WGD->nx - 1) * (WGD->ny - 1);
CanopyIsolatedTree.cpp:      WGD->canopy->canopy_d[icell_2d] = canopyBisection(WGD->canopy->canopy_ustar[icell_2d],
CanopyIsolatedTree.cpp:                                                        WGD->canopy->canopy_z0[icell_2d],
CanopyIsolatedTree.cpp:                                                        WGD->canopy->canopy_height[icell_2d],
CanopyIsolatedTree.cpp:                                                        WGD->canopy->canopy_atten_coeff[icell_3d],
CanopyIsolatedTree.cpp:                                                        WGD->vk,
CanopyIsolatedTree.cpp:      // std::cout << "WGD->vk:" << WGD->vk << "\n";
CanopyIsolatedTree.cpp:      // std::cout << "WGD->canopy_atten[icell_cent]:" << WGD->canopy_atten[icell_cent] << "\n";
CanopyIsolatedTree.cpp:      if (WGD->canopy->canopy_d[icell_2d] == 10000) {
CanopyIsolatedTree.cpp:        WGD->canopy->canopy_d[icell_2d] = canopySlopeMatch(WGD->canopy->canopy_z0[icell_2d],
CanopyIsolatedTree.cpp:                                                           WGD->canopy->canopy_height[icell_2d],
CanopyIsolatedTree.cpp:                                                           WGD->canopy->canopy_atten_coeff[icell_3d]);
CanopyIsolatedTree.cpp:      // Local variable - not being used by anything... so
CanopyIsolatedTree.cpp:      // float u_H = (WGD->canopy_ustar[id]/WGD->vk)*
CanopyIsolatedTree.cpp:      //  log((WGD->canopy_top[id]-WGD->canopy_d[id])/WGD->canopy_z0[id]);
CanopyIsolatedTree.cpp:      for (auto k = 1; k < WGD->nz - 1; k++) {
CanopyIsolatedTree.cpp:        int icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
CanopyIsolatedTree.cpp:        float z_rel = WGD->z[k] - WGD->canopy->canopy_base[icell_2d];
CanopyIsolatedTree.cpp:        if (WGD->z[k] < WGD->canopy->canopy_base[icell_2d]) {
CanopyIsolatedTree.cpp:        } else if (WGD->z[k] < WGD->canopy->canopy_top[icell_2d]) {
CanopyIsolatedTree.cpp:          if (WGD->canopy->canopy_atten_coeff[icell_3d] > 0) {
CanopyIsolatedTree.cpp:            icell_3d = icell_2d + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyIsolatedTree.cpp:            avg_atten = WGD->canopy->canopy_atten_coeff[icell_3d];
CanopyIsolatedTree.cpp:            veg_vel_frac = log((WGD->canopy->canopy_height[icell_2d] - WGD->canopy->canopy_d[icell_2d]) / WGD->canopy->canopy_z0[icell_2d])
CanopyIsolatedTree.cpp:                           * exp(avg_atten * ((z_rel / WGD->canopy->canopy_height[icell_2d]) - 1)) / log(z_rel / WGD->canopy->canopy_z0[icell_2d]);
CanopyIsolatedTree.cpp:            WGD->u0[icell_face] *= veg_vel_frac;
CanopyIsolatedTree.cpp:            WGD->v0[icell_face] *= veg_vel_frac;
CanopyIsolatedTree.cpp:            if (j < WGD->ny - 2) {
CanopyIsolatedTree.cpp:              if (WGD->canopy->canopy_top[icell_2d + (WGD->nx - 1)] == 0.0) {
CanopyIsolatedTree.cpp:                WGD->v0[icell_face + WGD->nx] *= veg_vel_frac;
CanopyIsolatedTree.cpp:            if (i < WGD->nx - 2) {
CanopyIsolatedTree.cpp:              if (WGD->canopy->canopy_top[icell_2d + 1] == 0.0) {
CanopyIsolatedTree.cpp:                WGD->u0[icell_face + 1] *= veg_vel_frac;
CanopyIsolatedTree.cpp:        } else if (WGD->z[k] < 2.0 * WGD->canopy->canopy_top[icell_2d]) {
CanopyIsolatedTree.cpp:          float lam = pow((z_rel - WGD->canopy->canopy_height[icell_2d]) / (1.0 * WGD->canopy->canopy_height[icell_2d]), 1.0);
CanopyIsolatedTree.cpp:          veg_vel_frac = log((z_rel - WGD->canopy->canopy_d[icell_2d]) / WGD->canopy->canopy_z0[icell_2d])
CanopyIsolatedTree.cpp:                         / log(z_rel / WGD->canopy->canopy_z0[icell_2d]);
CanopyIsolatedTree.cpp:          veg_vel_frac = (1 - lam) * veg_vel_frac + lam;
CanopyIsolatedTree.cpp:          WGD->u0[icell_face] *= veg_vel_frac;
CanopyIsolatedTree.cpp:          WGD->v0[icell_face] *= veg_vel_frac;
CanopyIsolatedTree.cpp:          if (j < WGD->ny - 2) {
CanopyIsolatedTree.cpp:            icell_3d = icell_2d + WGD->canopy->canopy_bot_index[icell_2d] * (WGD->nx - 1) * (WGD->ny - 1);
CanopyIsolatedTree.cpp:            if (WGD->canopy->canopy_top[icell_2d + (WGD->nx - 1)] == 0.0) {
CanopyIsolatedTree.cpp:              WGD->v0[icell_face + WGD->nx] *= veg_vel_frac;
CanopyIsolatedTree.cpp:          if (i < WGD->nx - 2) {
CanopyIsolatedTree.cpp:            icell_3d = icell_2d + WGD->canopy->canopy_bot_index[icell_2d] * (WGD->nx - 1) * (WGD->ny - 1);
CanopyIsolatedTree.cpp:            if (WGD->canopy->canopy_top[icell_2d + 1] == 0.0) {
CanopyIsolatedTree.cpp:              WGD->u0[icell_face + 1] *= veg_vel_frac;
CanopyIsolatedTree.cpp:      }// end of for(auto k=1; k < WGD->nz-1; k++)
CanopyIsolatedTree.cpp:  icell_face = i_building_cent + j_building_cent * WGD->nx + (k_end + 1) * WGD->nx * WGD->ny;
CanopyIsolatedTree.cpp:  u0_h = WGD->u0[icell_face];// u velocity at the height of building at the centroid
CanopyIsolatedTree.cpp:  v0_h = WGD->v0[icell_face];// v velocity at the height of building at the centroid
CanopyIsolatedTree.cpp:  const float epsilon = 10e-10;
CanopyIsolatedTree.cpp:  int kk(0), k_bottom(1), k_top(WGD->nz - 2);
CanopyIsolatedTree.cpp:  icell_face = i_building_cent + j_building_cent * WGD->nx + (k_end + 1) * WGD->nx * WGD->ny;
CanopyIsolatedTree.cpp:  u0_h = WGD->u0[icell_face];// u velocity at the height of building at the centroid
CanopyIsolatedTree.cpp:  v0_h = WGD->v0[icell_face];// v velocity at the height of building at the centroid
CanopyIsolatedTree.cpp:  yw3 = -0.5 * wake_span_coef * H;
CanopyIsolatedTree.cpp:    if (base_height <= WGD->z[k])
CanopyIsolatedTree.cpp:  for (auto k = k_start; k < WGD->nz - 2; k++) {
CanopyIsolatedTree.cpp:    if (1.5 * (H + base_height) < WGD->z[k + 1])
CanopyIsolatedTree.cpp:    if (0.75 * H + base_height <= WGD->z[k])
CanopyIsolatedTree.cpp:  // if the whole tree (defined as center) is in a flow reversal region -> skip the wake
CanopyIsolatedTree.cpp:  icell_cent = i_building_cent + j_building_cent * (WGD->nx - 1) + kk * (WGD->nx - 1) * (WGD->ny - 1);
CanopyIsolatedTree.cpp:  if (WGD->icellflag[icell_cent] == 3 || WGD->icellflag[icell_cent] == 4 || WGD->icellflag[icell_cent] == 6)
CanopyIsolatedTree.cpp:  // mathod 1 -> location of upsteam data point (5% of 1/2 building length)
CanopyIsolatedTree.cpp:  // method 2 -> displaced log profile
CanopyIsolatedTree.cpp:    int i = ceil(((-1.05 * Lt) * cos(upwind_dir) - 0.0 * sin(upwind_dir) + building_cent_x) / WGD->dx);
CanopyIsolatedTree.cpp:    int j = ceil(((-1.05 * Lt) * sin(upwind_dir) + 0.0 * cos(upwind_dir) + building_cent_y) / WGD->dy);
CanopyIsolatedTree.cpp:    int k = k_end - 1;
CanopyIsolatedTree.cpp:    icell_2d = i + j * (WGD->nx);
CanopyIsolatedTree.cpp:    icell_face = i + j * (WGD->nx) + k * (WGD->nx) * (WGD->ny);
CanopyIsolatedTree.cpp:    z0 = WGD->z0_domain_u[icell_2d];
CanopyIsolatedTree.cpp:    float utmp = WGD->u0[icell_face];
CanopyIsolatedTree.cpp:    float vtmp = WGD->v0[icell_face];
CanopyIsolatedTree.cpp:    z_c = WGD->z[k] - base_height;
CanopyIsolatedTree.cpp:    ustar_us = mag_us * WGD->vk / (log((z_c + z0) / z0));
CanopyIsolatedTree.cpp:    icell_2d = i + j * (WGD->nx - 1);
CanopyIsolatedTree.cpp:    icell_face = i + j * (WGD->nx) + k * (WGD->nx) * (WGD->ny);
CanopyIsolatedTree.cpp:    float utmp = WGD->u0[icell_face];
CanopyIsolatedTree.cpp:    float vtmp = WGD->v0[icell_face];
CanopyIsolatedTree.cpp:    z_c = WGD->z[k] - base_height;
CanopyIsolatedTree.cpp:    ustar_us = mag_us * WGD->vk / (log((z_c + WGD->canopy->canopy_d[icell_2d]) / WGD->canopy->canopy_z0[icell_2d]));
CanopyIsolatedTree.cpp:  for (auto k = k_top; k >= k_bottom; k--) {
CanopyIsolatedTree.cpp:    // absolute z-coord within building above ground
CanopyIsolatedTree.cpp:    z_b = WGD->z[k] - base_height;
CanopyIsolatedTree.cpp:    // z-coord relative to center of tree (zMaxLAI)
CanopyIsolatedTree.cpp:    z_c = z_b - zMaxLAI;
CanopyIsolatedTree.cpp:    for (auto y_idx = 1; y_idx < 2 * ceil((yw1 - yw3) / WGD->dxy); ++y_idx) {
CanopyIsolatedTree.cpp:      // y-coord relative to center of tree (zMaxLAI)
CanopyIsolatedTree.cpp:      y_c = 0.5 * float(y_idx) * WGD->dxy + yw3;
CanopyIsolatedTree.cpp:        // y_cp=y_c-Lt(ibuild)
CanopyIsolatedTree.cpp:        // xwall=sqrt((Lt(ibuild)**2.)-(y_cp**2.))
CanopyIsolatedTree.cpp:        // x_wall=sqrt(pow(Lt,2)-pow(y_c,2));
CanopyIsolatedTree.cpp:      int x_idx_min = -1;
CanopyIsolatedTree.cpp:      for (auto x_idx = 0; x_idx <= 2.0 * ceil(wake_stream_coef * Lr / WGD->dxy); ++x_idx) {
CanopyIsolatedTree.cpp:        // x-coord relative to center of tree (zMaxLAI)
CanopyIsolatedTree.cpp:        x_c = 0.5 * float(x_idx) * WGD->dxy;
CanopyIsolatedTree.cpp:        int i = ceil(((x_c + x_wall) * cos(upwind_dir) - y_c * sin(upwind_dir) + building_cent_x) / WGD->dx) - 1;
CanopyIsolatedTree.cpp:        int j = ceil(((x_c + x_wall) * sin(upwind_dir) + y_c * cos(upwind_dir) + building_cent_y) / WGD->dy) - 1;
CanopyIsolatedTree.cpp:        //int i = ((x_c + x_wall) * cos(upwind_dir) - y_c * sin(upwind_dir) + building_cent_x) / WGD->dx;
CanopyIsolatedTree.cpp:        //int j = ((x_c + x_wall) * sin(upwind_dir) + y_c * cos(upwind_dir) + building_cent_y) / WGD->dy;
CanopyIsolatedTree.cpp:        if (i >= WGD->nx - 2 || i <= 0 || j >= WGD->ny - 2 || j <= 0)
CanopyIsolatedTree.cpp:        icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyIsolatedTree.cpp:        /* old version - > canopy now
CanopyIsolatedTree.cpp:	  if (WGD->icellflag[icell_cent] != 0
CanopyIsolatedTree.cpp:            && WGD->icellflag[icell_cent] != 2
CanopyIsolatedTree.cpp:            && WGD->icellflag[icell_cent] != getCellFlagCanopy()
CanopyIsolatedTree.cpp:        if (WGD->icellflag[icell_cent] == 0
CanopyIsolatedTree.cpp:            || WGD->icellflag[icell_cent] == 2
CanopyIsolatedTree.cpp:            || WGD->icellflag[icell_cent] == getCellFlagCanopy()) {
CanopyIsolatedTree.cpp:            if (WGD->canopy->icanopy_flag[icell_cent] == tree_id) {
CanopyIsolatedTree.cpp:              x_idx_min = -1;
CanopyIsolatedTree.cpp:            } else if (WGD->icellflag[i + j * (WGD->nx - 1) + kk * (WGD->nx - 1) * (WGD->ny - 1)] == 0
CanopyIsolatedTree.cpp:                       || WGD->icellflag[i + j * (WGD->nx - 1) + kk * (WGD->nx - 1) * (WGD->ny - 1)] == 2) {
CanopyIsolatedTree.cpp:            } else if (WGD->icellflag[icell_cent] == 0
CanopyIsolatedTree.cpp:                       || WGD->icellflag[icell_cent] == 2
CanopyIsolatedTree.cpp:                       || WGD->icellflag[icell_cent] == getCellFlagCanopy()) {
CanopyIsolatedTree.cpp:            // check the tree is right by a building/terrain -> skip downstream
CanopyIsolatedTree.cpp:            if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2)
CanopyIsolatedTree.cpp:        if (WGD->icellflag[icell_cent] != 0
CanopyIsolatedTree.cpp:            && WGD->icellflag[icell_cent] != 2
CanopyIsolatedTree.cpp:        if (WGD->icellflag[icell_cent] == 0
CanopyIsolatedTree.cpp:            || WGD->icellflag[icell_cent] == 2
CanopyIsolatedTree.cpp:            || WGD->icellflag[icell_cent] == getCellFlagCanopy()) {
CanopyIsolatedTree.cpp:            if (WGD->canopy->icanopy_flag[icell_cent] == tree_id) {
CanopyIsolatedTree.cpp:              x_idx_min = -1;
CanopyIsolatedTree.cpp:            } else if (WGD->icellflag[i + j * (WGD->nx - 1) + kk * (WGD->nx - 1) * (WGD->ny - 1)] == 0
CanopyIsolatedTree.cpp:                       || WGD->icellflag[i + j * (WGD->nx - 1) + kk * (WGD->nx - 1) * (WGD->ny - 1)] == 2) {
CanopyIsolatedTree.cpp:            } else if (WGD->icellflag[icell_cent] == 0
CanopyIsolatedTree.cpp:                       || WGD->icellflag[icell_cent] == 2) {
CanopyIsolatedTree.cpp:            // check the tree is right by a building/terrain -> skip downstream
CanopyIsolatedTree.cpp:            if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2)
CanopyIsolatedTree.cpp:        if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2 && WGD->icellflag[icell_cent] != getCellFlagCanopy()) {
CanopyIsolatedTree.cpp:          // wake u-values
CanopyIsolatedTree.cpp:          // ij coord of u-face
CanopyIsolatedTree.cpp:          int i_u = std::round(((x_c + x_wall) * cos(upwind_dir) - y_c * sin(upwind_dir) + building_cent_x) / WGD->dx);
CanopyIsolatedTree.cpp:          int j_u = ((x_c + x_wall) * sin(upwind_dir) + y_c * cos(upwind_dir) + building_cent_y) / WGD->dy;
CanopyIsolatedTree.cpp:          if (i_u < WGD->nx - 1 && i_u > 0 && j_u < WGD->ny - 1 && j_u > 0) {
CanopyIsolatedTree.cpp:            // not rotated relative coordinate of u-face
CanopyIsolatedTree.cpp:            x_p = i_u * WGD->dx - building_cent_x;
CanopyIsolatedTree.cpp:            y_p = (j_u + 0.5) * WGD->dy - building_cent_y;
CanopyIsolatedTree.cpp:            // rotated relative coordinate of u-face
CanopyIsolatedTree.cpp:            y_u = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
CanopyIsolatedTree.cpp:            x_u -= x_wall_u;
CanopyIsolatedTree.cpp:            icell_cent = i_u + j_u * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyIsolatedTree.cpp:            icell_face = i_u + j_u * WGD->nx + k * WGD->nx * WGD->ny;
CanopyIsolatedTree.cpp:            if (dn_u > 0.0 && u_vegwake_flag == 1 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
CanopyIsolatedTree.cpp:              // FM - ellipse equation:
CanopyIsolatedTree.cpp:              delta = (B_h - 1.15) / sqrt(1 - (1 - pow((B_h - 1.15) / (B_h + 1.15), 2)) * pow(cos(theta), 2)) * H;
CanopyIsolatedTree.cpp:                u_defect = u_c * (exp(-(r_center * r_center) / (lambda_sq * delta * delta)));
CanopyIsolatedTree.cpp:                if (u_defect > WGD->canopy->wake_u_defect[icell_face])
CanopyIsolatedTree.cpp:                  WGD->canopy->wake_u_defect[icell_face] = u_defect;
CanopyIsolatedTree.cpp:                //if (std::abs(WGD->u0[icell_face]) >= std::abs(0.2 * cos(upwind_dir) * mag_us)) {
CanopyIsolatedTree.cpp:                //  u0_modified.push_back(WGD->u0[icell_face] * (1. - std::abs(u_defect)));
CanopyIsolatedTree.cpp:          // wake v-values
CanopyIsolatedTree.cpp:          // ij coord of v-face
CanopyIsolatedTree.cpp:          int i_v = ((x_c + x_wall) * cos(upwind_dir) - y_c * sin(upwind_dir) + building_cent_x) / WGD->dx;
CanopyIsolatedTree.cpp:          int j_v = std::round(((x_c + x_wall) * sin(upwind_dir) + y_c * cos(upwind_dir) + building_cent_y) / WGD->dy);
CanopyIsolatedTree.cpp:          if (i_v < WGD->nx - 1 && i_v > 0 && j_v < WGD->ny - 1 && j_v > 0) {
CanopyIsolatedTree.cpp:            // not rotated relative coordinate of v-face
CanopyIsolatedTree.cpp:            x_p = (i_v + 0.5) * WGD->dx - building_cent_x;
CanopyIsolatedTree.cpp:            y_p = j_v * WGD->dy - building_cent_y;
CanopyIsolatedTree.cpp:            // rotated relative coordinate of u-face
CanopyIsolatedTree.cpp:            y_v = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
CanopyIsolatedTree.cpp:            x_v -= x_wall_v;
CanopyIsolatedTree.cpp:            icell_cent = i_v + j_v * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyIsolatedTree.cpp:            icell_face = i_v + j_v * WGD->nx + k * WGD->nx * WGD->ny;
CanopyIsolatedTree.cpp:            if (dn_v > 0.0 && v_vegwake_flag == 1 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
CanopyIsolatedTree.cpp:              // FM - ellipse equation:
CanopyIsolatedTree.cpp:              delta = (B_h - 1.15) / sqrt(1 - (1 - pow((B_h - 1.15) / (B_h + 1.15), 2)) * pow(cos(theta), 2)) * H;
CanopyIsolatedTree.cpp:                u_defect = u_c * (exp(-(r_center * r_center) / (lambda_sq * delta * delta)));
CanopyIsolatedTree.cpp:                if (u_defect > WGD->canopy->wake_v_defect[icell_face])
CanopyIsolatedTree.cpp:                  WGD->canopy->wake_v_defect[icell_face] = u_defect;
CanopyIsolatedTree.cpp:                //if (std::abs(WGD->v0[icell_face]) >= std::abs(0.2 * sin(upwind_dir) * mag_us)) {
CanopyIsolatedTree.cpp:                //  v0_modified.push_back(WGD->v0[icell_face] * (1. - std::abs(u_defect)));
CanopyIsolatedTree.cpp:          // wake celltype w-values
CanopyIsolatedTree.cpp:          // ij coord of cell-center
CanopyIsolatedTree.cpp:          int i_w = ceil(((x_c + x_wall) * cos(upwind_dir) - y_c * sin(upwind_dir) + building_cent_x) / WGD->dx) - 1;
CanopyIsolatedTree.cpp:          int j_w = ceil(((x_c + x_wall) * sin(upwind_dir) + y_c * cos(upwind_dir) + building_cent_y) / WGD->dy) - 1;
CanopyIsolatedTree.cpp:          if (i_w < WGD->nx - 1 && i_w > 0 && j_w < WGD->ny - 1 && j_w > 0) {
CanopyIsolatedTree.cpp:            // not rotated relative coordinate of cell-center
CanopyIsolatedTree.cpp:            x_p = (i_w + 0.5) * WGD->dx - building_cent_x;
CanopyIsolatedTree.cpp:            y_p = (j_w + 0.5) * WGD->dy - building_cent_y;
CanopyIsolatedTree.cpp:            // rotated relative coordinate of cell-center
CanopyIsolatedTree.cpp:            y_w = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
CanopyIsolatedTree.cpp:            x_w -= x_wall_w;
CanopyIsolatedTree.cpp:            icell_cent = i_w + j_w * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyIsolatedTree.cpp:            // icell_face = i_v + j_v*WGD->nx+k*WGD->nx*WGD->ny;
CanopyIsolatedTree.cpp:            if (dn_w > 0.0 && w_vegwake_flag == 1 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
CanopyIsolatedTree.cpp:              // FM - ellipse equation:
CanopyIsolatedTree.cpp:              delta = (B_h - 1.15) / sqrt(1 - (1 - pow((B_h - 1.15) / (B_h + 1.15), 2)) * pow(cos(theta), 2)) * H;
CanopyIsolatedTree.cpp:                u_defect = u_c * (exp(-(r_center * r_center) / (lambda_sq * delta * delta)));
CanopyIsolatedTree.cpp:                WGD->icellflag[icell_cent] = getCellFlagWake();
CanopyIsolatedTree.cpp:          // if u,v, and w are done -> exit x-loop
CanopyIsolatedTree.cpp:      }// end of x-loop (stream-wise)
CanopyIsolatedTree.cpp:    }// end of y-loop (span-wise)
CanopyIsolatedTree.cpp:  }// end of z-loop
CanopyIsolatedTree.cpp:    WGD->u0[u0_mod_id[x_id]] = u0_modified[x_id];
CanopyIsolatedTree.cpp:    WGD->v0[v0_mod_id[y_id]] = v0_modified[y_id];
CanopyIsolatedTree.h: * This file is part of QES-Winds
CanopyIsolatedTree.h: * GPL-3.0 License
CanopyIsolatedTree.h: * QES-Winds is free software: you can redistribute it and/or modify
CanopyIsolatedTree.h: * QES-Winds is distributed in the hope that it will be useful,
CanopyIsolatedTree.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
CanopyIsolatedTree.h:    x_start = x_cent - 0.5 * W;
CanopyIsolatedTree.h:    y_start = y_cent - 0.5 * W;
CanopyIsolatedTree.h:    // x_start += UID->simParams->halo_x;
CanopyIsolatedTree.h:    // y_start += UID->simParams->halo_y;
CanopyIsolatedTree.h:    // uc=ustar_hanieh*(-0.0935*(xpc/eff_height)*(xpc/eff_height)+10)
CanopyIsolatedTree.h:    return us * ((-0.63 * (xh)) + 9.33);
CanopyIsolatedTree.h:    return us * 90.68 * pow(xh, -1.48);
CanopyVineyardBackup.cpp:  float d = abs((Lx[1] - Lx[0]) * (Ly[0] - P[1]) - (Lx[0] - P[0]) * (Ly[1] - Ly[0])) / sqrt(pow(Lx[1] - Lx[0], 2) + pow(Ly[1] - Ly[0], 2));
CanopyVineyardBackup.cpp:  float alph = 1 + pow((Ly[1] - Ly[0]) / (Lx[1] - Lx[0]), 2);
CanopyVineyardBackup.cpp:  row_ortho[0] = sqrt(pow(d, 2) - pow(row_ortho[1], 2));
CanopyVineyardBackup.cpp:  orth_test[0] = P[0] - row_ortho[0];
CanopyVineyardBackup.cpp:    o_signed[0] = -row_ortho[0];
CanopyVineyardBackup.cpp:  orth_test[1] = P[1] - row_ortho[1];
CanopyVineyardBackup.cpp:    o_signed[1] = -row_ortho[1];
CanopyVineyardBackup.cpp:  orth_test[0] = P[0] - row_ortho[0];
CanopyVineyardBackup.cpp:  orth_test[1] = P[1] - row_ortho[1];
CanopyVineyardBackup.cpp:    o_signed[0] = -row_ortho[0];
CanopyVineyardBackup.cpp:    o_signed[1] = -row_ortho[1];
CanopyVineyardBackup.cpp:  if (ceil(1.5 * k_end) > WGD->nz - 1) {
CanopyVineyardBackup.cpp:  int num_sites = WID->metParams->sensors.size();
CanopyVineyardBackup.cpp:    curr_dist = sqrt(pow((building_cent_x - WID->metParams->sensors[i]->site_xcoord), 2) + pow((building_cent_y - WID->metParams->sensors[i]->site_ycoord), 2));
CanopyVineyardBackup.cpp:  rL = WID->metParams->sensors[nearest_sensor_i]->TS[0]->site_one_overL;// uses first time step value only - figure out how to get current time step inside this function
CanopyVineyardBackup.cpp:  z0_site = WID->metParams->sensors[nearest_sensor_i]->TS[0]->site_z0;
CanopyVineyardBackup.cpp:  // Resize the canopy-related vectors
CanopyVineyardBackup.cpp:  int icell_face = i_building_cent + j_building_cent * WGD->nx + (WGD->nz - 5) * WGD->nx * WGD->ny;
CanopyVineyardBackup.cpp:  float u0_uw = WGD->u0[icell_face];// u velocity at the centroid, 5 nodes from the top of domain (avoids effect of nearby wakes)
CanopyVineyardBackup.cpp:  float v0_uw = WGD->v0[icell_face];// v velocity at the centroid, 5 nodes from the top of domain
CanopyVineyardBackup.cpp:  float rowAngle_u = -(rowAngle - 90);
CanopyVineyardBackup.cpp:  float wwdV = -1000000;// a low number
CanopyVineyardBackup.cpp:  for (int id = 0; id < polygonVertices.size() - 1; id++) {
CanopyVineyardBackup.cpp:    beta = 180 - beta;
CanopyVineyardBackup.cpp:  float d_dw = (rowSpacing - rowWidth) / sin(beta * M_PI / 180);
CanopyVineyardBackup.cpp:  //    - Need U_h from upwind of the vineyard block (should actually be component of velocity orthogonal to row, not U)
CanopyVineyardBackup.cpp:  while (WGD->z_face[k_top] < (H + WGD->terrain[i_building_cent + j_building_cent * (WGD->nx - 1)])) {
CanopyVineyardBackup.cpp:  icell_face = i_building_cent + j_building_cent * WGD->nx + k_top * WGD->nx * WGD->ny;
CanopyVineyardBackup.cpp:  float u0_h = WGD->u0[icell_face];
CanopyVineyardBackup.cpp:  float v0_h = WGD->v0[icell_face];
CanopyVineyardBackup.cpp:  float rd_o[2] = { rd[1], -rd[0] };// row-orthogonal unit vector
CanopyVineyardBackup.cpp:  float M0_h = abs(u0_h * rd_o[0] + v0_h * rd_o[1]);// the component of the wind vector in the row-orthogonal direction
CanopyVineyardBackup.cpp:  while (WGD->z_face[k_bot] < (understory_height + WGD->terrain[i_building_cent + j_building_cent * (WGD->nx - 1)])) {
CanopyVineyardBackup.cpp:  icell_face = i_building_cent + j_building_cent * WGD->nx + k_bot * WGD->nx * WGD->ny;
CanopyVineyardBackup.cpp:  float u0_uh = WGD->u0[icell_face];
CanopyVineyardBackup.cpp:  float v0_uh = WGD->v0[icell_face];
CanopyVineyardBackup.cpp:  float L_c = rowWidth * (1 / (1 - a_obf));// from eq. 3.1, Belcher 2003, approximating du/dx using a finite difference about the upwind-est vine, then dividing through by u
CanopyVineyardBackup.cpp:  float udelt = (1 - a_obf);
CanopyVineyardBackup.cpp:  // WGD->terrain[i+j*(WGD->nx-1)] appears to be height (in meters) of the terrain (may be cell-centered because it's always called with nx-1 rather than nx)
CanopyVineyardBackup.cpp:  // WGD->terrain_id[i+j*(WGD->nx)] appears to be height (in nodes) of the terrain (may be face-centered because it's always called with nx)
CanopyVineyardBackup.cpp:  // max_terrain_id is calculated in Sensor.cpp. Index (using nx-1) of highest terrain node
CanopyVineyardBackup.cpp:  float dv_c;// distance of current node to upwind-est vertex
CanopyVineyardBackup.cpp:  float fac;// multiplicative factor used to match lower and upper tanh profiles at mid-canopy height (multiplies the lower profile)
CanopyVineyardBackup.cpp:  int k_mid;// mid-canopy k-node
CanopyVineyardBackup.cpp:  float u_c0, v_c0;// u0 and v0 rotated into row-aligned coordinates
CanopyVineyardBackup.cpp:  float u_c, v_c;// altered (parameterized) u and v, in row-aligned coordinates
CanopyVineyardBackup.cpp:      // calculate row-orthogonal distance to upwind-est row, dv_c
CanopyVineyardBackup.cpp:      float cxy[2] = { (i - 1 + i_start) * WGD->dx, (j - 1 + j_start) * WGD->dy };// current x position
CanopyVineyardBackup.cpp:      float Rx_o[2] = { polygonVertices[idS].x_poly, polygonVertices[idS].x_poly + rd[0] };// x-components of upwind-est row vector
CanopyVineyardBackup.cpp:      float Ry_o[2] = { polygonVertices[idS].y_poly, polygonVertices[idS].y_poly + rd[1] };// y-components "   "   "
CanopyVineyardBackup.cpp:      // calculate "local row-orthogonal distance" from upwind-est row
CanopyVineyardBackup.cpp:      ld = dv_c - N * rowSpacing;
CanopyVineyardBackup.cpp:      float d_dw_local = (ld - rowWidth) / sin(beta * M_PI / 180);
CanopyVineyardBackup.cpp:      // find k-node of mid-canopy at current i,j location
CanopyVineyardBackup.cpp:        if (WGD->z[k] > (z_b + understory_height + (H - understory_height) / 2)) {
CanopyVineyardBackup.cpp:      fac = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (WGD->z[k_mid] - (szo_top + z_b)) / szt_top) + 0.5 * (1 + a_obf)) + (1 - a_exp)) / (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot + z_b - WGD->z[k_mid]) / szt_bot) + 0.5 * (1 + a_obf)) + (1 - a_exp));// upper/lower
CanopyVineyardBackup.cpp:      x_ud = rowSpacing - ld;// right now I'm using the row-orthogonal distance, not streamwise distance. Perhaps should use streamwise distance so that UD zone responds appropriately to wind angle.
CanopyVineyardBackup.cpp:      z_ud = H_ud * sqrt(abs(1 - x_ud / l_ud));
CanopyVineyardBackup.cpp:      br = log(1 - 0.99) / (z_ud * (1 - 0.2));// reaches 0.99 at 0.2*z_ud below z_ud
CanopyVineyardBackup.cpp:      for (auto k = canopy_bot_index[icell_2d]; k < WGD->nz; k++) {
CanopyVineyardBackup.cpp:        //std::cout << " z[k] = " << WGD->z[k] << " zref + z_b = " << zref + z_b << "\n";
CanopyVineyardBackup.cpp:        if (WGD->z[k] > (zref + z_b)) {
CanopyVineyardBackup.cpp:        icell_face_ref = (i - 1 + i_start) + (j - 1 + j_start) * WGD->nx + zref_k * WGD->nx * WGD->ny;
CanopyVineyardBackup.cpp:        vref_c = sinA * WGD->u0[icell_face_ref] + cosA * WGD->v0[icell_face_ref];// The sign of vref_c (the rotated reference velocity) is preserved (rather than abs() ) so that rotation of the final parameterized v0_c is correct. It determines the sign of ustar_v_c which determines sign of vH_c which determines sign of v_c
CanopyVineyardBackup.cpp:        ustar_v_c = WGD->vk * vref_c / log((zref - d_v) / z0_site);// d_v (displacement height from Nate's data)
CanopyVineyardBackup.cpp:        vH_c = ustar_v_c / WGD->vk * (log((H - d_v) / z0_site)) - psiH;
CanopyVineyardBackup.cpp:        a_v = (H / abs(vH_c + 0.00001)) * (abs(ustar_v_c) / (WGD->vk * (H - d_v)) - dpsiH);// abs() here because the attenuation coefficient should be always positive. add 0.00001 to avoid divide by zero
CanopyVineyardBackup.cpp:        for (auto k = canopy_bot_index[icell_2d]; k < WGD->nz; k++) {
CanopyVineyardBackup.cpp:          z_rel = WGD->z_face[k - 1] - z_b;
CanopyVineyardBackup.cpp:          int icell_face = (i - 1 + i_start) + (j - 1 + j_start) * WGD->nx + k * WGD->nx * WGD->ny;
CanopyVineyardBackup.cpp:          int icell_cent = (i - 1 + i_start) + (j - 1 + j_start) * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyVineyardBackup.cpp:          // Rotate u0 and v0 into row-aligned coords
CanopyVineyardBackup.cpp:          u_c0 = cosA * WGD->u0[icell_face] - sinA * WGD->v0[icell_face];
CanopyVineyardBackup.cpp:          v_c0 = sinA * WGD->u0[icell_face] + cosA * WGD->v0[icell_face];
CanopyVineyardBackup.cpp:            u_c0 = u_c0 + (a_obf * u_c0 - 2 * u_c0) * (1 - exp(br * (H_ud - z_rel)));
CanopyVineyardBackup.cpp:          if (k <= k_mid) {// if i'm below mid-canopy, use bottom shear layer quantities
CanopyVineyardBackup.cpp:            a_uw = fac * (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_rel) / szt_uw) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyardBackup.cpp:            a_local = fac * (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_rel) / szt_local) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyardBackup.cpp:            a_uw = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_rel - szo_top) / szt_uw) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyardBackup.cpp:            a_local = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_rel - szo_top) / szt_local) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyardBackup.cpp:          if (BF_flag == 1 && ld < rowWidth) {// if my x-y position indicates i'm on a vine
CanopyVineyardBackup.cpp:                WGD->icellflag[icell_cent] = 28;
CanopyVineyardBackup.cpp:                u0_modified.push_back(pow(a_uw, N - 1) * a_obf * (cosA * WGD->u0[icell_face] - sinA * WGD->v0[icell_face]) * cosA + (sinA * WGD->u0[icell_face] + cosA * WGD->v0[icell_face]) * sinA);
CanopyVineyardBackup.cpp:                v0_modified.push_back(pow(a_uw, N - 1) * a_obf * (cosA * WGD->u0[icell_face] - sinA * WGD->v0[icell_face]) * (-sinA) + (sinA * WGD->u0[icell_face] + cosA * WGD->v0[icell_face]) * cosA);
CanopyVineyardBackup.cpp:                WGD->icellflag[icell_cent] = 29;
CanopyVineyardBackup.cpp:                u0_modified.push_back(pow(a_uw, N_e) * a_obf * (cosA * WGD->u0[icell_face] - sinA * WGD->v0[icell_face]) * cosA + (sinA * WGD->u0[icell_face] + cosA * WGD->v0[icell_face]) * sinA);
CanopyVineyardBackup.cpp:                v0_modified.push_back(pow(a_uw, N_e) * a_obf * (cosA * WGD->u0[icell_face] - sinA * WGD->v0[icell_face]) * (-sinA) + (sinA * WGD->u0[icell_face] + cosA * WGD->v0[icell_face]) * cosA);
CanopyVineyardBackup.cpp:          }// end bleed flow x-y if
CanopyVineyardBackup.cpp:            WGD->icellflag[icell_cent] = 30;
CanopyVineyardBackup.cpp:            if (UD_zone_flag && ((rowSpacing - ld) < l_ud) && (z_rel <= z_ud)) {// if i'm ALSO in the UD zone
CanopyVineyardBackup.cpp:              //  If the rotated u-velocity was negative in the UD zone, this reverses it and then SUBTRACTS bleed flow. If the rotated u-velocity was positive in the UD zone, this reverses it and then ADDS bleed flow
CanopyVineyardBackup.cpp:              WGD->icellflag[icell_cent] = 31;
CanopyVineyardBackup.cpp:                  std::cout << "k = " << k << "     u_c = " << u_c << "       gz = " << (a_obf * pow(a_uw, N) * u_c0 - 2 * u_c) * (1 - exp(br * (z_ud - z_rel))) << "     br = " << br << "     x_ud = " << x_ud << "     1st chunk = " << a_obf * pow(a_uw, N) * u_c0 << "\n";
CanopyVineyardBackup.cpp:                u_c = u_c + (a_obf * pow(a_uw, N) * u_c0 - 2 * u_c) * (1 - exp(br * (z_ud - z_rel)));
CanopyVineyardBackup.cpp:                //u_c = -u_c;
CanopyVineyardBackup.cpp:                  std::cout << "k = " << k << "     u_c = " << u_c << "     gz = " << (a_obf * pow(a_uw, N_e) * u_c0 - 2 * u_c) * (1 - exp(br * (z_ud - z_rel))) << "     br = " << br << "     x_ud = " << x_ud << "     z_ud = " << z_ud << "      1st chunk = " << a_obf * pow(a_uw, N_e) * u_c0 << "\n";
CanopyVineyardBackup.cpp:                u_c = u_c + (a_obf * pow(a_uw, N_e) * u_c0 - 2 * u_c) * (1 - exp(br * (z_ud - z_rel)));
CanopyVineyardBackup.cpp:                //u_c = -u_c;
CanopyVineyardBackup.cpp:              psi = -5.0 * z_rel * rL;
CanopyVineyardBackup.cpp:              psiH = -5.0 * H * rL;
CanopyVineyardBackup.cpp:              dpsiH = -5.0 * rL;
CanopyVineyardBackup.cpp:              ex = pow((1. - 15. * z_rel * rL), 0.25);
CanopyVineyardBackup.cpp:              psi = log((0.5 * (1. + pow(ex, 2))) * pow(0.5 * (1. + ex), 2)) - 2. * atan(ex) + M_PI * 0.5;
CanopyVineyardBackup.cpp:              exH = pow(1. - 15. * H * rL, .25);
CanopyVineyardBackup.cpp:              psiH = log((0.5 * (1. + pow(exH, 2))) * pow(0.5 * (1. + exH), 2)) - 2. * atan(exH) + M_PI * 0.5;
CanopyVineyardBackup.cpp:              dexH = -15. / 4. * rL * pow(1. - 15. * H * rL, -0.75);
CanopyVineyardBackup.cpp:              dpsiH = (exH * dexH * (1. + exH) * 0.5 + 0.5 * (1. + pow(exH, 2)) * dexH) / (0.25 * (1. + pow(exH, 2)) * (1. + exH)) - (dexH / (1. + pow(exH, 2)));
CanopyVineyardBackup.cpp:              v_c = vH_c * exp(a_v * (z_rel / H - 1));
CanopyVineyardBackup.cpp:              v_c = ustar_v_c / WGD->vk * (log((z_rel - d_v) / z0_site)) - psi;
CanopyVineyardBackup.cpp:          // Rotate back into QES-grid coordinates
CanopyVineyardBackup.cpp:          v0_modified.push_back(-sinA * u_c + cosA * v_c);
CanopyVineyardBackup.cpp:        }// end k-loop
CanopyVineyardBackup.cpp:                    v0_mod_id.push_back(icell_face+WGD->nx);
CanopyVineyardBackup.cpp:    }// end i-loop
CanopyVineyardBackup.cpp:  }// end j-loop
CanopyVineyardBackup.cpp:    WGD->u0[u0_mod_id[x_id]] = u0_modified[x_id];
CanopyVineyardBackup.cpp:    WGD->v0[v0_mod_id[y_id]] = v0_modified[y_id];
CanopyVineyardCleaned.cpp:  float d = abs((Lx[1] - Lx[0]) * (Ly[0] - P[1]) - (Lx[0] - P[0]) * (Ly[1] - Ly[0])) / sqrt(pow(Lx[1] - Lx[0], 2) + pow(Ly[1] - Ly[0], 2));
CanopyVineyardCleaned.cpp:  float alph = 1 + pow((Ly[1] - Ly[0]) / (Lx[1] - Lx[0]), 2);
CanopyVineyardCleaned.cpp:  row_ortho[0] = sqrt(pow(d, 2) - pow(row_ortho[1], 2));
CanopyVineyardCleaned.cpp:  orth_test[0] = P[0] - row_ortho[0];
CanopyVineyardCleaned.cpp:    o_signed[0] = -row_ortho[0];
CanopyVineyardCleaned.cpp:  orth_test[1] = P[1] - row_ortho[1];
CanopyVineyardCleaned.cpp:    o_signed[1] = -row_ortho[1];
CanopyVineyardCleaned.cpp:  orth_test[0] = P[0] - row_ortho[0];
CanopyVineyardCleaned.cpp:  orth_test[1] = P[1] - row_ortho[1];
CanopyVineyardCleaned.cpp:    o_signed[0] = -row_ortho[0];
CanopyVineyardCleaned.cpp:    o_signed[1] = -row_ortho[1];
CanopyVineyardCleaned.cpp:  if (ceil(1.5 * k_end) > WGD->nz - 1) {
CanopyVineyardCleaned.cpp:  int num_sites = WID->metParams->sensors.size();
CanopyVineyardCleaned.cpp:    curr_dist = sqrt(pow((building_cent_x - WID->metParams->sensors[i]->site_xcoord), 2) + pow((building_cent_y - WID->metParams->sensors[i]->site_ycoord), 2));
CanopyVineyardCleaned.cpp:  rL = WID->metParams->sensors[nearest_sensor_i]->TS[0]->site_one_overL;// uses first time step value only - figure out how to get current time step inside this function
CanopyVineyardCleaned.cpp:  z0_site = WID->metParams->sensors[nearest_sensor_i]->TS[0]->site_z0;
CanopyVineyardCleaned.cpp:  // Resize the canopy-related vectors
CanopyVineyardCleaned.cpp:  int icell_face = i_building_cent + j_building_cent * WGD->nx + (WGD->nz - 5) * WGD->nx * WGD->ny;
CanopyVineyardCleaned.cpp:  float u0_uw = WGD->u0[icell_face];// u velocity at the centroid, 5 nodes from the top of domain (avoids effect of nearby wakes)
CanopyVineyardCleaned.cpp:  float v0_uw = WGD->v0[icell_face];// v velocity at the centroid, 5 nodes from the top of domain
CanopyVineyardCleaned.cpp:  float rowAngle_u = -(rowAngle - 90);
CanopyVineyardCleaned.cpp:  float wwdV = -1000000;// a low number
CanopyVineyardCleaned.cpp:  for (int id = 0; id < polygonVertices.size() - 1; id++) {
CanopyVineyardCleaned.cpp:    beta = 180 - beta;
CanopyVineyardCleaned.cpp:  float d_dw = (rowSpacing - rowWidth) / sin(beta * M_PI / 180);
CanopyVineyardCleaned.cpp:  //    - Need U_h from upwind of the vineyard block (should actually be component of velocity orthogonal to row, not U)
CanopyVineyardCleaned.cpp:  while (WGD->z_face[k_top] < (H + WGD->terrain[i_building_cent + j_building_cent * (WGD->nx - 1)])) {
CanopyVineyardCleaned.cpp:  icell_face = i_building_cent + j_building_cent * WGD->nx + k_top * WGD->nx * WGD->ny;
CanopyVineyardCleaned.cpp:  float u0_h = WGD->u0[icell_face];
CanopyVineyardCleaned.cpp:  float v0_h = WGD->v0[icell_face];
CanopyVineyardCleaned.cpp:  float rd_o[2] = { rd[1], -rd[0] };// row-orthogonal unit vector
CanopyVineyardCleaned.cpp:  float M0_h = abs(u0_h * rd_o[0] + v0_h * rd_o[1]);// the component of the wind vector in the row-orthogonal direction
CanopyVineyardCleaned.cpp:  while (WGD->z_face[k_bot] < (understory_height + WGD->terrain[i_building_cent + j_building_cent * (WGD->nx - 1)])) {
CanopyVineyardCleaned.cpp:  icell_face = i_building_cent + j_building_cent * WGD->nx + k_bot * WGD->nx * WGD->ny;
CanopyVineyardCleaned.cpp:  float u0_uh = WGD->u0[icell_face];
CanopyVineyardCleaned.cpp:  float v0_uh = WGD->v0[icell_face];
CanopyVineyardCleaned.cpp:  float L_c = rowWidth * (1 / (1 - a_obf));// from eq. 3.1, Belcher 2003, approximating du/dx using a finite difference about the upwind-est vine, then dividing through by u
CanopyVineyardCleaned.cpp:  float udelt = (1 - a_obf);
CanopyVineyardCleaned.cpp:  // Avoid divide-by-zero for the no-understory case (where M0_uh will be 0)
CanopyVineyardCleaned.cpp:  // WGD->terrain[i+j*(WGD->nx-1)] appears to be height (in meters) of the terrain (may be cell-centered because it's always called with nx-1 rather than nx)
CanopyVineyardCleaned.cpp:  // WGD->terrain_id[i+j*(WGD->nx)] appears to be height (in nodes) of the terrain (may be face-centered because it's always called with nx)
CanopyVineyardCleaned.cpp:  // max_terrain_id is calculated in Sensor.cpp. Index (using nx-1) of highest terrain node
CanopyVineyardCleaned.cpp:  float dv_c;// distance of current node to upwind-est vertex
CanopyVineyardCleaned.cpp:  float fac;// multiplicative factor used to match lower and upper tanh profiles at mid-canopy height (multiplies the lower profile)
CanopyVineyardCleaned.cpp:  int k_mid;// mid-canopy k-node
CanopyVineyardCleaned.cpp:  float u_c0, v_c0;// u0 and v0 rotated into row-aligned coordinates
CanopyVineyardCleaned.cpp:  float u_c, v_c;// altered (parameterized) u and v, in row-aligned coordinates
CanopyVineyardCleaned.cpp:      // calculate row-orthogonal distance to upwind-est row, dv_c
CanopyVineyardCleaned.cpp:      float cxy[2] = { (i - 1 + i_start) * WGD->dx, (j - 1 + j_start) * WGD->dy };// current x position
CanopyVineyardCleaned.cpp:      float Rx_o[2] = { polygonVertices[idS].x_poly, polygonVertices[idS].x_poly + rd[0] };// x-components of upwind-est row vector
CanopyVineyardCleaned.cpp:      float Ry_o[2] = { polygonVertices[idS].y_poly, polygonVertices[idS].y_poly + rd[1] };// y-components "   "   "
CanopyVineyardCleaned.cpp:      // calculate "local row-orthogonal distance" from upwind-est row
CanopyVineyardCleaned.cpp:      ld = dv_c - N * rowSpacing;
CanopyVineyardCleaned.cpp:      float d_dw_local = (ld - rowWidth) / sin(beta * M_PI / 180);
CanopyVineyardCleaned.cpp:      // find k-node of mid-canopy at current i,j location
CanopyVineyardCleaned.cpp:        if (WGD->z[k] > (z_b + understory_height + (H - understory_height) / 2)) {
CanopyVineyardCleaned.cpp:      // (this can be moved inside the if-statement under BEGIN PARAMETERIZATIONS so it doesn't run outside of canopy i-j spots)
CanopyVineyardCleaned.cpp:      float z_mid = (H - understory_height) / 2 + understory_height;
CanopyVineyardCleaned.cpp:      a_local_bot = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_mid) / szt_local_bot) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyardCleaned.cpp:        a_uw_bot[n] = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_rel) / szt_uw_bot) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyardCleaned.cpp:      a_local_top = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_mid - szo_top) / szt_local_top) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyardCleaned.cpp:        a_uw_top[n] = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_mid - szo_top) / szt_uw_top) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyardCleaned.cpp:      //fac = (a_exp*(0.5*(1-a_obf)*tanh(1.5*(WGD->z[k_mid] - (szo_top+z_b))/szt_top) + 0.5*(1+a_obf)) + (1-a_exp))/(a_exp*(0.5*(1-a_obf)*tanh(1.5*(szo_bot+z_b - WGD->z[k_mid])/szt_bot) + 0.5*(1+a_obf)) + (1-a_exp)); // upper/lower
CanopyVineyardCleaned.cpp:      x_ud = rowSpacing - ld;// right now I'm using the row-orthogonal distance, not streamwise distance. Perhaps should use streamwise distance so that UD zone responds appropriately to wind angle.
CanopyVineyardCleaned.cpp:      z_ud = H_ud * sqrt(abs(1 - x_ud / l_ud));
CanopyVineyardCleaned.cpp:      br = log(1 - 0.99) / (z_ud * (1 - 0.2));// reaches 0.99 at 0.2*z_ud below z_ud
CanopyVineyardCleaned.cpp:      for (auto k = canopy_bot_index[icell_2d]; k < WGD->nz; k++) {
CanopyVineyardCleaned.cpp:        //std::cout << " z[k] = " << WGD->z[k] << " zref + z_b = " << zref + z_b << "\n";
CanopyVineyardCleaned.cpp:        if (WGD->z[k] > (zref + z_b)) {
CanopyVineyardCleaned.cpp:        icell_face_ref = (i - 1 + i_start) + (j - 1 + j_start) * WGD->nx + zref_k * WGD->nx * WGD->ny;
CanopyVineyardCleaned.cpp:        vref_c = sinA * WGD->u0[icell_face_ref] + cosA * WGD->v0[icell_face_ref];// The sign of vref_c (the rotated reference velocity) is preserved (rather than abs() ) so that rotation of the final parameterized v0_c is correct. It determines the sign of ustar_v_c which determines sign of vH_c which determines sign of v_c
CanopyVineyardCleaned.cpp:        ustar_v_c = WGD->vk * vref_c / log((zref - d_v) / z0_site);// d_v (displacement height from Nate's data)
CanopyVineyardCleaned.cpp:        vH_c = ustar_v_c / WGD->vk * (log((H - d_v) / z0_site)) - psiH;
CanopyVineyardCleaned.cpp:        a_v = (H / abs(vH_c + 0.00001)) * (abs(ustar_v_c) / (WGD->vk * (H - d_v)) - dpsiH);// abs() here because the attenuation coefficient should be always positive. add 0.00001 to avoid divide by zero
CanopyVineyardCleaned.cpp:        for (auto k = canopy_bot_index[icell_2d]; k < WGD->nz; k++) {
CanopyVineyardCleaned.cpp:          z_rel = WGD->z_face[k - 1] - z_b;
CanopyVineyardCleaned.cpp:          int icell_face = (i - 1 + i_start) + (j - 1 + j_start) * WGD->nx + k * WGD->nx * WGD->ny;
CanopyVineyardCleaned.cpp:          int icell_cent = (i - 1 + i_start) + (j - 1 + j_start) * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyVineyardCleaned.cpp:          // Rotate u0 and v0 into row-aligned coords
CanopyVineyardCleaned.cpp:          u_c0 = cosA * WGD->u0[icell_face] - sinA * WGD->v0[icell_face];
CanopyVineyardCleaned.cpp:          v_c0 = sinA * WGD->u0[icell_face] + cosA * WGD->v0[icell_face];
CanopyVineyardCleaned.cpp:            //u_c0 = u_c0 + (a_obf*u_c0 - 2*u_c0)*(1-exp(br*(H_ud-z_rel)));
CanopyVineyardCleaned.cpp:          /*                    if (k <= k_mid){ // if i'm below mid-canopy, use bottom shear layer quantities
CanopyVineyardCleaned.cpp:                        a_uw = fac*(a_exp*(0.5*(1-a_obf)*tanh(1.5*(szo_bot - z_rel)/szt_uw) + 0.5*(1+a_obf)) + (1-a_exp));
CanopyVineyardCleaned.cpp:                        a_local = fac*(a_exp*(0.5*(1-a_obf)*tanh(1.5*(szo_bot - z_rel)/szt_local) + 0.5*(1+a_obf)) + (1-a_exp));
CanopyVineyardCleaned.cpp:                        a_uw = (a_exp*(0.5*(1-a_obf)*tanh(1.5*(z_rel - szo_top)/szt_uw) + 0.5*(1+a_obf)) + (1-a_exp));
CanopyVineyardCleaned.cpp:                        a_local = (a_exp*(0.5*(1-a_obf)*tanh(1.5*(z_rel - szo_top)/szt_local) + 0.5*(1+a_obf)) + (1-a_exp));
CanopyVineyardCleaned.cpp:          if (k <= k_mid) {// if i'm below mid-canopy, use bottom shear layer quantities
CanopyVineyardCleaned.cpp:            a_local = 1 * (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_rel) / szt_local) + 0.5 * (1 + a_obf)) + (1 - a_exp));// there should be a "fac" where the 1* is (fac isn't working right now)
CanopyVineyardCleaned.cpp:              a_uw[n] = 1 * (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_rel) / szt_uw) + 0.5 * (1 + a_obf)) + (1 - a_exp));// there should be a "fac" where the 1* is (fac isn't working right now)
CanopyVineyardCleaned.cpp:            a_local = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_rel - szo_top) / szt_local) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyardCleaned.cpp:              a_uw[n] = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_rel - szo_top) / szt_uw) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyardCleaned.cpp:          if (BF_flag == 1 && ld < rowWidth) {// if my x-y position indicates i'm on a vine
CanopyVineyardCleaned.cpp:                WGD->icellflag[icell_cent] = 28;
CanopyVineyardCleaned.cpp:                WGD->icellflag[icell_cent] = 29;
CanopyVineyardCleaned.cpp:          }// end bleed flow x-y if
CanopyVineyardCleaned.cpp:            WGD->icellflag[icell_cent] = 30;
CanopyVineyardCleaned.cpp:            if (UD_zone_flag && ((rowSpacing - ld) < l_ud) && (z_rel <= z_ud)) {// if i'm ALSO in the UD zone
CanopyVineyardCleaned.cpp:              //  If the rotated u-velocity was negative in the UD zone, this reverses it and then SUBTRACTS bleed flow. If the rotated u-velocity was positive in the UD zone, this reverses it and then ADDS bleed flow
CanopyVineyardCleaned.cpp:              WGD->icellflag[icell_cent] = 31;
CanopyVineyardCleaned.cpp:                u_c = -u_c;
CanopyVineyardCleaned.cpp:                u_c = -u_c;
CanopyVineyardCleaned.cpp:              psi = -5.0 * z_rel * rL;
CanopyVineyardCleaned.cpp:              psiH = -5.0 * H * rL;
CanopyVineyardCleaned.cpp:              dpsiH = -5.0 * rL;
CanopyVineyardCleaned.cpp:              ex = pow((1. - 15. * z_rel * rL), 0.25);
CanopyVineyardCleaned.cpp:              psi = log((0.5 * (1. + pow(ex, 2))) * pow(0.5 * (1. + ex), 2)) - 2. * atan(ex) + M_PI * 0.5;
CanopyVineyardCleaned.cpp:              exH = pow(1. - 15. * H * rL, .25);
CanopyVineyardCleaned.cpp:              psiH = log((0.5 * (1. + pow(exH, 2))) * pow(0.5 * (1. + exH), 2)) - 2. * atan(exH) + M_PI * 0.5;
CanopyVineyardCleaned.cpp:              dexH = -15. / 4. * rL * pow(1. - 15. * H * rL, -0.75);
CanopyVineyardCleaned.cpp:              dpsiH = (exH * dexH * (1. + exH) * 0.5 + 0.5 * (1. + pow(exH, 2)) * dexH) / (0.25 * (1. + pow(exH, 2)) * (1. + exH)) - (dexH / (1. + pow(exH, 2)));
CanopyVineyardCleaned.cpp:              v_c = vH_c * exp(a_v * (z_rel / H - 1));
CanopyVineyardCleaned.cpp:              v_c = ustar_v_c / WGD->vk * (log((z_rel - d_v) / z0_site)) - psi;
CanopyVineyardCleaned.cpp:            //std::cout << "k = " << k <<  "     u_c = " << u_c << "       gz = " <<  (a_obf*pow(a_uw,N)*u_c0 - 2*u_c)*(1-exp(br*(z_ud-z_rel))) << "     br = " << br << "     x_ud = " << x_ud << "     1st chunk = " <<  a_obf*pow(a_uw,N)*u_c0  <<  "\n";
CanopyVineyardCleaned.cpp:          // Rotate back into QES-grid coordinates
CanopyVineyardCleaned.cpp:          v0_modified.push_back(-sinA * u_c + cosA * v_c);
CanopyVineyardCleaned.cpp:        }// end k-loop
CanopyVineyardCleaned.cpp:                    v0_mod_id.push_back(icell_face+WGD->nx);
CanopyVineyardCleaned.cpp:    }// end i-loop
CanopyVineyardCleaned.cpp:  }// end j-loop
CanopyVineyardCleaned.cpp:    WGD->u0[u0_mod_id[x_id]] = u0_modified[x_id];
CanopyVineyardCleaned.cpp:    WGD->v0[v0_mod_id[y_id]] = v0_modified[y_id];
CanopyVineyard.cpp:  float d = abs((Lx[1] - Lx[0]) * (Ly[0] - P[1]) - (Lx[0] - P[0]) * (Ly[1] - Ly[0])) / sqrt(pow(Lx[1] - Lx[0], 2) + pow(Ly[1] - Ly[0], 2));
CanopyVineyard.cpp:  float alph = 1 + pow((Ly[1] - Ly[0]) / (Lx[1] - Lx[0]), 2);
CanopyVineyard.cpp:  row_ortho[0] = sqrt(pow(d, 2) - pow(row_ortho[1], 2));
CanopyVineyard.cpp:  orth_test[0] = P[0] - row_ortho[0];
CanopyVineyard.cpp:    o_signed[0] = -row_ortho[0];
CanopyVineyard.cpp:  orth_test[1] = P[1] - row_ortho[1];
CanopyVineyard.cpp:    o_signed[1] = -row_ortho[1];
CanopyVineyard.cpp:  orth_test[0] = P[0] - row_ortho[0];
CanopyVineyard.cpp:  orth_test[1] = P[1] - row_ortho[1];
CanopyVineyard.cpp:    o_signed[0] = -row_ortho[0];
CanopyVineyard.cpp:    o_signed[1] = -row_ortho[1];
CanopyVineyard.cpp:  if (ceil(1.5 * k_end) > WGD->nz - 1) {
CanopyVineyard.cpp:  int num_sites = WID->metParams->sensors.size();
CanopyVineyard.cpp:    curr_dist = sqrt(pow((building_cent_x - WID->metParams->sensors[i]->site_xcoord), 2) + pow((building_cent_y - WID->metParams->sensors[i]->site_ycoord), 2));
CanopyVineyard.cpp:  rL = WID->metParams->sensors[nearest_sensor_i]->TS[0]->site_one_overL;// uses first time step value only - figure out how to get current time step inside this function
CanopyVineyard.cpp:  z0_site = WID->metParams->sensors[nearest_sensor_i]->TS[0]->site_z0;
CanopyVineyard.cpp:  // Resize the canopy-related vectors
CanopyVineyard.cpp:  int icell_face = i_building_cent + j_building_cent * WGD->nx + (WGD->nz - 5) * WGD->nx * WGD->ny;
CanopyVineyard.cpp:  float u0_uw = WGD->u0[icell_face];// u velocity at the centroid, 5 nodes from the top of domain (avoids effect of nearby wakes)
CanopyVineyard.cpp:  float v0_uw = WGD->v0[icell_face];// v velocity at the centroid, 5 nodes from the top of domain
CanopyVineyard.cpp:  float rowAngle_u = -(rowAngle - 90);
CanopyVineyard.cpp:  float wwdV = -1000000;// a low number
CanopyVineyard.cpp:  for (int id = 0; id < polygonVertices.size() - 1; id++) {
CanopyVineyard.cpp:    beta = 180 - beta;
CanopyVineyard.cpp:  float d_dw = (rowSpacing - rowWidth) / sin(beta * M_PI / 180);
CanopyVineyard.cpp:  //    - Need U_h from upwind of the vineyard block (should actually be component of velocity orthogonal to row, not U)
CanopyVineyard.cpp:  while (WGD->z_face[k_top] < (H + WGD->terrain[i_building_cent + j_building_cent * (WGD->nx - 1)])) {
CanopyVineyard.cpp:  icell_face = i_building_cent + j_building_cent * WGD->nx + k_top * WGD->nx * WGD->ny;
CanopyVineyard.cpp:  float u0_h = WGD->u0[icell_face];
CanopyVineyard.cpp:  float v0_h = WGD->v0[icell_face];
CanopyVineyard.cpp:  float rd_o[2] = { rd[1], -rd[0] };// row-orthogonal unit vector
CanopyVineyard.cpp:  float M0_h = abs(u0_h * rd_o[0] + v0_h * rd_o[1]);// the component of the wind vector in the row-orthogonal direction
CanopyVineyard.cpp:  while (WGD->z_face[k_bot] < (understory_height + WGD->terrain[i_building_cent + j_building_cent * (WGD->nx - 1)])) {
CanopyVineyard.cpp:  icell_face = i_building_cent + j_building_cent * WGD->nx + k_bot * WGD->nx * WGD->ny;
CanopyVineyard.cpp:  float u0_uh = WGD->u0[icell_face];
CanopyVineyard.cpp:  float v0_uh = WGD->v0[icell_face];
CanopyVineyard.cpp:  //float L_c = rowWidth*(1/(1-a_obf)); // from eq. 3.1, Belcher 2003, approximating du/dx using a finite difference about the upwind-est vine, then dividing through by u
CanopyVineyard.cpp:  float L_c = pow(Cd * LAD_eff, -1);
CanopyVineyard.cpp:  //float udelt = (1-a_obf);
CanopyVineyard.cpp:  float udelt = (1 - pow(a_obf, N_e));
CanopyVineyard.cpp:  // Avoid divide-by-zero for the no-understory case (where M0_uh will be 0)
CanopyVineyard.cpp:  // WGD->terrain[i+j*(WGD->nx-1)] appears to be height (in meters) of the terrain (may be cell-centered because it's always called with nx-1 rather than nx)
CanopyVineyard.cpp:  // WGD->terrain_id[i+j*(WGD->nx)] appears to be height (in nodes) of the terrain (may be face-centered because it's always called with nx)
CanopyVineyard.cpp:  // max_terrain_id is calculated in Sensor.cpp. Index (using nx-1) of highest terrain node
CanopyVineyard.cpp:  float dv_c;// distance of current node to upwind-est vertex
CanopyVineyard.cpp:  float fac;// multiplicative factor used to match lower and upper tanh profiles at mid-canopy height (multiplies the lower profile)
CanopyVineyard.cpp:  int k_mid;// mid-canopy k-node
CanopyVineyard.cpp:  float u_c0, v_c0;// u0 and v0 rotated into row-aligned coordinates
CanopyVineyard.cpp:  float u_c, v_c;// altered (parameterized) u and v, in row-aligned coordinates
CanopyVineyard.cpp:      // calculate row-orthogonal distance to upwind-est row, dv_c
CanopyVineyard.cpp:      float cxy[2] = { (i - 1 + i_start) * WGD->dx, (j - 1 + j_start) * WGD->dy };// current x position
CanopyVineyard.cpp:      float Rx_o[2] = { polygonVertices[idS].x_poly, polygonVertices[idS].x_poly + rd[0] };// x-components of upwind-est row vector
CanopyVineyard.cpp:      float Ry_o[2] = { polygonVertices[idS].y_poly, polygonVertices[idS].y_poly + rd[1] };// y-components "   "   "
CanopyVineyard.cpp:      // Row-orthogonal distance between current point and the upwind-est row
CanopyVineyard.cpp:      // calculate "local row-orthogonal distance" from nearest upwind row
CanopyVineyard.cpp:      ld = dv_c - N * rowSpacing;
CanopyVineyard.cpp:      float d_dw_local = (ld - rowWidth) / sin(beta * M_PI / 180);
CanopyVineyard.cpp:      // find k-node of mid-canopy at current i,j location
CanopyVineyard.cpp:        if (WGD->z[k] > (z_b + understory_height + (H - understory_height) / 2)) {
CanopyVineyard.cpp:      szo_top = std::max(-0.43 * ld + H, 0.);
CanopyVineyard.cpp:      float szo_top_uw = std::max(-0.43 * (rowSpacing - rowWidth) + H, 0.);// origin right before the next row, e.g. at a distance of "rowSpacing" orthogonally from nearest upwind row
CanopyVineyard.cpp:      // (this can be moved inside the if-statement under BEGIN PARAMETERIZATIONS so it doesn't run outside of canopy i-j spots)
CanopyVineyard.cpp:      float z_mid = (H - understory_height) / 2 + understory_height;
CanopyVineyard.cpp:      a_local_bot = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_mid) / szt_local_bot) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyard.cpp:        a_uw_bot[n] = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_rel) / szt_uw_bot) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyard.cpp:      a_local_top = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_mid - szo_top) / szt_local_top) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyard.cpp:        a_uw_top[n] = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_mid - szo_top_uw) / szt_uw_top) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyard.cpp:      //fac = (a_exp*(0.5*(1-a_obf)*tanh(1.5*(WGD->z[k_mid] - (szo_top+z_b))/szt_top) + 0.5*(1+a_obf)) + (1-a_exp))/(a_exp*(0.5*(1-a_obf)*tanh(1.5*(szo_bot+z_b - WGD->z[k_mid])/szt_bot) + 0.5*(1+a_obf)) + (1-a_exp)); // upper/lower
CanopyVineyard.cpp:      x_ud = rowSpacing - ld;// right now I'm using the row-orthogonal distance, not streamwise distance. Perhaps should use streamwise distance so that UD zone responds appropriately to wind angle.
CanopyVineyard.cpp:      z_ud = H_ud * sqrt(abs(1 - x_ud / l_ud));
CanopyVineyard.cpp:      br = log(1 - 0.99) / (z_ud * (1 - 0.2));// reaches 0.99 at 0.2*z_ud below z_ud
CanopyVineyard.cpp:      for (auto k = canopy_bot_index[icell_2d]; k < WGD->nz; k++) {
CanopyVineyard.cpp:        //std::cout << " z[k] = " << WGD->z[k] << " zref + z_b = " << zref + z_b << "\n";
CanopyVineyard.cpp:        if (WGD->z[k] > (zref + z_b)) {
CanopyVineyard.cpp:        icell_face_ref = (i - 1 + i_start) + (j - 1 + j_start) * WGD->nx + zref_k * WGD->nx * WGD->ny;
CanopyVineyard.cpp:          psiH = -5.0 * (H - d_v) * rL;
CanopyVineyard.cpp:          dpsiH = -5.0 * rL;
CanopyVineyard.cpp:          psiRef = -5.0 * (zref - d_v) * rL;
CanopyVineyard.cpp:          dpsiRef = -5.0 * rL;
CanopyVineyard.cpp:          exH = pow(1. - 15. * (H - d_v) * rL, .25);
CanopyVineyard.cpp:          psiH = log((0.5 * (1. + pow(exH, 2))) * pow(0.5 * (1. + exH), 2)) - 2. * atan(exH) + M_PI * 0.5;
CanopyVineyard.cpp:          dexH = -15. / 4. * rL * pow(1. - 15. * (H - d_v) * rL, -0.75);
CanopyVineyard.cpp:          //dpsiH = (exH*dexH*(1.+exH)*0.5 + 0.5*(1.+pow(exH,2))*dexH)/(0.25*(1.+pow(exH,2))*(1.+exH)) - (dexH/(1.+pow(exH,2))); // this is old, from the Fortran, possibly contains errors (7/15/21)
CanopyVineyard.cpp:          dpsiH = dexH * (((exH * (0.5 * (1 + exH)) + 0.5 * (1 + pow(exH, 2))) / (0.5 * (1 + pow(exH, 2)) * (0.5 * (1 + exH)))) - 2. / (1. + pow(exH, 2.)));
CanopyVineyard.cpp:          exRef = pow(1. - 15. * (zref - d_v) * rL, .25);
CanopyVineyard.cpp:          psiRef = log((0.5 * (1. + pow(exRef, 2))) * pow(0.5 * (1. + exRef), 2)) - 2. * atan(exRef) + M_PI * 0.5;
CanopyVineyard.cpp:          dexRef = -15. / 4. * rL * pow(1. - 15. * (zref - d_v) * rL, -0.75);
CanopyVineyard.cpp:          dpsiRef = dexRef * (((exRef * (0.5 * (1 + exRef)) + 0.5 * (1 + pow(exRef, 2))) / (0.5 * (1 + pow(exRef, 2)) * (0.5 * (1 + exRef)))) - 2. / (1. + pow(exRef, 2.)));
CanopyVineyard.cpp:        vref_c = sinA * WGD->u0[icell_face_ref] + cosA * WGD->v0[icell_face_ref];// The sign of vref_c (the rotated reference velocity) is preserved (rather than abs() ) so that rotation of the final parameterized v0_c is correct. It determines the sign of ustar_v_c which determines sign of vH_c which determines sign of v_c
CanopyVineyard.cpp:        ustar_v_c = WGD->vk * vref_c / (log((zref - d_v) / z0_site) - psiRef);// d_v (displacement height from Nate's data). This is the ustar_v_c that should cause the v profile to be vref_c at zref. it's zref-d_v and not just zref like in Pardyjak 2008 because the v profile that will eventually be prescribed in the canopy is displaced.
CanopyVineyard.cpp:        vH_c = ustar_v_c / WGD->vk * (log((H - d_v) / z0_site) - psiH);
CanopyVineyard.cpp:        a_v = (H / abs(vH_c + 0.00001)) * (abs(ustar_v_c) / WGD->vk) * (1 / (H - d_v) - dpsiH);// abs() here because the attenuation coefficient should be always positive. add 0.00001 to avoid divide by zero
CanopyVineyard.cpp:        // MAIN Z-LOOP
CanopyVineyard.cpp:        for (auto k = canopy_bot_index[icell_2d]; k < WGD->nz; k++) {
CanopyVineyard.cpp:          z_rel = WGD->z_face[k - 1] - z_b;
CanopyVineyard.cpp:          int icell_face = (i - 1 + i_start) + (j - 1 + j_start) * WGD->nx + k * WGD->nx * WGD->ny;
CanopyVineyard.cpp:          int icell_cent = (i - 1 + i_start) + (j - 1 + j_start) * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyVineyard.cpp:          // Rotate u0 and v0 into row-aligned coords
CanopyVineyard.cpp:          u_c0 = cosA * WGD->u0[icell_face] - sinA * WGD->v0[icell_face];
CanopyVineyard.cpp:          v_c0 = sinA * WGD->u0[icell_face] + cosA * WGD->v0[icell_face];
CanopyVineyard.cpp:            //u_c0 = u_c0 + (a_obf*u_c0 - 2*u_c0)*(1-exp(br*(H_ud-z_rel)));
CanopyVineyard.cpp:            if (k <= k_mid) {// if i'm below mid-canopy, use bottom shear layer quantities
CanopyVineyard.cpp:              a_uw = 1 * (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_rel) / szt_uw) + 0.5 * (1 + a_obf)) + (1 - a_exp));// should be a "fac" where the 1* is, will fix this later
CanopyVineyard.cpp:              a_local = 1 * (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_rel) / szt_local) + 0.5 * (1 + a_obf)) + (1 - a_exp));// should be a "fac" where the 1* is, will fix this later
CanopyVineyard.cpp:              a_uw = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_rel - szo_top_uw) / szt_uw) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyard.cpp:              a_local = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_rel - szo_top) / szt_local) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyard.cpp:            if (k <= k_mid) {// if i'm below mid-canopy, use bottom shear layer quantities
CanopyVineyard.cpp:              a_local = 1 * (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_rel) / szt_local) + 0.5 * (1 + a_obf)) + (1 - a_exp));// there should be a "fac" where the 1* is (fac isn't working right now)
CanopyVineyard.cpp:                a_uwv[n] = 1 * (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (szo_bot - z_rel) / szt_uw) + 0.5 * (1 + a_obf)) + (1 - a_exp));// there should be a "fac" where the 1* is (fac isn't working right now)
CanopyVineyard.cpp:            } else {// if I'm above mid-canopy
CanopyVineyard.cpp:              a_local = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_rel - szo_top) / szt_local) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyard.cpp:                a_uwv[n] = (a_exp * (0.5 * (1 - a_obf) * tanh(1.5 * (z_rel - szo_top_uw) / szt_uw) + 0.5 * (1 + a_obf)) + (1 - a_exp));
CanopyVineyard.cpp:          if (BF_flag == 1 && ld < rowWidth) {// if my x-y position indicates i'm on a vine
CanopyVineyard.cpp:                WGD->icellflag[icell_cent] = 28;
CanopyVineyard.cpp:                //std::cout << "bleed flow is being applied, entry. icellflag is: " << WGD->icellflag[icell_cent] << "\n";
CanopyVineyard.cpp:                WGD->icellflag[icell_cent] = 29;
CanopyVineyard.cpp:          }// end bleed flow x-y if
CanopyVineyard.cpp:            WGD->icellflag[icell_cent] = 30;
CanopyVineyard.cpp:            if (UD_zone_flag && ((rowSpacing - ld) < l_ud) && (z_rel <= z_ud)) {// if i'm ALSO in the UD zone
CanopyVineyard.cpp:              //  If the rotated u-velocity was negative in the UD zone, this reverses it and then SUBTRACTS bleed flow. If the rotated u-velocity was positive in the UD zone, this reverses it and then ADDS bleed flow
CanopyVineyard.cpp:              WGD->icellflag[icell_cent] = 31;
CanopyVineyard.cpp:                //    std::cout << "k = " << k <<  "     u_c = " << u_c << "       gz = " <<  (a_obf*pow(a_uw,N)*u_c0 - 2*u_c)*(1-exp(br*(z_ud-z_rel))) << "     br = " << br << "     x_ud = " << x_ud << "     1st chunk = " <<  a_obf*pow(a_uw,N)*u_c0  <<  "\n";
CanopyVineyard.cpp:                // u_c = u_c + (a_obf*pow(a_uw,N+3)*u_c0 - 2*u_c)*(1-exp(br*(z_ud-z_rel)));
CanopyVineyard.cpp:                // u_c = u_c + (-2*u_c)*(1-exp(br*(z_ud-z_rel)));
CanopyVineyard.cpp:                u_c = -u_c;
CanopyVineyard.cpp:                //    std::cout << "k = " << k <<  "     u_c = " << u_c << "     gz = " <<  (a_obf*pow(a_uw,N_e)*u_c0 - 2*u_c)*(1-exp(br*(z_ud-z_rel))) << "     br = " << br << "     x_ud = " << x_ud << "     z_ud = " << z_ud << "      1st chunk = " <<  a_obf*pow(a_uw,N_e)*u_c0   << "\n";
CanopyVineyard.cpp:                //u_c = u_c + (a_obf*pow(a_uw,N_e+3)*u_c0 - 2*u_c)*(1-exp(br*(z_ud-z_rel)));
CanopyVineyard.cpp:                //u_c = u_c + (-2*u_c)*(1-exp(br*(z_ud-z_rel)));
CanopyVineyard.cpp:                u_c = -u_c;
CanopyVineyard.cpp:              v_c = vH_c * exp(a_v * (z_rel / H - 1));
CanopyVineyard.cpp:              // Calculate height-dependent stability correction quantities
CanopyVineyard.cpp:                psi = -5.0 * (z_rel - d_v) * rL;
CanopyVineyard.cpp:                ex = pow((1. - 15. * (z_rel - d_v) * rL), 0.25);
CanopyVineyard.cpp:                psi = log((0.5 * (1. + pow(ex, 2))) * pow(0.5 * (1. + ex), 2)) - 2. * atan(ex) + M_PI * 0.5;
CanopyVineyard.cpp:              v_c = ustar_v_c / WGD->vk * (log((z_rel - d_v) / z0_site) - psi);
CanopyVineyard.cpp:            //std::cout << "k = " << k <<  "     u_c = " << u_c << "       gz = " <<  (a_obf*pow(a_uw,N)*u_c0 - 2*u_c)*(1-exp(br*(z_ud-z_rel))) << "     br = " << br << "     x_ud = " << x_ud << "     1st chunk = " <<  a_obf*pow(a_uw,N)*u_c0  <<  "\n";
CanopyVineyard.cpp:            std::cout << "After params, U = " << cosA * u_c + sinA * v_c << " V = " << -sinA * u_c + cosA * v_c << " arctan(U/V) = " << 180. / M_PI * atan((cosA * u_c + sinA * v_c) / (-sinA * u_c + cosA * v_c)) << "\n";
CanopyVineyard.cpp:          // Rotate back into QES-grid coordinates
CanopyVineyard.cpp:          v0_modified.push_back(-sinA * u_c + cosA * v_c);
CanopyVineyard.cpp:        }// end k-loop
CanopyVineyard.cpp:                    v0_mod_id.push_back(icell_face+WGD->nx);
CanopyVineyard.cpp:    }// end i-loop
CanopyVineyard.cpp:  }// end j-loop
CanopyVineyard.cpp:    WGD->u0[u0_mod_id[x_id]] = u0_modified[x_id];
CanopyVineyard.cpp:    WGD->v0[v0_mod_id[y_id]] = v0_modified[y_id];
CanopyVineyard.h:    //parsePrimitive<float>(true, L, "length"); // in y-direction (before rotation)
CanopyVineyard.h:    //parsePrimitive<float>(true, W, "width"); // in x-direction (before rotation)
CanopyVineyard.h:    //x_start += UID->simParams->halo_x;
CanopyVineyard.h:    //y_start += UID->simParams->halo_y;
CanopyVineyard.h:        polygonVertices[1].x_poly = x_start-L*sin(canopy_rotation);
CanopyWindbreak.cpp: * This file is part of QES-Winds
CanopyWindbreak.cpp: * GPL-3.0 License
CanopyWindbreak.cpp: * QES-Winds is free software: you can redistribute it and/or modify
CanopyWindbreak.cpp: * QES-Winds is distributed in the hope that it will be useful,
CanopyWindbreak.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
CanopyWindbreak.cpp:  // Based on Wm. Randolph Franklin, "PNPOLY - Point Inclusion in Polygon Test"
CanopyWindbreak.cpp:    float y_cent = (j + 0.5) * WGD->dy;
CanopyWindbreak.cpp:      float x_cent = (i + 0.5) * WGD->dx;
CanopyWindbreak.cpp:      while (vert_id < polygonVertices.size() - 1) {
CanopyWindbreak.cpp:          ray_intersect = (y_cent - polygonVertices[vert_id].y_poly) / (polygonVertices[vert_id + 1].y_poly - polygonVertices[vert_id].y_poly);
CanopyWindbreak.cpp:          if (x_cent < (polygonVertices[vert_id].x_poly + ray_intersect * (polygonVertices[vert_id + 1].x_poly - polygonVertices[vert_id].x_poly))) {
CanopyWindbreak.cpp:        int icell_2d = i + j * (WGD->nx - 1);
CanopyWindbreak.cpp:        if (WGD->icellflag_footprint[icell_2d] == 0) {
CanopyWindbreak.cpp:          // a  building exist here -> skip
CanopyWindbreak.cpp:          WGD->icellflag_footprint[icell_2d] = getCellFlagCanopy();
CanopyWindbreak.cpp:          // Define start index of the canopy in z-direction
CanopyWindbreak.cpp:          for (size_t k = 1u; k < WGD->z.size(); k++) {
CanopyWindbreak.cpp:            if (WGD->terrain[icell_2d] + base_height <= WGD->z[k]) {
CanopyWindbreak.cpp:              WGD->canopy->canopy_bot_index[icell_2d] = k;
CanopyWindbreak.cpp:              WGD->canopy->canopy_bot[icell_2d] = WGD->terrain[icell_2d] + base_height;
CanopyWindbreak.cpp:              WGD->canopy->canopy_base[icell_2d] = WGD->z_face[k - 1];
CanopyWindbreak.cpp:          // Define end index of the canopy in z-direction
CanopyWindbreak.cpp:          for (size_t k = 0u; k < WGD->z.size(); k++) {
CanopyWindbreak.cpp:            if (WGD->terrain[icell_2d] + H < WGD->z[k + 1]) {
CanopyWindbreak.cpp:              WGD->canopy->canopy_top_index[icell_2d] = k + 1;
CanopyWindbreak.cpp:              WGD->canopy->canopy_top[icell_2d] = WGD->terrain[icell_2d] + H;
CanopyWindbreak.cpp:          WGD->canopy->canopy_height[icell_2d] = WGD->canopy->canopy_top[icell_2d] - WGD->canopy->canopy_bot[icell_2d];
CanopyWindbreak.cpp:          for (auto k = WGD->canopy->canopy_bot_index[icell_2d]; k < WGD->canopy->canopy_top_index[icell_2d]; k++) {
CanopyWindbreak.cpp:            int icell_3d = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyWindbreak.cpp:            if (WGD->icellflag[icell_3d] != 0 && WGD->icellflag[icell_3d] != 2) {
CanopyWindbreak.cpp:              WGD->icellflag[icell_3d] = getCellFlagCanopy();
CanopyWindbreak.cpp:              //WGD->canopy->canopy_atten_coeff[icell_3d] = attenuationCoeff;
CanopyWindbreak.cpp:              WGD->canopy->icanopy_flag[icell_3d] = canopy_id;
CanopyWindbreak.cpp:    k_start = WGD->nz - 1;
CanopyWindbreak.cpp:      if (WGD->canopy->canopy_bot_index[canopy_cell2D[k]] < k_start)
CanopyWindbreak.cpp:        k_start = WGD->canopy->canopy_bot_index[canopy_cell2D[k]];
CanopyWindbreak.cpp:      if (WGD->canopy->canopy_top_index[canopy_cell2D[k]] > k_end)
CanopyWindbreak.cpp:        k_end = WGD->canopy->canopy_top_index[canopy_cell2D[k]];
CanopyWindbreak.cpp:  if (ceil(1.5 * k_end) > WGD->nz - 1) {
CanopyWindbreak.cpp:  int icell_face = i_building_cent + j_building_cent * WGD->nx + k_end * WGD->nx * WGD->ny;
CanopyWindbreak.cpp:  u0_h = WGD->u0[icell_face];// u velocity at the height of building at the centroid
CanopyWindbreak.cpp:  v0_h = WGD->v0[icell_face];// v velocity at the height of building at the centroid
CanopyWindbreak.cpp:    int j = (int)((icell_2d) / (WGD->nx - 1));
CanopyWindbreak.cpp:    int i = icell_2d - j * (WGD->nx - 1);
CanopyWindbreak.cpp:    float z_b = WGD->z[WGD->terrain_id[icell_2d]];
CanopyWindbreak.cpp:    for (auto k = WGD->canopy->canopy_bot_index[icell_2d]; k < WGD->canopy->canopy_top_index[icell_2d]; ++k) {
CanopyWindbreak.cpp:      int icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
CanopyWindbreak.cpp:      if ((WGD->z_face[k - 1] - z_b >= understory_height) && (WGD->z_face[k - 1] - z_b <= H)) {
CanopyWindbreak.cpp:            example: u0[]*=(1-p)
CanopyWindbreak.cpp:        v0_modified[icell_face + WGD->nx] = a_obf;
CanopyWindbreak.cpp:    WGD->u0[m.first] *= m.second;
CanopyWindbreak.cpp:    WGD->v0[m.first] *= m.second;
CanopyWindbreak.cpp:  const float epsilon = 10e-10;
CanopyWindbreak.cpp:  float udelt = (1 - a_obf);// udelt parameters
CanopyWindbreak.cpp:  /* FM - OBSOLETE (using tanh to blend recovery zone)
CanopyWindbreak.cpp:     Perrera 1981 contains a typo "K=(2.0*k^2)/(ln(H-d)/zo)" where k is von Karman's constant.
CanopyWindbreak.cpp:     "Wakes behind two-dimensional surface obstacles in turbulent boundary layers"
CanopyWindbreak.cpp:  //float K = (2.0 * 0.4 * 0.4) / log((H - d) / zo);
CanopyWindbreak.cpp:  //int k_bottom(1), k_top(WGD->nz - 2);
CanopyWindbreak.cpp:  icell_face = i_building_cent + j_building_cent * WGD->nx + k_end * WGD->nx * WGD->ny;
CanopyWindbreak.cpp:  u0_h = WGD->u0[icell_face];// u velocity at the height of building at the centroid
CanopyWindbreak.cpp:  v0_h = WGD->v0[icell_face];// v velocity at the height of building at the centroid
CanopyWindbreak.cpp:    xi[id] = (polygonVertices[id].x_poly - building_cent_x) * cos(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * sin(upwind_dir);
CanopyWindbreak.cpp:    yi[id] = -(polygonVertices[id].x_poly - building_cent_x) * sin(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * cos(upwind_dir);
CanopyWindbreak.cpp:  for (auto id = 0u; id < polygonVertices.size() - 1; id++) {
CanopyWindbreak.cpp:    upwind_rel_dir[id] = atan2(yi[id + 1] - yi[id], xi[id + 1] - xi[id]) + 0.5 * M_PI;
CanopyWindbreak.cpp:      upwind_rel_dir[id] -= 2 * M_PI;
CanopyWindbreak.cpp:    if ((abs(upwind_rel_dir[id]) < 0.5 * M_PI - tol) && (id % 2 == 0))
CanopyWindbreak.cpp:    if ((polygonVertices[id + 1].x_poly > polygonVertices[0].x_poly - 0.1)
CanopyWindbreak.cpp:        && (polygonVertices[id + 1].y_poly > polygonVertices[0].y_poly - 0.1)
CanopyWindbreak.cpp:      for (auto y_id = 0; y_id <= 2 * ceil(abs(yi[id] - yi[id + 1]) / WGD->dxy); y_id++) {
CanopyWindbreak.cpp:        // y-coord relative to center of the windbreak (left to right)
CanopyWindbreak.cpp:        y_c = yi[id] - 0.5 * y_id * WGD->dxy;
CanopyWindbreak.cpp:          x_wall = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (y_c - yi[id]) + xi[id];
CanopyWindbreak.cpp:        int i = ((x_wall - WGD->dxy) * cos(upwind_dir) - y_c * sin(upwind_dir) + building_cent_x) / WGD->dx;
CanopyWindbreak.cpp:        int j = ((x_wall - WGD->dxy) * sin(upwind_dir) + y_c * cos(upwind_dir) + building_cent_y) / WGD->dy;
CanopyWindbreak.cpp:        if (i >= WGD->nx - 2 && i <= 0 && j >= WGD->ny - 2 && j <= 0)
CanopyWindbreak.cpp:        for (auto z_id = 5.0 * H / WGD->dz; z_id > 0; z_id--) {
CanopyWindbreak.cpp:          int x_id_min = -1;
CanopyWindbreak.cpp:          for (auto x_id = 1; x_id <= 2 * ceil(wake_stream_coef * Lr / WGD->dxy); x_id++) {
CanopyWindbreak.cpp:            // x-coord relative to center of the windbreak (downstream)
CanopyWindbreak.cpp:            x_c = 0.5 * x_id * WGD->dxy;
CanopyWindbreak.cpp:            int i = ceil(((x_c + x_wall) * cos(upwind_dir) - y_c * sin(upwind_dir) + building_cent_x) / WGD->dx) - 1;
CanopyWindbreak.cpp:            int j = ceil(((x_c + x_wall) * sin(upwind_dir) + y_c * cos(upwind_dir) + building_cent_y) / WGD->dy) - 1;
CanopyWindbreak.cpp:            int k = z_id + WGD->terrain_id[i + j * (WGD->nx - 1)] - 1;
CanopyWindbreak.cpp:            int k_top = H / WGD->dz + WGD->terrain_id[i + j * (WGD->nx - 1)];
CanopyWindbreak.cpp:            // z-coord relative to the base of the building.
CanopyWindbreak.cpp:            z_c = WGD->z[k] - WGD->z_face[WGD->terrain_id[i + j * (WGD->nx - 1)] - 1];
CanopyWindbreak.cpp:            if (i >= WGD->nx - 2 && i <= 0 && j >= WGD->ny - 2 && j <= 0)
CanopyWindbreak.cpp:            icell_face = i + j * WGD->nx + k_top * WGD->nx * WGD->ny;
CanopyWindbreak.cpp:            u0_wh = WGD->u0[icell_face];
CanopyWindbreak.cpp:            v0_wh = WGD->v0[icell_face];
CanopyWindbreak.cpp:            w0_wh = WGD->w0[icell_face];
CanopyWindbreak.cpp:              zwmo = H + w0_wh / umag0_wh * WGD->dx;
CanopyWindbreak.cpp:            icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyWindbreak.cpp:            if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2 && x_id_min < 0)
CanopyWindbreak.cpp:            if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2 || WGD->icellflag[icell_cent] == getCellFlagCanopy()) {
CanopyWindbreak.cpp:                if (WGD->ibuilding_flag[icell_cent] == building_id) {
CanopyWindbreak.cpp:                  x_id_min = -1;
CanopyWindbreak.cpp:                } else if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2) {
CanopyWindbreak.cpp:            if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2
CanopyWindbreak.cpp:                && WGD->icellflag[icell_cent] != getCellFlagCanopy()) {
CanopyWindbreak.cpp:              // wake u-values
CanopyWindbreak.cpp:              // ij coord of u-face
CanopyWindbreak.cpp:              int i_u = std::round(((x_c + x_wall) * cos(upwind_dir) - y_c * sin(upwind_dir) + building_cent_x) / WGD->dx);
CanopyWindbreak.cpp:              int j_u = ((x_c + x_wall) * sin(upwind_dir) + y_c * cos(upwind_dir) + building_cent_y) / WGD->dy;
CanopyWindbreak.cpp:              if (i_u < WGD->nx - 1 && i_u > 0 && j_u < WGD->ny - 1 && j_u > 0) {
CanopyWindbreak.cpp:                // not rotated relative coordinate of u-face
CanopyWindbreak.cpp:                x_p = i_u * WGD->dx - building_cent_x;
CanopyWindbreak.cpp:                y_p = (j_u + 0.5) * WGD->dy - building_cent_y;
CanopyWindbreak.cpp:                // rotated relative coordinate of u-face
CanopyWindbreak.cpp:                y_u = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
CanopyWindbreak.cpp:                  x_wall_u = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (y_u - yi[id]) + xi[id];
CanopyWindbreak.cpp:                x_u -= x_wall_u;
CanopyWindbreak.cpp:                icell_cent = i_u + j_u * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyWindbreak.cpp:                icell_face = i_u + j_u * WGD->nx + k * WGD->nx * WGD->ny;
CanopyWindbreak.cpp:                if (dn_u > 0.0 && u_wake_flag == 1 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
CanopyWindbreak.cpp:                  float aeropor = (0.5 * (1.0 - a_obf)) * tanh(1.5 * (z_c - zwmo) / d_shearzone) + 0.5 * (1.0 + a_obf);
CanopyWindbreak.cpp:                  float recovery = 0.5 - 0.5 * tanh((x_u - wake_shear_coef * Lr - 0.5 * wake_recov_coef * Lr) / (0.25 * wake_recov_coef * Lr));
CanopyWindbreak.cpp:                  WGD->canopy->wake_u_defect[icell_face] = (1.0 - aeropor) * recovery;
CanopyWindbreak.cpp:                  WGD->canopy->wake_u_defect[icell_face] *= (0.5 - 0.5 * tanh(1.5 * (y_u - (y2 - ds)) / ds));
CanopyWindbreak.cpp:                  WGD->canopy->wake_u_defect[icell_face] *= (0.5 - 0.5 * tanh(1.5 * ((y1 + ds) - y_u) / ds));
CanopyWindbreak.cpp:              // wake v-values
CanopyWindbreak.cpp:              // ij coord of v-face
CanopyWindbreak.cpp:              int i_v = ((x_c + x_wall) * cos(upwind_dir) - y_c * sin(upwind_dir) + building_cent_x) / WGD->dx;
CanopyWindbreak.cpp:              int j_v = std::round(((x_c + x_wall) * sin(upwind_dir) + y_c * cos(upwind_dir) + building_cent_y) / WGD->dy);
CanopyWindbreak.cpp:              if (i_v < WGD->nx - 1 && i_v > 0 && j_v < WGD->ny - 1 && j_v > 0) {
CanopyWindbreak.cpp:                // not rotated relative coordinate of v-face
CanopyWindbreak.cpp:                x_p = (i_v + 0.5) * WGD->dx - building_cent_x;
CanopyWindbreak.cpp:                y_p = j_v * WGD->dy - building_cent_y;
CanopyWindbreak.cpp:                // rotated relative coordinate of u-face
CanopyWindbreak.cpp:                y_v = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
CanopyWindbreak.cpp:                  x_wall_v = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (y_v - yi[id]) + xi[id];
CanopyWindbreak.cpp:                x_v -= x_wall_v;
CanopyWindbreak.cpp:                icell_cent = i_u + j_u * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyWindbreak.cpp:                icell_face = i_v + j_v * WGD->nx + k * WGD->nx * WGD->ny;
CanopyWindbreak.cpp:                if (dn_v > 0.0 && v_wake_flag == 1 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
CanopyWindbreak.cpp:                  float aeropor = (0.5 * (1.0 - a_obf)) * tanh(1.5 / (d_shearzone) * (z_c)-1.5 / (d_shearzone)*zwmo) + 0.5 * (1.0 + a_obf);
CanopyWindbreak.cpp:                  float recovery = 0.5 - 0.5 * tanh((x_v - wake_shear_coef * Lr - 0.5 * wake_recov_coef * Lr) / (0.25 * wake_recov_coef * Lr));
CanopyWindbreak.cpp:                  WGD->canopy->wake_v_defect[icell_face] = (1.0 - aeropor) * recovery;
CanopyWindbreak.cpp:                  WGD->canopy->wake_v_defect[icell_face] *= (-0.5 * tanh(1.5 * (y_u - (y2 - ds)) / ds) + 0.5);
CanopyWindbreak.cpp:                  WGD->canopy->wake_v_defect[icell_face] *= (-0.5 * tanh(1.5 * ((y1 + ds) - y_u) / ds) + 0.5);
CanopyWindbreak.cpp:              // wake celltype w-values
CanopyWindbreak.cpp:              // ij coord of cell-center
CanopyWindbreak.cpp:              int i_w = ceil(((x_c + x_wall) * cos(upwind_dir) - y_c * sin(upwind_dir) + building_cent_x) / WGD->dx) - 1;
CanopyWindbreak.cpp:              int j_w = ceil(((x_c + x_wall) * sin(upwind_dir) + y_c * cos(upwind_dir) + building_cent_y) / WGD->dy) - 1;
CanopyWindbreak.cpp:              if (i_w < WGD->nx - 1 && i_w > 0 && j_w < WGD->ny - 1 && j_w > 0) {
CanopyWindbreak.cpp:                // not rotated relative coordinate of cell-center
CanopyWindbreak.cpp:                x_p = (i_w + 0.5) * WGD->dx - building_cent_x;
CanopyWindbreak.cpp:                y_p = (j_w + 0.5) * WGD->dy - building_cent_y;
CanopyWindbreak.cpp:                // rotated relative coordinate of cell-center
CanopyWindbreak.cpp:                y_w = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
CanopyWindbreak.cpp:                  x_wall_w = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (y_w - yi[id]) + xi[id];
CanopyWindbreak.cpp:                x_w -= x_wall_w;
CanopyWindbreak.cpp:                icell_cent = i_w + j_w * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CanopyWindbreak.cpp:                if (dn_w > 0.0 && w_wake_flag == 1 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
CanopyWindbreak.cpp:                  WGD->icellflag[icell_cent] = getCellFlagWake();
CanopyWindbreak.cpp:              // if u,v, and w are done -> exit x-loop
CanopyWindbreak.h: * This file is part of QES-Winds
CanopyWindbreak.h: * GPL-3.0 License
CanopyWindbreak.h: * QES-Winds is free software: you can redistribute it and/or modify
CanopyWindbreak.h: * QES-Winds is distributed in the hope that it will be useful,
CanopyWindbreak.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
CanopyWindbreak.h:    // x_start += UID->simParams->halo_x;
CanopyWindbreak.h:    // y_start += UID->simParams->halo_y;
CanopyWindbreak.h:    polygonVertices[1].x_poly = x_start - L * sin(canopy_rotation);
Cell.cpp: * This file is part of QES-Winds
Cell.cpp: * GPL-3.0 License
Cell.cpp: * QES-Winds is free software: you can redistribute it and/or modify
Cell.cpp: * QES-Winds is distributed in the hope that it will be useful,
Cell.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Cell.cpp:      } else if (intermed[firstC][secondC][1] == -1)
Cell.cpp:        if (intermed[firstC][secondC][j] != -1)
Cell.cpp:          if (intermed[first][second][i - 4] != -1)
Cell.cpp:            fluidFacePoints[i].push_back(points[intermed[first][second][i - 4]]);
Cell.h: * This file is part of QES-Winds
Cell.h: * GPL-3.0 License
Cell.h: * QES-Winds is free software: you can redistribute it and/or modify
Cell.h: * QES-Winds is distributed in the hope that it will be useful,
Cell.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
CPUSolver.cpp: * This file is part of QES-Winds
CPUSolver.cpp: * GPL-3.0 License
CPUSolver.cpp: * QES-Winds is free software: you can redistribute it and/or modify
CPUSolver.cpp: * QES-Winds is distributed in the hope that it will be useful,
CPUSolver.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
CPUSolver.cpp:  int icell_face;// cell-face index
CPUSolver.cpp:  int icell_cent;// cell-centered index
CPUSolver.cpp:  R.resize(WGD->numcell_cent, 0.0);
CPUSolver.cpp:  lambda.resize(WGD->numcell_cent, 0.0);
CPUSolver.cpp:  lambda_old.resize(WGD->numcell_cent, 0.0);
CPUSolver.cpp:  for (int k = 1; k < WGD->nz - 2; k++) {
CPUSolver.cpp:    for (int j = 0; j < WGD->ny - 1; j++) {
CPUSolver.cpp:      for (int i = 0; i < WGD->nx - 1; i++) {
CPUSolver.cpp:        icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
CPUSolver.cpp:        icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
CPUSolver.cpp:        R[icell_cent] = (-2 * pow(alpha1, 2.0)) * (((WGD->u0[icell_face + 1] - WGD->u0[icell_face]) / WGD->dx) + ((WGD->v0[icell_face + WGD->nx] - WGD->v0[icell_face]) / WGD->dy) + ((WGD->w0[icell_face + WGD->nx * WGD->ny] - WGD->w0[icell_face]) / WGD->dz_array[k]));
CPUSolver.cpp:      for (int k = 1; k < WGD->nz - 2; k++) {
CPUSolver.cpp:        for (int j = 1; j < WGD->ny - 2; j++) {
CPUSolver.cpp:          for (int i = 1; i < WGD->nx - 2; i++) {
CPUSolver.cpp:            icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);// Lineralized index for cell centered values
CPUSolver.cpp:            lambda[icell_cent] = (omega / (WGD->e[icell_cent] + WGD->f[icell_cent] + WGD->g[icell_cent] + WGD->h[icell_cent] + WGD->m[icell_cent] + WGD->n[icell_cent]))
CPUSolver.cpp:                                   * (WGD->e[icell_cent] * lambda[icell_cent + 1]
CPUSolver.cpp:                                      + WGD->f[icell_cent] * lambda[icell_cent - 1]
CPUSolver.cpp:                                      + WGD->g[icell_cent] * lambda[icell_cent + (WGD->nx - 1)]
CPUSolver.cpp:                                      + WGD->h[icell_cent] * lambda[icell_cent - (WGD->nx - 1)]
CPUSolver.cpp:                                      + WGD->m[icell_cent] * lambda[icell_cent + (WGD->nx - 1) * (WGD->ny - 1)]
CPUSolver.cpp:                                      + WGD->n[icell_cent] * lambda[icell_cent - (WGD->nx - 1) * (WGD->ny - 1)] - R[icell_cent])
CPUSolver.cpp:                                 + (1.0 - omega) * lambda[icell_cent];// SOR formulation
CPUSolver.cpp:      for (int j = 0; j < WGD->ny - 1; j++) {
CPUSolver.cpp:        for (int i = 0; i < WGD->nx - 1; i++) {
CPUSolver.cpp:          int icell_cent = i + j * (WGD->nx - 1);// Lineralized index for cell centered values
CPUSolver.cpp:          lambda[icell_cent] = lambda[icell_cent + (WGD->nx - 1) * (WGD->ny - 1)];
CPUSolver.cpp:      for (int k = 0; k < WGD->nz - 1; k++) {
CPUSolver.cpp:        for (int j = 0; j < WGD->ny - 1; j++) {
CPUSolver.cpp:          for (int i = 0; i < WGD->nx - 1; i++) {
CPUSolver.cpp:            int icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);// Lineralized index for cell centered values
CPUSolver.cpp:            error = fabs(lambda[icell_cent] - lambda_old[icell_cent]);
CPUSolver.cpp:     *** Update the velocity field using Euler-Lagrange equations **
CPUSolver.cpp:    for (int k = 0; k < WGD->nz; k++) {
CPUSolver.cpp:      for (int j = 0; j < WGD->ny; j++) {
CPUSolver.cpp:        for (int i = 0; i < WGD->nx; i++) {
CPUSolver.cpp:          int icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;// Lineralized index for cell faced values
CPUSolver.cpp:          WGD->u[icell_face] = WGD->u0[icell_face];
CPUSolver.cpp:          WGD->v[icell_face] = WGD->v0[icell_face];
CPUSolver.cpp:          WGD->w[icell_face] = WGD->w0[icell_face];
CPUSolver.cpp:    for (int k = 1; k < WGD->nz - 2; k++) {
CPUSolver.cpp:      for (int j = 1; j < WGD->ny - 1; j++) {
CPUSolver.cpp:        for (int i = 1; i < WGD->nx - 1; i++) {
CPUSolver.cpp:          icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);// Lineralized index for cell centered values
CPUSolver.cpp:          icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;// Lineralized index for cell faced values
CPUSolver.cpp:          WGD->u[icell_face] = WGD->u0[icell_face]
CPUSolver.cpp:                               + (1 / (2 * pow(alpha1, 2.0))) * WGD->f[icell_cent] * WGD->dx
CPUSolver.cpp:                                   * (lambda[icell_cent] - lambda[icell_cent - 1]);
CPUSolver.cpp:          WGD->v[icell_face] = WGD->v0[icell_face]
CPUSolver.cpp:                               + (1 / (2 * pow(alpha1, 2.0))) * WGD->h[icell_cent] * WGD->dy
CPUSolver.cpp:                                   * (lambda[icell_cent] - lambda[icell_cent - (WGD->nx - 1)]);
CPUSolver.cpp:          WGD->w[icell_face] = WGD->w0[icell_face]
CPUSolver.cpp:                               + (1 / (2 * pow(alpha2, 2.0))) * WGD->n[icell_cent] * WGD->dz_array[k]
CPUSolver.cpp:                                   * (lambda[icell_cent] - lambda[icell_cent - (WGD->nx - 1) * (WGD->ny - 1)]);
CPUSolver.cpp:    for (int k = 1; k < WGD->nz - 1; k++) {
CPUSolver.cpp:      for (int j = 0; j < WGD->ny - 1; j++) {
CPUSolver.cpp:        for (int i = 0; i < WGD->nx - 1; i++) {
CPUSolver.cpp:          icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);// Lineralized index for cell centered values
CPUSolver.cpp:          icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;// Lineralized index for cell faced values
CPUSolver.cpp:          if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2) {
CPUSolver.cpp:            WGD->u[icell_face] = 0;
CPUSolver.cpp:            WGD->u[icell_face + 1] = 0;
CPUSolver.cpp:            WGD->v[icell_face] = 0;
CPUSolver.cpp:            WGD->v[icell_face + WGD->nx] = 0;
CPUSolver.cpp:            WGD->w[icell_face] = 0;
CPUSolver.cpp:            WGD->w[icell_face + WGD->nx * WGD->ny] = 0;
CPUSolver.cpp:    std::chrono::duration<float> elapsedTotal = finish - startOfSolveMethod;
CPUSolver.cpp:    std::chrono::duration<float> elapsedSolve = finish - startSolveSection;
CPUSolver.h: * This file is part of QES-Winds
CPUSolver.h: * GPL-3.0 License
CPUSolver.h: * QES-Winds is free software: you can redistribute it and/or modify
CPUSolver.h: * QES-Winds is distributed in the hope that it will be useful,
CPUSolver.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Cut_cell.cpp: * This file is part of QES-Winds
Cut_cell.cpp: * GPL-3.0 License
Cut_cell.cpp: * QES-Winds is free software: you can redistribute it and/or modify
Cut_cell.cpp: * QES-Winds is distributed in the hope that it will be useful,
Cut_cell.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Cut_cell.cpp:  std::vector<int> cutcell_index;// Index of cut-cells
Cut_cell.cpp:  //cells = new Cell[(WGD->nx - 1) * (WGD->ny - 1) * (WGD->nz - 1)];
Cut_cell.cpp:  // Get cut-cell indices from terrain function
Cut_cell.cpp:  //cutcell_index = DTEHF->setCells(cells, WGD->nx, WGD->ny, WGD->nz, WGD->dx, WGD->dy, WGD->dz_array, WGD->z_face, WID->simParams->halo_x, WID->simParams->halo_y);
Cut_cell.cpp:  for (int i = 0; i < WGD->nx - 1; i++) {
Cut_cell.cpp:    for (int j = 0; j < WGD->ny - 1; j++) {
Cut_cell.cpp:      for (int k = 1; k < WGD->nz - 1; k++) {
Cut_cell.cpp:        int icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Cut_cell.cpp:          WGD->icellflag[icell_cent] = 2;
Cut_cell.cpp:    WGD->icellflag[cutcell_index[i]] = 8;
Cut_cell.cpp:    int k = cutcell_index[j] / ((WGD->nx - 1) * (WGD->ny - 1));
Cut_cell.cpp:    int jjj = (cutcell_index[j] - k * (WGD->nx - 1) * (WGD->ny - 1)) / (WGD->nx - 1);
Cut_cell.cpp:    int iii = cutcell_index[j] - k * (WGD->nx - 1) * (WGD->ny - 1) - jjj * (WGD->nx - 1);
Cut_cell.cpp:            cut_points[jj][l] = cut_points[jj][l] - location[l];
Cut_cell.cpp:            S_right = calculateArea(cut_points, cutcell_index[j], WGD->dx, WGD->dy, WGD->dz_array[k], WGD->n, WGD->m, WGD->f, WGD->e, WGD->h, WGD->g, i);
Cut_cell.cpp:            S_left = calculateArea(cut_points, cutcell_index[j], WGD->dx, WGD->dy, WGD->dz_array[k], WGD->n, WGD->m, WGD->f, WGD->e, WGD->h, WGD->g, i);
Cut_cell.cpp:            S_front = calculateArea(cut_points, cutcell_index[j], WGD->dx, WGD->dy, WGD->dz_array[k], WGD->n, WGD->m, WGD->f, WGD->e, WGD->h, WGD->g, i);
Cut_cell.cpp:            S_behind = calculateArea(cut_points, cutcell_index[j], WGD->dx, WGD->dy, WGD->dz_array[k], WGD->n, WGD->m, WGD->f, WGD->e, WGD->h, WGD->g, i);
Cut_cell.cpp:        S_below = calculateAreaTopBot(terrainPoints, terrainEdges, cutcell_index[j], WGD->dx, WGD->dy, WGD->dz_array[k], location, WGD->n, true);
Cut_cell.cpp:        S_above = calculateAreaTopBot(terrainPoints, terrainEdges, cutcell_index[j], WGD->dx, WGD->dy, WGD->dz_array[k], location, WGD->m, false);
Cut_cell.cpp:      S_cut = sqrt(pow(S_behind - S_front, 2.0) + pow(S_right - S_left, 2.0) + pow(S_below - S_above, 2.0));
Cut_cell.cpp:        ni = (S_behind - S_front) / S_cut;
Cut_cell.cpp:        nj = (S_right - S_left) / S_cut;
Cut_cell.cpp:        nk = (S_below - S_above) / S_cut;
Cut_cell.cpp:        solid_V_frac += (0.0 * (-1) * S_right) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
Cut_cell.cpp:        solid_V_frac += (WGD->dy * (1) * S_left) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
Cut_cell.cpp:        solid_V_frac += (WGD->dx * (1) * S_front) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
Cut_cell.cpp:        solid_V_frac += (0.0 * (-1) * S_behind) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
Cut_cell.cpp:        solid_V_frac += (0.0 * (-1) * S_below) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
Cut_cell.cpp:        solid_V_frac += (WGD->dz_array[k] * (1) * S_above) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
Cut_cell.cpp:      solid_V_frac += (((terrainPoints[0][0] - location[0]) * ni * S_cut) + ((terrainPoints[0][1] - location[1]) * nj * S_cut) + ((terrainPoints[0][2] - location[2]) * nk * S_cut)) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
Cut_cell.cpp:    WGD->terrain_volume_frac[cutcell_index[j]] -= solid_V_frac;
Cut_cell.cpp:    WGD->ni[cutcell_index[j]] = ni;
Cut_cell.cpp:    WGD->nj[cutcell_index[j]] = nj;
Cut_cell.cpp:    WGD->nk[cutcell_index[j]] = nk;
Cut_cell.cpp:    if (WGD->terrain_volume_frac[cutcell_index[j]] < 0.0) {
Cut_cell.cpp:      WGD->terrain_volume_frac[cutcell_index[j]] = 0.0;
Cut_cell.cpp:      angle[i] = (180 / pi) * atan2((cut_points[i][2] - centroid[2]), (cut_points[i][1] - centroid[1]));
Cut_cell.cpp:      angle[i] = (180 / pi) * atan2((cut_points[i][2] - centroid[2]), (cut_points[i][0] - centroid[0]));
Cut_cell.cpp:      angle[i] = (180 / pi) * atan2((cut_points[i][1] - centroid[1]), (cut_points[i][0] - centroid[0]));
Cut_cell.cpp:  // Call sort to sort points based on the angles (from -180 to 180)
Cut_cell.cpp:  angleR.resize(angle.size() - angle.size() / 2);
Cut_cell.cpp:  cutPointsR.resize(cutPoints.size() - cutPoints.size() / 2);
Cut_cell.cpp:        angle_max[i] = -180;
Cut_cell.cpp:        angle[imax[i]] = -999;
Cut_cell.cpp:        cut_points[i][0] = cut_points_temp[imax[cut_points.size()-1-i]][0];
Cut_cell.cpp:        cut_points[i][1] = cut_points_temp[imax[cut_points.size()-1-i]][1];
Cut_cell.cpp:        cut_points[i][2] = cut_points_temp[imax[cut_points.size()-1-i]][2];
Cut_cell.cpp:        angle[i] = angle_temp[imax[cut_points.size()-1-i]];
Cut_cell.cpp:    /// calculate area fraction coeeficient for each face of the cut-cell
Cut_cell.cpp:    for (int i = 0; i < cut_points.size() - 1; i++) {
Cut_cell.cpp:      coeff += (0.5 * (cut_points[i + 1][1] + cut_points[i][1]) * (cut_points[i + 1][2] - cut_points[i][2])) / (dy * dz) + (0.5 * (cut_points[i + 1][0] + cut_points[i][0]) * (cut_points[i + 1][2] - cut_points[i][2])) / (dx * dz) + (0.5 * (cut_points[i + 1][0] + cut_points[i][0]) * (cut_points[i + 1][1] - cut_points[i][1])) / (dx * dy);
Cut_cell.cpp:    coeff += (0.5 * (cut_points[0][1] + cut_points[cut_points.size() - 1][1]) * (cut_points[0][2] - cut_points[cut_points.size() - 1][2])) / (dy * dz) + (0.5 * (cut_points[0][0] + cut_points[cut_points.size() - 1][0]) * (cut_points[0][2] - cut_points[cut_points.size() - 1][2])) / (dx * dz) + (0.5 * (cut_points[0][0] + cut_points[cut_points.size() - 1][0]) * (cut_points[0][1] - cut_points[cut_points.size() - 1][1])) / (dx * dy);
Cut_cell.cpp:      S = (1.0 - coeff) * (dy * dz);
Cut_cell.cpp:      S = (1.0 - coeff) * (dy * dz);
Cut_cell.cpp:      S = (1.0 - coeff) * (dx * dz);
Cut_cell.cpp:      S = (1.0 - coeff) * (dx * dz);
Cut_cell.cpp:        S = (1.0 - coeff)*(dx*dy);
Cut_cell.cpp:        S = (1.0 - coeff)*(dx*dy);
Cut_cell.cpp:    if (terrainPoints[i][2] > faceHeight - 0.00001f && terrainPoints[i][2] < faceHeight + 0.00001f)
Cut_cell.cpp:    for (int a = 0; a < pointsOnFace.size() - 2; a++)
Cut_cell.cpp:      for (int b = a + 1; b < pointsOnFace.size() - 1; b++)
Cut_cell.cpp:      a[d] -= location[d];
Cut_cell.cpp:      b[d] -= location[d];
Cut_cell.cpp:      c[d] -= location[d];
Cut_cell.cpp:    float tempArea = (a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) / 2.0f;
Cut_cell.cpp:    area += (tempArea < 0.0f ? tempArea * -1.0f : tempArea);
Cut_cell.cpp:    area = dx * dy - area;
Cut_cell.cpp:  S = (1.0 - coef[cellIndex]) * (dx * dy);
Cut_cell.h: * This file is part of QES-Winds
Cut_cell.h: * GPL-3.0 License
Cut_cell.h: * QES-Winds is free software: you can redistribute it and/or modify
Cut_cell.h: * QES-Winds is distributed in the hope that it will be useful,
Cut_cell.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Cut_cell.h:   * This function calculates area fraction coefficients used in the cut-cell method.
Cut_cell.h:   * on their angle start from -180 to 180 degree.
DTEHeightField.cpp: * This file is part of QES-Winds
DTEHeightField.cpp: * GPL-3.0 License
DTEHeightField.cpp: * QES-Winds is free software: you can redistribute it and/or modify
DTEHeightField.cpp: * QES-Winds is distributed in the hope that it will be useful,
DTEHeightField.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
DTEHeightField.cpp:  for (float j = 0; j < ny - 1; j += step) {
DTEHeightField.cpp:    for (float i = 0; i < nx - 1; i += step) {
DTEHeightField.cpp:      if (idx > heightField.size() - 1) idx = heightField.size() - 1;
DTEHeightField.cpp:      // halo_y to all positions to shift the domain -- these
DTEHeightField.cpp:      if (idx > heightField.size() - 1) {
DTEHeightField.cpp:        idx = heightField.size() - 1;
DTEHeightField.cpp:      if (idx > heightField.size() - 1) {
DTEHeightField.cpp:        std::cout << "---------------" << std::endl;
DTEHeightField.cpp:        idx = heightField.size() - 1;
DTEHeightField.cpp:      if (idx > heightField.size() - 1) idx = heightField.size() - 1;
DTEHeightField.cpp:      if (idx > heightField.size() - 1) idx = heightField.size() - 1;
DTEHeightField.cpp:      if (idx > heightField.size() - 1) idx = heightField.size() - 1;
DTEHeightField.cpp:  // From -- http://www.gdal.org/gdal_tutorial.html
DTEHeightField.cpp:      m_imageDataset->GetDriver()->GetDescription(),
DTEHeightField.cpp:      m_imageDataset->GetDriver()->GetMetadataItem( GDAL_DMD_LONGNAME ) );
DTEHeightField.cpp:      m_imageDataset->GetRasterXSize(), m_imageDataset->GetRasterYSize(),
DTEHeightField.cpp:      m_imageDataset->GetRasterCount() );
DTEHeightField.cpp:  if( m_imageDataset->GetProjectionRef()  != NULL )
DTEHeightField.cpp:    printf( "Projection is `%s'\n", m_imageDataset->GetProjectionRef() );
DTEHeightField.cpp:  if( m_imageDataset->GetGeoTransform( m_imageGeoTransform ) == CE_None )
DTEHeightField.cpp:  m_imageXSize = m_imageDataset->GetRasterXSize();
DTEHeightField.cpp:  m_imageYSize = m_imageDataset->GetRasterYSize();
DTEHeightField.cpp:  // From -- http://www.gdal.org/gdal_tutorial.html
DTEHeightField.cpp:         m_poDataset->GetDriver()->GetDescription(),
DTEHeightField.cpp:         m_poDataset->GetDriver()->GetMetadataItem(GDAL_DMD_LONGNAME));
DTEHeightField.cpp:         m_poDataset->GetRasterXSize(),
DTEHeightField.cpp:         m_poDataset->GetRasterYSize(),
DTEHeightField.cpp:         m_poDataset->GetRasterCount());
DTEHeightField.cpp:  // Attempt to get the spatial reference from this dataset -
DTEHeightField.cpp:  // spatialRef = m_poDataset->GetSpatialRef, but in pre-3.0 versions,
DTEHeightField.cpp:  if (m_poDataset->GetProjectionRef() != NULL)
DTEHeightField.cpp:    printf("\tProjection is `%s'\n", m_poDataset->GetProjectionRef());
DTEHeightField.cpp:  if (m_poDataset->GetGeoTransform(m_geoTransform) == CE_None) {
DTEHeightField.cpp:  poBand = m_poDataset->GetRasterBand(1);
DTEHeightField.cpp:  poBand->GetBlockSize(&nBlockXSize, &nBlockYSize);
DTEHeightField.cpp:         GDALGetDataTypeName(poBand->GetRasterDataType()),
DTEHeightField.cpp:         GDALGetColorInterpretationName(poBand->GetColorInterpretation()));
DTEHeightField.cpp:  adfMinMax[0] = poBand->GetMinimum(&bGotMin);
DTEHeightField.cpp:  adfMinMax[1] = poBand->GetMaximum(&bGotMax);
DTEHeightField.cpp:  if (poBand->GetOverviewCount() > 0)
DTEHeightField.cpp:    printf("\tBand has %d overviews.\n", poBand->GetOverviewCount());
DTEHeightField.cpp:  if (poBand->GetColorTable() != NULL)
DTEHeightField.cpp:           poBand->GetColorTable()->GetColorEntryCount());
DTEHeightField.cpp:  m_rbScale = poBand->GetScale();
DTEHeightField.cpp:  m_rbOffset = poBand->GetOffset();
DTEHeightField.cpp:  m_rbNoData = poBand->GetNoDataValue();
DTEHeightField.cpp:  m_nXSize = poBand->GetXSize();
DTEHeightField.cpp:  m_nYSize = poBand->GetYSize();
DTEHeightField.cpp:  origin_y = m_geoTransform[3] - pixelSizeY * m_nYSize;
DTEHeightField.cpp:  //      demMinX == UTMx - halo_x
DTEHeightField.cpp:  //      demMinY = (UTMy + m_nYSize * perPixelDim) - halo_y
DTEHeightField.cpp:  std::cout << "Mapping between raster coordinates and geo-referenced coordinates" << std::endl;
DTEHeightField.cpp:      end_x = (dem_end_x - domain_end_x) / pixelSizeX;
DTEHeightField.cpp:      end_y = (dem_end_y - domain_end_y) / pixelSizeY;
DTEHeightField.cpp:    m_nXSize = m_nXSize - shift_x - end_x;
DTEHeightField.cpp:    m_nYSize = m_nYSize - shift_y - end_y;
DTEHeightField.cpp:      shift_x = (domain_UTMx - origin_x) / pixelSizeX;
DTEHeightField.cpp:      shift_y = (domain_UTMy - origin_y) / pixelSizeY;
DTEHeightField.cpp:      end_x = (dem_end_x - domain_end_x) / pixelSizeX;
DTEHeightField.cpp:      end_y = (dem_end_y - domain_end_y) / pixelSizeY;
DTEHeightField.cpp:    m_nXSize = m_nXSize - shift_x - end_x;
DTEHeightField.cpp:    m_nYSize = m_nYSize - shift_y - end_y;
DTEHeightField.cpp:  // rb->RasterIO(GF_Read, 0, 0, xsize, ysize, buffer, xsize, ysize, GDT_Float32, 0, 0);
DTEHeightField.cpp:  // CPLErr - CE_Failure if the access fails, otherwise CE_None.
DTEHeightField.cpp:  CPLErr rasterErr = poBand->RasterIO(GF_Read, shift_x, end_y, m_nXSize, m_nYSize, pafScanline, m_nXSize, m_nYSize, GDT_Float32, 0, 0);
DTEHeightField.cpp:  for (float iYline = 0; iYline < m_nYSize - 1; iYline += stepY) {
DTEHeightField.cpp:    for (float iXpixel = 0; iXpixel < m_nXSize - 1; iXpixel += stepX) {
DTEHeightField.cpp:      // turn localized coordinates (Yline and Xpixel) into geo-referenced values.
DTEHeightField.cpp:      // These "should" be real unit-based triangles.. hopefully meters..
DTEHeightField.cpp:      if ((*(m_triList[i]->a))[q] >= 0 && (*(m_triList[i]->a))[q] < min[q])
DTEHeightField.cpp:        min[q] = (*(m_triList[i]->a))[q];
DTEHeightField.cpp:      if ((*(m_triList[i]->b))[q] >= 0 && (*(m_triList[i]->b))[q] < min[q])
DTEHeightField.cpp:        min[q] = (*(m_triList[i]->b))[q];
DTEHeightField.cpp:      if ((*(m_triList[i]->c))[q] >= 0 && (*(m_triList[i]->c))[q] < min[q])
DTEHeightField.cpp:        min[q] = (*(m_triList[i]->c))[q];
DTEHeightField.cpp:      if ((*(m_triList[i]->a))[q] > max[q] && (*(m_triList[i]->a))[q] < LIMIT)
DTEHeightField.cpp:        max[q] = (*(m_triList[i]->a))[q];
DTEHeightField.cpp:      if ((*(m_triList[i]->b))[q] > max[q] && (*(m_triList[i]->b))[q] < LIMIT)
DTEHeightField.cpp:        max[q] = (*(m_triList[i]->b))[q];
DTEHeightField.cpp:      if ((*(m_triList[i]->c))[q] > max[q] && (*(m_triList[i]->c))[q] < LIMIT)
DTEHeightField.cpp:        max[q] = (*(m_triList[i]->c))[q];
DTEHeightField.cpp:      (*(m_triList[i]->a))[q] -= min[q];
DTEHeightField.cpp:      (*(m_triList[i]->b))[q] -= min[q];
DTEHeightField.cpp:      (*(m_triList[i]->c))[q] -= min[q];
DTEHeightField.cpp:      max[q] -= min[q];
DTEHeightField.cpp:      max[q] = max[q] - min[q] + (float)((*grid)[2]);
DTEHeightField.cpp:  std::chrono::duration<double> elapsed = finish - start;
DTEHeightField.cpp:    Vector3 *tVs = new Vector3(-1, -1, -1);
DTEHeightField.cpp:      if ((*(t->a)) == (*verts[j]))
DTEHeightField.cpp:      if ((*(t->b)) == (*verts[j]))
DTEHeightField.cpp:      if ((*(t->c)) == (*verts[j]))
DTEHeightField.cpp:    if ((*tVs)[0] == -1) {
DTEHeightField.cpp:      verts.push_back(t->a);
DTEHeightField.cpp:    if ((*tVs)[1] == -1) {
DTEHeightField.cpp:      verts.push_back(t->b);
DTEHeightField.cpp:    if ((*tVs)[2] == -1) {
DTEHeightField.cpp:      verts.push_back(t->c);
DTEHeightField.cpp:  int rpad = PBWIDTH - lpad;
DTEHeightField.cpp:#define CELL(i, j, k) ((i) + (j) * (nx - 1) + (k) * (nx - 1) * (ny - 1))
DTEHeightField.cpp:  int ii = WID->simParams->halo_x / WGD->dx;
DTEHeightField.cpp:  int jj = WID->simParams->halo_y / WGD->dy;
DTEHeightField.cpp:  int i_domain_end = ii + (m_nXSize * pixelSizeX) / WGD->dx;
DTEHeightField.cpp:  int j_domain_end = jj + (m_nYSize * pixelSizeY) / WGD->dy;
DTEHeightField.cpp:  for (int i = 0; i < WGD->nx - 2; i++)
DTEHeightField.cpp:    for (int j = 0; j < WGD->ny - 2; j++) {
DTEHeightField.cpp:        corners[0] = Vector3(i * WGD->dx, j * WGD->dy, CLAMP(0, max[2], queryHeight(pafScanline, ((i - ii) * WGD->dx) / pixelSizeX, ((j - jj) * WGD->dy) / pixelSizeY) - min[2]));
DTEHeightField.cpp:        corners[1] = Vector3(i * WGD->dx, (j + 1) * WGD->dy, CLAMP(0, max[2], queryHeight(pafScanline, ((i - ii) * WGD->dx) / pixelSizeX, (((j - jj) + 1) * WGD->dy) / pixelSizeY) - min[2]));
DTEHeightField.cpp:        corners[2] = Vector3((i + 1) * WGD->dx, (j + 1) * WGD->dy, CLAMP(0, max[2], queryHeight(pafScanline, (((i - ii) + 1) * WGD->dx) / pixelSizeX, (((j - jj) + 1) * WGD->dy) / pixelSizeY) - min[2]));
DTEHeightField.cpp:        corners[3] = Vector3((i + 1) * WGD->dx, j * WGD->dy, CLAMP(0, max[2], queryHeight(pafScanline, (((i - ii) + 1) * WGD->dx) / pixelSizeX, ((j - jj) * WGD->dy) / pixelSizeY) - min[2]));
DTEHeightField.cpp:        corners[0] = Vector3(i * WGD->dx, j * WGD->dy, 0.0f);
DTEHeightField.cpp:        corners[1] = Vector3(i * WGD->dx, (j + 1) * WGD->dy, 0.0f);
DTEHeightField.cpp:        corners[2] = Vector3((i + 1) * WGD->dx, (j + 1) * WGD->dy, 0.0f);
DTEHeightField.cpp:        corners[3] = Vector3((i + 1) * WGD->dx, j * WGD->dy, 0.0f);
DTEHeightField.cpp:          //std::cout << "height:  " << queryHeight( pafScanline , ( dx) / pixelSizeX,  ( dy) / pixelSizeY) - min[2] << std::endl;
DTEHeightField.cpp:          corners[0] = Vector3( i * dx, j * dy,   queryHeight( pafScanline , ( dx) / pixelSizeX,  ( dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[1] = Vector3( i * dx, (j + 1) * dy, queryHeight( pafScanline , ( dx) / pixelSizeX,  ( dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[2] = Vector3( (i + 1) * dx, (j + 1) * dy, queryHeight( pafScanline , (dx) / pixelSizeX,  (dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[3] = Vector3( (i + 1) * dx, j * dy, queryHeight( pafScanline , (dx) / pixelSizeX,  (dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[0] = Vector3( i * dx, j * dy,   queryHeight( pafScanline , ( dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[1] = Vector3( i * dx, (j + 1) * dy, queryHeight( pafScanline , (dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[2] = Vector3( (i + 1) * dx, (j + 1) * dy, queryHeight( pafScanline , (dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[3] = Vector3( (i + 1) * dx, j * dy, queryHeight( pafScanline , (dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[0] = Vector3( i * dx, j * dy,   queryHeight( pafScanline , (dx) / pixelSizeX,  ( (j-jj) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[1] = Vector3( i * dx, (j + 1) * dy, queryHeight( pafScanline , (dx) / pixelSizeX,  ( (j-jj) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[2] = Vector3( (i + 1) * dx, (j + 1) * dy, queryHeight( pafScanline , (dx) / pixelSizeX,  ( (j-jj) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[3] = Vector3( (i + 1) * dx, j * dy, queryHeight( pafScanline , (dx) / pixelSizeX,  ( (j-jj) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[0] = Vector3( i * dx, j * dy,   queryHeight( pafScanline , ( (i_domain_end-ii-1) * dx) / pixelSizeX,  (dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[1] = Vector3( i * dx, (j + 1) * dy, queryHeight( pafScanline , ( (i_domain_end-ii-1) * dx) / pixelSizeX,  (dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[2] = Vector3( (i + 1) * dx, (j + 1) * dy, queryHeight( pafScanline , ( (i_domain_end-ii-1) * dx) / pixelSizeX,  (dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[3] = Vector3( (i + 1) * dx, j * dy, queryHeight( pafScanline , ( (i_domain_end-ii-1) * dx) / pixelSizeX,  (dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[0] = Vector3( i * dx, j * dy,   queryHeight( pafScanline , ((i-ii) * dx) / pixelSizeX,  (dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[1] = Vector3( i * dx, (j + 1) * dy, queryHeight( pafScanline , ((i-ii) * dx) / pixelSizeX,  (dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[2] = Vector3( (i + 1) * dx, (j + 1) * dy, queryHeight( pafScanline , ((i-ii) * dx) / pixelSizeX,  (dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[3] = Vector3( (i + 1) * dx, j * dy, queryHeight( pafScanline , ((i-ii) * dx) / pixelSizeX,  (dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[0] = Vector3( i * dx, j * dy,   queryHeight( pafScanline , ( (i_domain_end-ii-1) * dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[1] = Vector3( i * dx, (j + 1) * dy, queryHeight( pafScanline , ( (i_domain_end-ii-1) * dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[2] = Vector3( (i + 1) * dx, (j + 1) * dy, queryHeight( pafScanline , ((i_domain_end-ii-1) * dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[3] = Vector3( (i + 1) * dx, j * dy, queryHeight( pafScanline , ((i_domain_end-ii-1) * dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[0] = Vector3( i * dx, j * dy,   queryHeight( pafScanline , ((i_domain_end-ii-1) * dx) / pixelSizeX,  ( (j-jj) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[1] = Vector3( i * dx, (j + 1) * dy, queryHeight( pafScanline , ( (i_domain_end-ii-1) * dx) / pixelSizeX,  ( (j-jj) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[2] = Vector3( (i + 1) * dx, (j + 1) * dy, queryHeight( pafScanline , ((i_domain_end-ii-1) * dx) / pixelSizeX,  ( (j-jj) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:          corners[3] = Vector3( (i + 1) * dx, j * dy, queryHeight( pafScanline , ((i_domain_end-ii-1) * dx) / pixelSizeX,  ( (j-jj) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:        corners[0] = Vector3( i * dx, j * dy,   queryHeight( pafScanline , ((i-ii) * dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:        corners[1] = Vector3( i * dx, (j + 1) * dy, queryHeight( pafScanline , ((i-ii) * dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:        corners[2] = Vector3( (i + 1) * dx, (j + 1) * dy, queryHeight( pafScanline , ((i-ii) * dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:        corners[3] = Vector3( (i + 1) * dx, j * dy, queryHeight( pafScanline , ((i-ii) * dx) / pixelSizeX,  ( (j_domain_end-jj-1) * dy) / pixelSizeY) - min[2]);
DTEHeightField.cpp:        std::cout << "((i-ii) + 1) * dx) / pixelSizeX:  " << ((i-ii) + 1) * dx / pixelSizeX << std::endl;
DTEHeightField.cpp:        std::cout << "((j-jj) * dy) / pixelSizeY:  " << ((j-jj) * dy) / pixelSizeY << std::endl;
DTEHeightField.cpp:        std::cout << "(j_domain_end-jj-1):  " << (j_domain_end-jj-1) << std::endl;
DTEHeightField.cpp:      setCellPoints(cells, i, j, WGD->nx, WGD->ny, WGD->nz, WGD->dz_array, WGD->z_face, corners, cutCells, WGD);
DTEHeightField.cpp:  //std::chrono::duration<float> elapsed = finish - start;
DTEHeightField.cpp:  for (int k = 1; k < nz - 1; k++) {
DTEHeightField.cpp:    float cellBot = z_face[k - 1];
DTEHeightField.cpp:      //cells[CELL(i, j, k)] = Cell(terrain_CT, Vector3(corners[0][0], corners[0][1], cellBot), Vector3(corners[1][0] - corners[0][0], corners[0][1] - corners[3][1], dz_array[k]));
DTEHeightField.cpp:      WGD->icellflag[CELL(i, j, k)] = 2;
DTEHeightField.cpp:      //cells[CELL(i, j, k)] = Cell(air_CT, Vector3(corners[0][0], corners[0][1], cellBot), Vector3(corners[1][0] - corners[0][0], corners[0][1] - corners[3][1], dz_array[k]));
DTEHeightField.cpp:      WGD->icellflag[CELL(i, j, k)] = 1;
DTEHeightField.cpp:      WGD->icellflag[CELL(i, j, k)] = 8;
DTEHeightField.cpp:      int cornerPos[4] = { 0, 0, 0, 0 };// 0 is in, 1 is above, -1 is below
DTEHeightField.cpp:          cornerPos[l] = -1;
DTEHeightField.cpp:      // check intermediates 0-1 0-2 0-3 1-2 2-3
DTEHeightField.cpp:      // initialize all identifiers to -1, this is a position in the list of points that doesn't exist
DTEHeightField.cpp:          intermed[di][dj][0] = intermed[di][dj][1] = -1;
DTEHeightField.cpp:      // for all considered pairs 0-1 0-2 0-3 1-2 2-3, we check to see if they span a Z-dimension boundary
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(second, pointsInCell.size() - 1));
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(first, pointsInCell.size() - 1));
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(second, pointsInCell.size() - 1));
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(first, pointsInCell.size() - 1));
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(first, pointsInCell.size() - 1));
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(second, pointsInCell.size() - 1));
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(first, pointsInCell.size() - 2));
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(second, pointsInCell.size() - 1));
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(first, pointsInCell.size() - 1));
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(second, pointsInCell.size() - 1));
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(second, pointsInCell.size() - 2));
DTEHeightField.cpp:                edgesInCell.push_back(Edge<int>(first, pointsInCell.size() - 1));
DTEHeightField.cpp:            if (intermed[first][second][0] != -1 && intermed[first][second][1] != -1)
DTEHeightField.cpp:        if (cornerPos[1] == -1 + (2 * tier) && intermed[0][1][tier] != -1 && intermed[1][2][tier] != -1)//-1 for bottom, 1 for top
DTEHeightField.cpp:        if (cornerPos[3] == -1 + (2 * tier) && intermed[0][3][tier] != -1 && intermed[2][3][tier] != -1)//-1 for bottom, 1 for top
DTEHeightField.cpp:        int newP = pointsInCell.size() - 1;
DTEHeightField.cpp:            if (intermed[0][1][tier] != -1)
DTEHeightField.cpp:            if (intermed[1][2][tier] != -1)
DTEHeightField.cpp:            if (intermed[0][3][tier] != -1)
DTEHeightField.cpp:            if (intermed[2][3][tier] != -1)
DTEHeightField.cpp:      // intermediate pair.---- != is essentially XOR
DTEHeightField.cpp:      else if ((intermed[0][2][0] != -1) != (intermed[0][2][1] != -1)) {
DTEHeightField.cpp:        int midP = (intermed[0][2][0] != -1 ? intermed[0][2][0] : intermed[0][2][1]);
DTEHeightField.cpp:        if ((cornerPos[1] == -1 && (intermed[0][1][0] == -1 || intermed[1][2][0] == -1)) || (cornerPos[1] == 1 && (intermed[0][1][1] == -1 || intermed[1][2][1] == -1)) || cornerPos[1] == 0)
DTEHeightField.cpp:        if ((cornerPos[3] == -1 && (intermed[0][3][0] == -1 || intermed[2][3][0] == -1)) || (cornerPos[3] == 1 && (intermed[0][3][1] == -1 || intermed[2][3][1] == -1)) || cornerPos[3] == 0)
DTEHeightField.cpp:              if (intermed[first][second][0] != -1)
DTEHeightField.cpp:              if (intermed[first][second][1] != -1)
DTEHeightField.cpp:      else if (intermed[0][2][0] != -1 && intermed[0][2][1] != -1) {
DTEHeightField.cpp:        //for bot, check 0-3, 2-3, 0-1, 1-2  & Corner 1,3
DTEHeightField.cpp:              if (intermed[first][second][0] != -1) {
DTEHeightField.cpp:              if (intermed[first][second][1] != -1)
DTEHeightField.cpp:          if (cornerPos[1] == (topBot == 1 ? -1 : 1))//if the diag is on the cell top, we check if the corner is out of the bottom vice versa.
DTEHeightField.cpp:          if (cornerPos[3] == (topBot == 1 ? -1 : 1))//if the diag is on the cell top, we check if the corner is out of the bottom vice versa.
DTEHeightField.cpp:       * 0-1 0-2 0-3 1-2 2-3, So for example. If 0 is below the cell, 1 is above the cell, 2 is
DTEHeightField.cpp:       * in the cell, and 3 is below the cell. Point 4 is a 0-1 intermediate resting on the ceiling
DTEHeightField.cpp:       * of the cell. Point 5 is a 0-1 intermediate resting on the bottom of the cell. Point 6 is a
DTEHeightField.cpp:       * 0-2 intermediate resting on the bottom. Point 7 is a 1-2 intermediate resting on the top, and
DTEHeightField.cpp:       * Point 8 is a 2-3 intermediate resting on the bottom. I'll send you a picture depicting the look
DTEHeightField.cpp:       * are written in should not matter, edge(0-3) is the same as edge(3-0) and the index of each edge
DTEHeightField.cpp:      //cells[CELL(i, j, k)] = Cell(pointsInCell, edgesInCell, intermed, Vector3(corners[0][0], corners[0][1], cellBot), Vector3(corners[1][0] - corners[0][0], corners[0][1] - corners[3][1], dz_array[k]));
DTEHeightField.cpp:      dimensions = Vector3(corners[1][0] - corners[0][0], corners[0][1] - corners[3][1], dz_array[k]);
DTEHeightField.cpp:          } else if (intermed[firstC][secondC][1] == -1)
DTEHeightField.cpp:            if (intermed[firstC][secondC][j] != -1)
DTEHeightField.cpp:              if (intermed[first][second][i - 4] != -1)
DTEHeightField.cpp:                fluidFacePoints[i].push_back(pointsInCell[intermed[first][second][i - 4]]);
DTEHeightField.cpp:              cut_points[jj][l] = cut_points[jj][l] - location[l];
DTEHeightField.cpp:            WGD->cut_cell->reorderPoints(cut_points, i, pi);
DTEHeightField.cpp:              S_right = WGD->cut_cell->calculateArea(cut_points, cutcell_index, WGD->dx, WGD->dy, WGD->dz_array[k], WGD->n, WGD->m, WGD->f, WGD->e, WGD->h, WGD->g, i);
DTEHeightField.cpp:              S_left = WGD->cut_cell->calculateArea(cut_points, cutcell_index, WGD->dx, WGD->dy, WGD->dz_array[k], WGD->n, WGD->m, WGD->f, WGD->e, WGD->h, WGD->g, i);
DTEHeightField.cpp:              S_front = WGD->cut_cell->calculateArea(cut_points, cutcell_index, WGD->dx, WGD->dy, WGD->dz_array[k], WGD->n, WGD->m, WGD->f, WGD->e, WGD->h, WGD->g, i);
DTEHeightField.cpp:              S_behind = WGD->cut_cell->calculateArea(cut_points, cutcell_index, WGD->dx, WGD->dy, WGD->dz_array[k], WGD->n, WGD->m, WGD->f, WGD->e, WGD->h, WGD->g, i);
DTEHeightField.cpp:          S_below = WGD->cut_cell->calculateAreaTopBot(terrainPoints, terrainEdges, cutcell_index, WGD->dx, WGD->dy, WGD->dz_array[k], location, WGD->n, true);
DTEHeightField.cpp:          S_above = WGD->cut_cell->calculateAreaTopBot(terrainPoints, terrainEdges, cutcell_index, WGD->dx, WGD->dy, WGD->dz_array[k], location, WGD->m, false);
DTEHeightField.cpp:        S_cut = sqrt(pow(S_behind - S_front, 2.0) + pow(S_right - S_left, 2.0) + pow(S_below - S_above, 2.0));
DTEHeightField.cpp:          ni = (S_behind - S_front) / S_cut;
DTEHeightField.cpp:          nj = (S_right - S_left) / S_cut;
DTEHeightField.cpp:          nk = (S_below - S_above) / S_cut;
DTEHeightField.cpp:          solid_V_frac += (0.0 * (-1) * S_right) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
DTEHeightField.cpp:          solid_V_frac += (WGD->dy * (1) * S_left) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
DTEHeightField.cpp:          solid_V_frac += (WGD->dx * (1) * S_front) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
DTEHeightField.cpp:          solid_V_frac += (0.0 * (-1) * S_behind) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
DTEHeightField.cpp:          solid_V_frac += (0.0 * (-1) * S_below) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
DTEHeightField.cpp:          solid_V_frac += (WGD->dz_array[k] * (1) * S_above) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
DTEHeightField.cpp:        solid_V_frac += (((terrainPoints[0][0] - location[0]) * ni * S_cut) + ((terrainPoints[0][1] - location[1]) * nj * S_cut) + ((terrainPoints[0][2] - location[2]) * nk * S_cut)) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
DTEHeightField.cpp:      WGD->terrain_volume_frac[cutcell_index] -= solid_V_frac;
DTEHeightField.cpp:      WGD->ni[cutcell_index] = ni;
DTEHeightField.cpp:      WGD->nj[cutcell_index] = nj;
DTEHeightField.cpp:      WGD->nk[cutcell_index] = nk;
DTEHeightField.cpp:      if (WGD->terrain_volume_frac[cutcell_index] < 0.0) {
DTEHeightField.cpp:        WGD->terrain_volume_frac[cutcell_index] = 0.0;
DTEHeightField.cpp:  float offset = a[2] - height;
DTEHeightField.cpp:    slopeX = (b[2] - a[2]) / (b[0] - a[0]);
DTEHeightField.cpp:    xCoord = a[0] < b[0] ? a[0] + xOff : a[0] - xOff;
DTEHeightField.cpp:    slopeY = (b[2] - a[2]) / (b[1] - a[1]);
DTEHeightField.cpp:    yCoord = a[1] < b[1] ? a[1] + yOff : a[1] - yOff;
DTEHeightField.h: * This file is part of QES-Winds
DTEHeightField.h: * GPL-3.0 License
DTEHeightField.h: * QES-Winds is free software: you can redistribute it and/or modify
DTEHeightField.h: * QES-Winds is distributed in the hope that it will be useful,
DTEHeightField.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
DTEHeightField.h:    // useful -- Pete
DTEHeightField.h:   * @param dim a 3-tuple of ints representing the dimension of
DTEHeightField.h:   * @param cellSize a 3-tuple of floats representing the size of
DTEHeightField.h:   * the id's of all cut-cells(cells that are both terrain and air).
DTEHeightField.h:    const double eps = 1.0e-6;
DTEHeightField.h:    return fabs(f1 - f2) < eps;
DTEHeightField.h:      // important to remember range is [0, n-1], so need the -1
DTEHeightField.h:      // Previous code had this -- does not seem correct
DTEHeightField.h:      // height = scanline[ abs(k-m_nYSize) * m_nXSize + j ];
DTEHeightField.h:      height = scanline[(m_nYSize - 1 - k) * (m_nXSize) + j] - adfMinMax[0];
DynamicParallelism.cu:    printf("\"%s\" at %d in %s\n\treturned %d\n-> %s\n", func, line, call, (int)e, cudaGetErrorString(e));
DynamicParallelism.cu:  int k = icell_cent / ((nx - 1) * (ny - 1));
DynamicParallelism.cu:  int j = (icell_cent - k * (nx - 1) * (ny - 1)) / (nx - 1);
DynamicParallelism.cu:  int i = icell_cent - k * (nx - 1) * (ny - 1) - j * (nx - 1);
DynamicParallelism.cu:  if ((i < nx - 1) && (j < ny - 1) && (k < nz - 1) && (i >= 0) && (j >= 0) && (k > 0)) {
DynamicParallelism.cu:    d_R[icell_cent] = (-2 * pow(alpha1, 2.0)) * (((d_e[icell_cent] * d_u0[icell_face + 1] - d_f[icell_cent] * d_u0[icell_face]) * dx) + ((d_g[icell_cent] * d_v0[icell_face + nx] - d_h[icell_cent] * d_v0[icell_face]) * dy) + (d_m[icell_cent] * d_dz_array[k] * 0.5 * (d_dz_array[k] + d_dz_array[k + 1]) * d_w0[icell_face + nx * ny] - d_n[icell_cent] * d_w0[icell_face] * d_dz_array[k] * 0.5 * (d_dz_array[k] + d_dz_array[k - 1])));
DynamicParallelism.cu:    int k = icell_cent/((nx-1)*(ny-1));
DynamicParallelism.cu:    int j = (icell_cent - k*(nx-1)*(ny-1))/(nx-1);
DynamicParallelism.cu:    int i = icell_cent - k*(nx-1)*(ny-1) - j*(nx-1);
DynamicParallelism.cu:    if ( (i > 0) && (i < nx-2) && (j > 0) && (j < ny-2) && (k < nz-2) && (k > 0) ){
DynamicParallelism.cu:            ( d_e[icell_cent] * d_lambda_old[icell_cent+1]               + d_f[icell_cent] * d_lambda_old[icell_cent-1] +
DynamicParallelism.cu:              d_g[icell_cent] * d_lambda_old[icell_cent + (nx-1)]        + d_h[icell_cent] * d_lambda_old[icell_cent - (nx-1)] +
DynamicParallelism.cu:              d_m[icell_cent] * d_lambda_old[icell_cent + (nx-1)*(ny-1)] +
DynamicParallelism.cu:              d_n[icell_cent] * d_lambda_old[icell_cent - (nx-1)*(ny-1)] - d_R[icell_cent] );    /// Jacobi formulation
DynamicParallelism.cu:  int k = icell_cent / ((nx - 1) * (ny - 1));
DynamicParallelism.cu:  int j = (icell_cent - k * (nx - 1) * (ny - 1)) / (nx - 1);
DynamicParallelism.cu:  int i = icell_cent - k * (nx - 1) * (ny - 1) - j * (nx - 1);
DynamicParallelism.cu:  if ((i > 0) && (i < nx - 2) && (j > 0) && (j < ny - 2) && (k < nz - 2) && (k > 0) && ((i + j + k) % 2) == offset) {
DynamicParallelism.cu:    d_lambda[icell_cent] = (omega / (d_e[icell_cent] + d_f[icell_cent] + d_g[icell_cent] + d_h[icell_cent] + d_m[icell_cent] + d_n[icell_cent])) * (d_e[icell_cent] * d_lambda[icell_cent + 1] + d_f[icell_cent] * d_lambda[icell_cent - 1] + d_g[icell_cent] * d_lambda[icell_cent + (nx - 1)] + d_h[icell_cent] * d_lambda[icell_cent - (nx - 1)] + d_m[icell_cent] * d_lambda[icell_cent + (nx - 1) * (ny - 1)] + d_n[icell_cent] * d_lambda[icell_cent - (nx - 1) * (ny - 1)] - d_R[icell_cent]) + (1.0 - omega) * d_lambda[icell_cent];/// SOR formulation
DynamicParallelism.cu:  if (ii < (nz - 1) * (ny - 1) * (nx - 1)) {
DynamicParallelism.cu:    d_lambda[ii] = d_lambda[ii + 1 * (nx - 1) * (ny - 1)];
DynamicParallelism.cu:  int d_size = (nx - 1) * (ny - 1) * (nz - 1);
DynamicParallelism.cu:    d_value[ii] = fabs(d_lambda[ii] - d_lambda_old[ii]);
DynamicParallelism.cu:  int j = (icell_face - k * nx * ny) / nx;
DynamicParallelism.cu:  int i = icell_face - k * nx * ny - j * nx;
DynamicParallelism.cu:  int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);/// Lineralized index for cell centered values
DynamicParallelism.cu:  if ((i >= 0) && (j >= 0) && (k >= 0) && (i < nx) && (j < ny) && (k < nz - 1)) {
DynamicParallelism.cu:  if ((i > 0) && (i < nx - 1) && (j > 0) && (j < ny - 1) && (k < nz - 2) && (k > 0)) {
DynamicParallelism.cu:    d_u[icell_face] = d_u0[icell_face] + (1 / (2 * pow(alpha1, 2.0))) * d_f[icell_cent] * dx * (d_lambda[icell_cent] - d_lambda[icell_cent - 1]);
DynamicParallelism.cu:    d_v[icell_face] = d_v0[icell_face] + (1 / (2 * pow(alpha1, 2.0))) * d_h[icell_cent] * dy * (d_lambda[icell_cent] - d_lambda[icell_cent - (nx - 1)]);
DynamicParallelism.cu:    d_w[icell_face] = d_w0[icell_face] + (1 / (2 * pow(alpha2, 2.0))) * d_n[icell_cent] * d_dz_array[k] * (d_lambda[icell_cent] - d_lambda[icell_cent - (nx - 1) * (ny - 1)]);
DynamicParallelism.cu:  if ((i >= 0) && (i < nx - 1) && (j >= 0) && (j < ny - 1) && (k < nz - 1) && (k >= 1) && ((d_icellflag[icell_cent] == 0) || (d_icellflag[icell_cent] == 2))) {
DynamicParallelism.cu:  dim3 numberOfBlocks(ceil(((nx - 1) * (ny - 1) * (nz - 1)) / (float)(BLOCKSIZE)), 1, 1);
DynamicParallelism.cu:    //  Invoke red-black SOR kernel for red nodes
DynamicParallelism.cu:    //  Invoke red-black SOR kernel for black nodes
DynamicParallelism.cu:    dim3 numberOfBlocks2(ceil(((nx - 1) * (ny - 1)) / (float)(BLOCKSIZE)), 1, 1);
DynamicParallelism.cu:              << static_cast<int>(error_id) << "\n\t-> "
DynamicParallelism.cu:              << deviceProp.clockRate * 1e-3f << " MHz ("
DynamicParallelism.cu:              << deviceProp.clockRate * 1e-6f << " GHz)" << std::endl;
DynamicParallelism.cu:  int numblocks = (WGD->numcell_cent / BLOCKSIZE) + 1;
DynamicParallelism.cu:  R.resize(WGD->numcell_cent, 0.0);
DynamicParallelism.cu:  lambda.resize(WGD->numcell_cent, 0.0);
DynamicParallelism.cu:  lambda_old.resize(WGD->numcell_cent, 0.0);
DynamicParallelism.cu:  std::vector<float> value(WGD->numcell_cent, 0.0);
DynamicParallelism.cu:  cudaMalloc((void **)&d_e, WGD->numcell_cent * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_f, WGD->numcell_cent * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_g, WGD->numcell_cent * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_h, WGD->numcell_cent * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_m, WGD->numcell_cent * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_n, WGD->numcell_cent * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_R, WGD->numcell_cent * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_lambda, WGD->numcell_cent * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_lambda_old, WGD->numcell_cent * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_icellflag, WGD->numcell_cent * sizeof(int));
DynamicParallelism.cu:  cudaMalloc((void **)&d_u0, WGD->numcell_face * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_v0, WGD->numcell_face * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_w0, WGD->numcell_face * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_value, WGD->numcell_cent * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_dz_array, (WGD->nz - 1) * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_u, WGD->numcell_face * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_v, WGD->numcell_face * sizeof(float));
DynamicParallelism.cu:  cudaMalloc((void **)&d_w, WGD->numcell_face * sizeof(float));
DynamicParallelism.cu:  long long memory_req = (10 * WGD->numcell_cent + 6 * WGD->numcell_face + numblocks + (WGD->nz - 1)) * sizeof(float) + (WGD->numcell_cent) * sizeof(int) + 2308964352;
DynamicParallelism.cu:  cudaMemcpy(d_icellflag, WGD->icellflag.data(), WGD->numcell_cent * sizeof(int), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_u0, WGD->u0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_v0, WGD->v0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_w0, WGD->w0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_R, R.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_value, value.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_e, WGD->e.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_f, WGD->f.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_g, WGD->g.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_h, WGD->h.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_m, WGD->m.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_n, WGD->n.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_dz_array, WGD->dz_array.data(), (WGD->nz - 1) * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_lambda, lambda.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  cudaMemcpy(d_lambda_old, lambda_old.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
DynamicParallelism.cu:  SOR_iteration<<<1, 1>>>(d_lambda, d_lambda_old, WGD->nx, WGD->ny, WGD->nz, omega, A, B, WGD->dx, WGD->dy, WGD->dz, d_dz_array, d_e, d_f, d_g, d_h, d_m, d_n, d_R, itermax, tol, d_value, d_bvalue, d_u0, d_v0, d_w0, alpha1, alpha2, d_u, d_v, d_w, d_icellflag);
DynamicParallelism.cu:  // cudaMemcpy (lambda.data() , d_lambda , WGD->numcell_cent * sizeof(float) , cudaMemcpyDeviceToHost);
DynamicParallelism.cu:  cudaMemcpy(WGD->u.data(), d_u, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
DynamicParallelism.cu:  cudaMemcpy(WGD->v.data(), d_v, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
DynamicParallelism.cu:  cudaMemcpy(WGD->w.data(), d_w, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
DynamicParallelism.cu:  // cudaMemcpy(R.data(),d_R,WGD->numcell_cent*sizeof(float),cudaMemcpyDeviceToHost);
DynamicParallelism.cu:  // cudaMemcpy(lambda_old.data(),d_lambda_old,WGD->numcell_cent*sizeof(float),cudaMemcpyDeviceToHost);
DynamicParallelism.cu:  std::chrono::duration<float> elapsed = finish - start;
DynamicParallelism.cu:    for (int k = 1; k < WGD->nz-2; k++)
DynamicParallelism.cu:      for (int j = 1; j < WGD->ny-2; j++)
DynamicParallelism.cu:          for (int i = 1; i < WGD->nx-2; i++)
DynamicParallelism.cu:              int icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);   /// Lineralized index for cell centered values
DynamicParallelism.cu:              lambda[icell_cent] = (omega / ( WGD->e[icell_cent] + WGD->f[icell_cent] + WGD->g[icell_cent] +
DynamicParallelism.cu:                                                WGD->h[icell_cent] + WGD->m[icell_cent] + WGD->n[icell_cent])) *
DynamicParallelism.cu:                    ( WGD->e[icell_cent] * lambda[icell_cent+1]        + WGD->f[icell_cent] * lambda[icell_cent-1] +
DynamicParallelism.cu:                      WGD->g[icell_cent] * lambda[icell_cent + (WGD->nx-1)] + WGD->h[icell_cent] * lambda[icell_cent-(WGD->nx-1)] +
DynamicParallelism.cu:                      WGD->m[icell_cent] * lambda[icell_cent+(WGD->nx-1)*(WGD->ny-1)] +
DynamicParallelism.cu:                      WGD->n[icell_cent] * lambda[icell_cent-(WGD->nx-1)*(WGD->ny-1)] - R[icell_cent] ) +
DynamicParallelism.cu:                    (1.0 - omega) * lambda[icell_cent];    /// SOR formulation
DynamicParallelism.cu:  for (int k = 0; k < WGD->nz-1; k++)
DynamicParallelism.cu:      for (int j = 0; j < WGD->ny; j++)
DynamicParallelism.cu:          for (int i = 0; i < WGD->nx; i++)
DynamicParallelism.cu:              int icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;   /// Lineralized index for cell faced values
DynamicParallelism.cu:              WGD->u[icell_face] = WGD->u0[icell_face];
DynamicParallelism.cu:              WGD->v[icell_face] = WGD->v0[icell_face];
DynamicParallelism.cu:              WGD->w[icell_face] = WGD->w0[icell_face];
DynamicParallelism.cu:  for (int k = 1; k < WGD->nz-2; k++)
DynamicParallelism.cu:      for (int j = 1; j < WGD->ny-1; j++)
DynamicParallelism.cu:          for (int i = 1; i < WGD->nx-1; i++)
DynamicParallelism.cu:              int icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);   /// Lineralized index for cell centered values
DynamicParallelism.cu:              int icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;               /// Lineralized index for cell faced values
DynamicParallelism.cu:              WGD->u[icell_face] = WGD->u0[icell_face] + (1/(2*pow(alpha1, 2.0))) *
DynamicParallelism.cu:                  WGD->f[icell_cent]*WGD->dx*(lambda[icell_cent]-lambda[icell_cent-1]);
DynamicParallelism.cu:              WGD->v[icell_face] = WGD->v0[icell_face] + (1/(2*pow(alpha1, 2.0))) *
DynamicParallelism.cu:                  WGD->h[icell_cent]*WGD->dy*(lambda[icell_cent]-lambda[icell_cent - (WGD->nx-1)]);
DynamicParallelism.cu:              WGD->w[icell_face] = WGD->w0[icell_face]+(1/(2*pow(alpha2, 2.0))) *
DynamicParallelism.cu:                  WGD->n[icell_cent]*WGD->dz_array[k]*(lambda[icell_cent]-lambda[icell_cent - (WGD->nx-1)*(WGD->ny-1)]);
DynamicParallelism.cu:  for (int k = 1; k < WGD->nz-1; k++)
DynamicParallelism.cu:      for (int j = 0; j < WGD->ny-1; j++)
DynamicParallelism.cu:          for (int i = 0; i < WGD->nx-1; i++)
DynamicParallelism.cu:              int icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);   /// Lineralized index for cell centered values
DynamicParallelism.cu:              int icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;               /// Lineralized index for cell faced values
DynamicParallelism.cu:              if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2)
DynamicParallelism.cu:                  WGD->u[icell_face] = 0;
DynamicParallelism.cu:                  WGD->u[icell_face+1] = 0;
DynamicParallelism.cu:                  WGD->v[icell_face] = 0;
DynamicParallelism.cu:                  WGD->v[icell_face+WGD->nx] = 0;
DynamicParallelism.cu:                  WGD->w[icell_face] = 0;
DynamicParallelism.cu:                  WGD->w[icell_face+WGD->nx*WGD->ny] = 0;
DynamicParallelism.h: * This file is part of QES-Winds
DynamicParallelism.h: * GPL-3.0 License
DynamicParallelism.h: * QES-Winds is free software: you can redistribute it and/or modify
DynamicParallelism.h: * QES-Winds is distributed in the hope that it will be useful,
DynamicParallelism.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Edge.cpp:    return -1;
Edge.h: * This file is part of QES-Winds
Edge.h: * GPL-3.0 License
Edge.h: * QES-Winds is free software: you can redistribute it and/or modify
Edge.h: * QES-Winds is distributed in the hope that it will be useful,
Edge.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Edge.h:   * returns -1.
Edge.h:   * @return the index of the given value, -1 if not found
ESRIShapefile.cpp: * This file is part of QES-Winds
ESRIShapefile.cpp: * GPL-3.0 License
ESRIShapefile.cpp: * QES-Winds is free software: you can redistribute it and/or modify
ESRIShapefile.cpp: * QES-Winds is distributed in the hope that it will be useful,
ESRIShapefile.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
ESRIShapefile.cpp:  maxBound = { -1.0 * std::numeric_limits<float>::max(), -1.0 * std::numeric_limits<float>::max() };
ESRIShapefile.cpp:  maxBound = { -1.0 * std::numeric_limits<float>::max(), -1.0 * std::numeric_limits<float>::max() };
ESRIShapefile.cpp:  maxBound = { -1.0 * std::numeric_limits<float>::max(), -1.0 * std::numeric_limits<float>::max() };
ESRIShapefile.cpp:  maxBound = { -1.0 * std::numeric_limits<float>::max(), -1.0 * std::numeric_limits<float>::max() };
ESRIShapefile.cpp:  // From -- http://www.gdal.org/gdal_tutorial.html
ESRIShapefile.cpp:    std::cerr << "ESRIShapefile -- could not open data file: " << m_filename << std::endl;
ESRIShapefile.cpp:           m_poDS->GetDriver()->GetDescription(),
ESRIShapefile.cpp:           m_poDS->GetDriver()->GetMetadataItem(GDAL_DMD_LONGNAME));
ESRIShapefile.cpp:    m_SpRef = (OGRSpatialReference *)m_poDS->GetSpatialRef();
ESRIShapefile.cpp:      m_SpRef->dumpReadable();
ESRIShapefile.cpp:  // From -- http://www.gdal.org/gdal_tutorial.html
ESRIShapefile.cpp:    std::cerr << "ESRIShapefile -- could not open data file: " << m_filename << std::endl;
ESRIShapefile.cpp:         m_poDS->GetDriver()->GetDescription(),
ESRIShapefile.cpp:         m_poDS->GetDriver()->GetMetadataItem(GDAL_DMD_LONGNAME));
ESRIShapefile.cpp:  // poLayer = poDS->GetLayerByName( "point" );
ESRIShapefile.cpp:  int numLayers = m_poDS->GetLayerCount();
ESRIShapefile.cpp:    OGRLayer *poLayer = m_poDS->GetLayer(i);
ESRIShapefile.cpp:    std::cout << "\tLayer: " << poLayer->GetName() << std::endl;
ESRIShapefile.cpp:  // just what I set my layer name too -- may need to specify this
ESRIShapefile.cpp:  OGRLayer *buildingLayer = m_poDS->GetLayerByName(m_layerName.c_str());
ESRIShapefile.cpp:    std::cerr << "ESRIShapefile -- no layer" << std::endl;
ESRIShapefile.cpp:  OGRFeatureDefn *poFDefn = buildingLayer->GetLayerDefn();
ESRIShapefile.cpp:  while ((feature = buildingLayer->GetNextFeature()) != nullptr) {
ESRIShapefile.cpp:    if (poFDefn->GetFieldCount() > 1) {
ESRIShapefile.cpp:      for (int idxField = 0; idxField < poFDefn->GetFieldCount(); idxField++) {
ESRIShapefile.cpp:        OGRFieldDefn *oField = poFDefn->GetFieldDefn(idxField);
ESRIShapefile.cpp:        // std::cout << "Field Name: " << oField->GetNameRef() << ", Value: ";
ESRIShapefile.cpp:        if (strcmp(oField->GetNameRef(), "H") == 0) {
ESRIShapefile.cpp:          switch (oField->GetType()) {
ESRIShapefile.cpp:            // printf( "%d,", feature->GetFieldAsInteger( idxField ) );
ESRIShapefile.cpp:            building_height.push_back(feature->GetFieldAsInteger(idxField) * heightFactor);
ESRIShapefile.cpp:            // printf( CPL_FRMT_GIB ",", feature->GetFieldAsInteger64( idxField ));
ESRIShapefile.cpp:            building_height.push_back(feature->GetFieldAsInteger(idxField) * heightFactor);
ESRIShapefile.cpp:            // printf( "%.3f,", feature->GetFieldAsDouble( idxField ) );
ESRIShapefile.cpp:            building_height.push_back(feature->GetFieldAsDouble(idxField) * heightFactor);
ESRIShapefile.cpp:            // printf( "%s,", feature->GetFieldAsString( idxField ) );
ESRIShapefile.cpp:            // printf( "%s,", feature->GetFieldAsString( idxField ) );
ESRIShapefile.cpp:      OGRFieldDefn *oField = poFDefn->GetFieldDefn(idxField);
ESRIShapefile.cpp:      // std::cout << "Field Name: " << oField->GetNameRef() << ", Value: ";
ESRIShapefile.cpp:      switch (oField->GetType()) {
ESRIShapefile.cpp:        // printf( "%d,", feature->GetFieldAsInteger( idxField ) );
ESRIShapefile.cpp:        building_height.push_back(feature->GetFieldAsInteger(idxField) * heightFactor);
ESRIShapefile.cpp:        // printf( CPL_FRMT_GIB ",", feature->GetFieldAsInteger64( idxField ));
ESRIShapefile.cpp:        building_height.push_back(feature->GetFieldAsInteger(idxField) * heightFactor);
ESRIShapefile.cpp:        // printf( "%.3f,", feature->GetFieldAsDouble( idxField ) );
ESRIShapefile.cpp:        building_height.push_back(feature->GetFieldAsDouble(idxField) * heightFactor);
ESRIShapefile.cpp:        // printf( "%s,", feature->GetFieldAsString( idxField ) );
ESRIShapefile.cpp:        // printf( "%s,", feature->GetFieldAsString( idxField ) );
ESRIShapefile.cpp:    poGeometry = feature->GetGeometryRef();
ESRIShapefile.cpp:        && wkbFlatten(poGeometry->getGeometryType()) == wkbPoint) {
ESRIShapefile.cpp:      OGRPoint *poPoint = poGeometry->toPoint();
ESRIShapefile.cpp:      printf("%.3f,%3.f\n", poPoint->getX(), poPoint->getY());
ESRIShapefile.cpp:             && wkbFlatten(poGeometry->getGeometryType()) == wkbPolygon) {
ESRIShapefile.cpp:      pLinearRing = ((OGRPolygon *)poGeometry)->getExteriorRing();
ESRIShapefile.cpp:      int vertexCount = pLinearRing->getNumPoints();
ESRIShapefile.cpp:        double x = pLinearRing->getX(vidx);
ESRIShapefile.cpp:        double y = pLinearRing->getY(vidx);
ESRIShapefile.cpp:  std::cout << "Domain Size: " << (int)ceil(maxBound[0] - minBound[0]) << " X " << (int)ceil(maxBound[1] - minBound[1]) << std::endl;
ESRIShapefile.cpp:  // poLayer = poDS->GetLayerByName( "point" );
ESRIShapefile.cpp:  int numLayers = m_poDS->GetLayerCount();
ESRIShapefile.cpp:    OGRLayer *poLayer = m_poDS->GetLayer(i);
ESRIShapefile.cpp:    std::cout << "\tLayer Name: " << poLayer->GetName() << std::endl;
ESRIShapefile.cpp:  // just what I set my layer name too -- may need to specify this
ESRIShapefile.cpp:  OGRLayer *buildingLayer = m_poDS->GetLayerByName(m_layerName.c_str());
ESRIShapefile.cpp:    std::cerr << "[ERROR]\t ESRIShapefile -- no layer" << std::endl;
ESRIShapefile.cpp:  OGRFeatureDefn *poFDefn = buildingLayer->GetLayerDefn();
ESRIShapefile.cpp:  std::cout << "\tNumber of Features: " << buildingLayer->GetFeatureCount() << std::endl;
ESRIShapefile.cpp:  if (buildingLayer->GetFeatureCount() == 0) {
ESRIShapefile.cpp:    std::cerr << "[ERROR]\t ESRIShapefile -- no feature" << std::endl;
ESRIShapefile.cpp:  feature = buildingLayer->GetFeature(0);
ESRIShapefile.cpp:  std::cout << "\tNumber of Fields: " << feature->GetFieldCount() << std::endl;
ESRIShapefile.cpp:  if (feature->GetFieldCount() == 0) {
ESRIShapefile.cpp:    std::cerr << "[ERROR]\t ESRIShapefile -- no field" << std::endl;
ESRIShapefile.cpp:  for (int idxField = 0; idxField < poFDefn->GetFieldCount(); ++idxField) {
ESRIShapefile.cpp:    OGRFieldDefn *oField = poFDefn->GetFieldDefn(idxField);
ESRIShapefile.cpp:    std::cout << " " << oField->GetNameRef();
ESRIShapefile.cpp:    switch (oField->GetType()) {
ESRIShapefile.cpp:  while ((feature = buildingLayer->GetNextFeature()) != nullptr) {
ESRIShapefile.cpp:      OGRFieldDefn *oField = poFDefn->GetFieldDefn(idxField);
ESRIShapefile.cpp:      std::string fn(oField->GetNameRef());
ESRIShapefile.cpp:      switch (oField->GetType()) {
ESRIShapefile.cpp:        features[fn].push_back(feature->GetFieldAsInteger(idxField));
ESRIShapefile.cpp:        features[fn].push_back(feature->GetFieldAsInteger64(idxField));
ESRIShapefile.cpp:        features[fn].push_back(feature->GetFieldAsDouble(idxField));
ESRIShapefile.cpp:        std::cerr << "[ERROR]\t ESRIShapefile -- incompatible field type" << std::endl;
ESRIShapefile.cpp:    poGeometry = feature->GetGeometryRef();
ESRIShapefile.cpp:        && wkbFlatten(poGeometry->getGeometryType()) == wkbPoint) {
ESRIShapefile.cpp:      OGRPoint *poPoint = poGeometry->toPoint();
ESRIShapefile.cpp:      printf("%.3f,%3.f\n", poPoint->getX(), poPoint->getY());
ESRIShapefile.cpp:             && wkbFlatten(poGeometry->getGeometryType()) == wkbPolygon) {
ESRIShapefile.cpp:      pLinearRing = ((OGRPolygon *)poGeometry)->getExteriorRing();
ESRIShapefile.cpp:      int vertexCount = pLinearRing->getNumPoints();
ESRIShapefile.cpp:        double x = pLinearRing->getX(vidx);
ESRIShapefile.cpp:        double y = pLinearRing->getY(vidx);
ESRIShapefile.cpp:  std::cout << "\tDomain Size: " << (int)ceil(maxBound[0] - minBound[0]) << " X " << (int)ceil(maxBound[1] - minBound[1]) << std::endl;
ESRIShapefile.h: * This file is part of QES-Winds
ESRIShapefile.h: * GPL-3.0 License
ESRIShapefile.h: * QES-Winds is free software: you can redistribute it and/or modify
ESRIShapefile.h: * QES-Winds is distributed in the hope that it will be useful,
ESRIShapefile.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
ESRIShapefile.h:    dim[0] = (int)ceil(maxBound[0] - minBound[0]);
ESRIShapefile.h:    dim[1] = (int)ceil(maxBound[1] - minBound[1]);
FileOptions.h: * This file is part of QES-Winds
FileOptions.h: * GPL-3.0 License
FileOptions.h: * QES-Winds is free software: you can redistribute it and/or modify
FileOptions.h: * QES-Winds is distributed in the hope that it will be useful,
FileOptions.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
GlobalMemory.cu: * This file is part of QES-Winds
GlobalMemory.cu: * GPL-3.0 License
GlobalMemory.cu: * QES-Winds is free software: you can redistribute it and/or modify
GlobalMemory.cu: * QES-Winds is distributed in the hope that it will be useful,
GlobalMemory.cu: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
GlobalMemory.cu:    printf("\"%s\" at %d in %s\n\treturned %d\n-> %s\n", func, line, call, (int)e, cudaGetErrorString(e));
GlobalMemory.cu:  int k = icell_cent / ((nx - 1) * (ny - 1));
GlobalMemory.cu:  int j = (icell_cent - k * (nx - 1) * (ny - 1)) / (nx - 1);
GlobalMemory.cu:  int i = icell_cent - k * (nx - 1) * (ny - 1) - j * (nx - 1);
GlobalMemory.cu:  if ((i < nx - 1) && (j < ny - 1) && (k < nz - 1) && (i >= 0) && (j >= 0) && (k > 0)) {
GlobalMemory.cu:    d_R[icell_cent] = (-2 * pow(alpha1, 2.0)) * (((d_e[icell_cent] * d_u0[icell_face + 1] - d_f[icell_cent] * d_u0[icell_face]) * dx) + ((d_g[icell_cent] * d_v0[icell_face + nx] - d_h[icell_cent] * d_v0[icell_face]) * dy) + (d_m[icell_cent] * d_dz_array[k] * 0.5 * (d_dz_array[k] + d_dz_array[k + 1]) * d_w0[icell_face + nx * ny] - d_n[icell_cent] * d_w0[icell_face] * d_dz_array[k] * 0.5 * (d_dz_array[k] + d_dz_array[k - 1])));
GlobalMemory.cu:  int k = icell_cent / ((nx - 1) * (ny - 1));
GlobalMemory.cu:  int j = (icell_cent - k * (nx - 1) * (ny - 1)) / (nx - 1);
GlobalMemory.cu:  int i = icell_cent - k * (nx - 1) * (ny - 1) - j * (nx - 1);
GlobalMemory.cu:  if ((i > 0) && (i < nx - 2) && (j > 0) && (j < ny - 2) && (k < nz - 2) && (k > 0) && ((i + j + k) % 2) == offset) {
GlobalMemory.cu:    d_lambda[icell_cent] = (omega / (d_e[icell_cent] + d_f[icell_cent] + d_g[icell_cent] + d_h[icell_cent] + d_m[icell_cent] + d_n[icell_cent])) * (d_e[icell_cent] * d_lambda[icell_cent + 1] + d_f[icell_cent] * d_lambda[icell_cent - 1] + d_g[icell_cent] * d_lambda[icell_cent + (nx - 1)] + d_h[icell_cent] * d_lambda[icell_cent - (nx - 1)] + d_m[icell_cent] * d_lambda[icell_cent + (nx - 1) * (ny - 1)] + d_n[icell_cent] * d_lambda[icell_cent - (nx - 1) * (ny - 1)] - d_R[icell_cent]) + (1.0 - omega) * d_lambda[icell_cent];// SOR formulation
GlobalMemory.cu:  if (ii < (nz - 1) * (ny - 1) * (nx - 1)) {
GlobalMemory.cu:    d_lambda[ii] = d_lambda[ii + 1 * (nx - 1) * (ny - 1)];
GlobalMemory.cu:  int d_size = (nx - 1) * (ny - 1) * (nz - 1);
GlobalMemory.cu:    d_value[ii] = fabs(d_lambda[ii] - d_lambda_old[ii]);
GlobalMemory.cu:  int j = (icell_face - k * nx * ny) / nx;
GlobalMemory.cu:  int i = icell_face - k * nx * ny - j * nx;
GlobalMemory.cu:  int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);// Lineralized index for cell centered values
GlobalMemory.cu:  if ((i > 0) && (i < nx - 1) && (j > 0) && (j < ny - 1) && (k < nz - 2) && (k > 0)) {
GlobalMemory.cu:    d_u[icell_face] = d_u[icell_face] + (1 / (2 * pow(alpha1, 2.0))) * d_f[icell_cent] * dx * (d_lambda[icell_cent] - d_lambda[icell_cent - 1]);
GlobalMemory.cu:    d_v[icell_face] = d_v[icell_face] + (1 / (2 * pow(alpha1, 2.0))) * d_h[icell_cent] * dy * (d_lambda[icell_cent] - d_lambda[icell_cent - (nx - 1)]);
GlobalMemory.cu:    d_w[icell_face] = d_w[icell_face] + (1 / (2 * pow(alpha2, 2.0))) * d_n[icell_cent] * d_dz_array[k] * (d_lambda[icell_cent] - d_lambda[icell_cent - (nx - 1) * (ny - 1)]);
GlobalMemory.cu:  if ((i >= 0) && (i < nx - 1) && (j >= 0) && (j < ny - 1) && (k < nz - 1) && (k >= 1) && ((d_icellflag[icell_cent] == 0) || (d_icellflag[icell_cent] == 2))) {
GlobalMemory.cu:  int numblocks = (WGD->numcell_cent / BLOCKSIZE) + 1;
GlobalMemory.cu:  R.resize(WGD->numcell_cent, 0.0);
GlobalMemory.cu:  lambda.resize(WGD->numcell_cent, 0.0);
GlobalMemory.cu:  lambda_old.resize(WGD->numcell_cent, 0.0);
GlobalMemory.cu:  std::vector<float> value(WGD->numcell_cent, 0.0);
GlobalMemory.cu:  cudaMalloc((void **)&d_e, WGD->numcell_cent * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_f, WGD->numcell_cent * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_g, WGD->numcell_cent * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_h, WGD->numcell_cent * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_m, WGD->numcell_cent * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_n, WGD->numcell_cent * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_lambda, WGD->numcell_cent * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_lambda_old, WGD->numcell_cent * sizeof(float));
GlobalMemory.cu:  /*cudaMalloc((void **)&d_u0, WGD->numcell_face * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_v0, WGD->numcell_face * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_w0, WGD->numcell_face * sizeof(float));*/
GlobalMemory.cu:  cudaMalloc((void **)&d_dz_array, (WGD->nz - 1) * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_R, WGD->numcell_cent * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_value, WGD->numcell_cent * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_icellflag, WGD->numcell_cent * sizeof(int));
GlobalMemory.cu:  cudaMalloc((void **)&d_u, WGD->numcell_face * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_v, WGD->numcell_face * sizeof(float));
GlobalMemory.cu:  cudaMalloc((void **)&d_w, WGD->numcell_face * sizeof(float));
GlobalMemory.cu:  /*cudaMemcpy(d_u0, WGD->u0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_v0, WGD->v0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_w0, WGD->w0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);*/
GlobalMemory.cu:  cudaMemcpy(d_u, WGD->u0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_v, WGD->v0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_w, WGD->w0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_R, R.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_e, WGD->e.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_f, WGD->f.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_g, WGD->g.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_h, WGD->h.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_m, WGD->m.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_n, WGD->n.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_dz_array, WGD->dz_array.data(), (WGD->nz - 1) * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_lambda_old, lambda_old.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_value, value.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_lambda, lambda.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
GlobalMemory.cu:  cudaMemcpy(d_icellflag, WGD->icellflag.data(), WGD->numcell_cent * sizeof(int), cudaMemcpyHostToDevice);
GlobalMemory.cu:  dim3 numberOfBlocks(ceil(((WGD->nx - 1) * (WGD->ny - 1) * (WGD->nz - 1)) / (float)(BLOCKSIZE)), 1, 1);
GlobalMemory.cu:  divergenceGlobal<<<numberOfBlocks, numberOfThreadsPerBlock>>>(d_u, d_v, d_w, d_R, d_e, d_f, d_g, d_h, d_m, d_n, alpha1, WGD->nx, WGD->ny, WGD->nz, WGD->dx, WGD->dy, d_dz_array);
GlobalMemory.cu:    /*for (int k = 0; k < WGD->nz-1; k++)
GlobalMemory.cu:      for (int j = 0; j < WGD->ny-1; j++)
GlobalMemory.cu:        for (int i = 0; i < WGD->nx-1; i++)
GlobalMemory.cu:          int ii = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);   // Lineralize the vectors (make it 1D)
GlobalMemory.cu:    saveLambdaGlobal<<<numberOfBlocks, numberOfThreadsPerBlock>>>(d_lambda, d_lambda_old, WGD->nx, WGD->ny, WGD->nz);
GlobalMemory.cu:    // cudaMemcpy(d_lambda , lambda.data() , WGD->numcell_cent * sizeof(float) , cudaMemcpyHostToDevice);
GlobalMemory.cu:    SOR_RB_Global<<<numberOfBlocks, numberOfThreadsPerBlock>>>(d_lambda, WGD->nx, WGD->ny, WGD->nz, omega, A, B, d_e, d_f, d_g, d_h, d_m, d_n, d_R, offset);
GlobalMemory.cu:    SOR_RB_Global<<<numberOfBlocks, numberOfThreadsPerBlock>>>(d_lambda, WGD->nx, WGD->ny, WGD->nz, omega, A, B, d_e, d_f, d_g, d_h, d_m, d_n, d_R, offset);
GlobalMemory.cu:    // cudaMemcpy (lambda.data() , d_lambda , WGD->numcell_cent * sizeof(float) , cudaMemcpyDeviceToHost);
GlobalMemory.cu:    for (int j = 0; j < WGD->ny; j++)
GlobalMemory.cu:      for (int i = 0; i < WGD->nx; i++)
GlobalMemory.cu:        int ii = i + j*(WGD->nx-1);          // Lineralize the vectors (make it 1D)
GlobalMemory.cu:        lambda[ii] = lambda[ii + (WGD->nx-1)*(WGD->ny-1)];
GlobalMemory.cu:    dim3 numberOfBlocks2(ceil(((WGD->nx - 1) * (WGD->ny - 1)) / (float)(BLOCKSIZE)), 1, 1);
GlobalMemory.cu:    applyNeumannBCGlobal<<<numberOfBlocks2, numberOfThreadsPerBlock>>>(d_lambda, WGD->nx, WGD->ny);
GlobalMemory.cu:    for (int k = 0; k < WGD->nz-1; k++)
GlobalMemory.cu:        for (int j = 0; j < WGD->ny-1; j++)
GlobalMemory.cu:            for (int i = 0; i < WGD->nx-1; i++)
GlobalMemory.cu:                int icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);   // Lineralized index for cell centered values
GlobalMemory.cu:                error = fabs(lambda[icell_cent] - lambda_old[icell_cent]);
GlobalMemory.cu:    calculateErrorGlobal<<<numberOfBlocks, numberOfThreadsPerBlock>>>(d_lambda, d_lambda_old, WGD->nx, WGD->ny, WGD->nz, d_value, d_bvalue, d_error);
GlobalMemory.cu:  dim3 numberOfBlocks3(ceil((WGD->nx * WGD->ny * WGD->nz) / (float)(BLOCKSIZE)), 1, 1);
GlobalMemory.cu:  finalVelocityGlobal<<<numberOfBlocks3, numberOfThreadsPerBlock>>>(d_lambda, d_u, d_v, d_w, d_icellflag, d_f, d_h, d_n, alpha1, alpha2, WGD->dx, WGD->dy, WGD->dz, d_dz_array, WGD->nx, WGD->ny, WGD->nz);
GlobalMemory.cu:  cudaMemcpy(WGD->u.data(), d_u, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
GlobalMemory.cu:  cudaMemcpy(WGD->v.data(), d_v, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
GlobalMemory.cu:  cudaMemcpy(WGD->w.data(), d_w, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
GlobalMemory.cu:  std::chrono::duration<float> elapsed = finish - start;
GlobalMemory.h: * This file is part of QES-Winds
GlobalMemory.h: * GPL-3.0 License
GlobalMemory.h: * QES-Winds is free software: you can redistribute it and/or modify
GlobalMemory.h: * QES-Winds is distributed in the hope that it will be useful,
GlobalMemory.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
handleWINDSArgs.cpp: * This file is part of QES-Winds
handleWINDSArgs.cpp: * GPL-3.0 License
handleWINDSArgs.cpp: * QES-Winds is free software: you can redistribute it and/or modify
handleWINDSArgs.cpp: * QES-Winds is distributed in the hope that it will be useful,
handleWINDSArgs.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
handleWINDSArgs.cpp:    // -> subject to change
handleWINDSArgs.cpp:    std::cout << "No output basename set -> output turned off " << std::endl;
handleWINDSArgs.h: * This file is part of QES-Winds
handleWINDSArgs.h: * GPL-3.0 License
handleWINDSArgs.h: * QES-Winds is free software: you can redistribute it and/or modify
handleWINDSArgs.h: * QES-Winds is distributed in the hope that it will be useful,
handleWINDSArgs.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
handleWINDSArgs.h:  std::string netCDFFileVisu = ""; /**< netCDFFile for standard cell-center visualization file */
HitRecord.cpp: * This file is part of QES-Winds
HitRecord.cpp: * GPL-3.0 License
HitRecord.cpp: * QES-Winds is free software: you can redistribute it and/or modify
HitRecord.cpp: * QES-Winds is distributed in the hope that it will be useful,
HitRecord.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
HitRecord.cpp:  this->hitNode = hitNode;
HitRecord.cpp:  this->isHit = isHit;
HitRecord.cpp:  hitDist = -1 * (std::numeric_limits<float>::infinity());
HitRecord.cpp:  this->hitNode = hitNode;
HitRecord.cpp:  this->isHit = isHit;
HitRecord.cpp:  this->hitDist = hitDist;
HitRecord.h: * This file is part of QES-Winds
HitRecord.h: * GPL-3.0 License
HitRecord.h: * QES-Winds is free software: you can redistribute it and/or modify
HitRecord.h: * QES-Winds is distributed in the hope that it will be useful,
HitRecord.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
LocalMixing.cpp: * This file is part of QES-Winds
LocalMixing.cpp: * GPL-3.0 License
LocalMixing.cpp: * QES-Winds is free software: you can redistribute it and/or modify
LocalMixing.cpp: * QES-Winds is distributed in the hope that it will be useful,
LocalMixing.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
LocalMixing.cpp:  mixLengthOut = new NetCDFOutput(WID->turbParams->filename);
LocalMixing.cpp:  NcDim NcDim_x = mixLengthOut->addDimension("x", WGD->nx - 1);
LocalMixing.cpp:  NcDim NcDim_y = mixLengthOut->addDimension("y", WGD->ny - 1);
LocalMixing.cpp:  NcDim NcDim_z = mixLengthOut->addDimension("z", WGD->nz - 1);
LocalMixing.cpp:  vector_size = { static_cast<unsigned long>(WGD->nz - 1),
LocalMixing.cpp:                  static_cast<unsigned long>(WGD->ny - 1),
LocalMixing.cpp:                  static_cast<unsigned long>(WGD->nx - 1) };
LocalMixing.cpp:  mixLengthOut->addField(WID->turbParams->varname, "m", "distance to nearest object", { NcDim_z, NcDim_y, NcDim_x }, ncFloat);
LocalMixing.cpp:  mixLengthOut->saveField2D(WID->turbParams->varname, vector_index, vector_size, WGD->mixingLengths);
LocalMixingDefault.cpp: * This file is part of QES-Winds
LocalMixingDefault.cpp: * GPL-3.0 License
LocalMixingDefault.cpp: * QES-Winds is free software: you can redistribute it and/or modify
LocalMixingDefault.cpp: * QES-Winds is distributed in the hope that it will be useful,
LocalMixingDefault.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
LocalMixingDefault.cpp:  int nx = WGD->nx;
LocalMixingDefault.cpp:  int ny = WGD->ny;
LocalMixingDefault.cpp:  int nz = WGD->nz;
LocalMixingDefault.cpp:  // z cell-center
LocalMixingDefault.cpp:  z_cc.resize(nz - 1, 0);
LocalMixingDefault.cpp:  z_cc = WGD->z;
LocalMixingDefault.cpp:  for (int i = 0; i < nx - 1; i++) {
LocalMixingDefault.cpp:    for (int j = 0; j < ny - 1; j++) {
LocalMixingDefault.cpp:      for (int k = 1; k < nz - 2; k++) {
LocalMixingDefault.cpp:        int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
LocalMixingDefault.cpp:        if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
LocalMixingDefault.cpp:          WGD->mixingLengths[icell_cent] = z_cc[k] - WGD->terrain[i + j * (nx - 1)];
LocalMixingDefault.cpp:        if (WGD->mixingLengths[icell_cent] < 0.0) {
LocalMixingDefault.cpp:          WGD->mixingLengths[icell_cent] = 0.0;
LocalMixingDefault.h: * This file is part of QES-Winds
LocalMixingDefault.h: * GPL-3.0 License
LocalMixingDefault.h: * QES-Winds is free software: you can redistribute it and/or modify
LocalMixingDefault.h: * QES-Winds is distributed in the hope that it will be useful,
LocalMixingDefault.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
LocalMixing.h: * This file is part of QES-Winds
LocalMixing.h: * GPL-3.0 License
LocalMixing.h: * QES-Winds is free software: you can redistribute it and/or modify
LocalMixing.h: * QES-Winds is distributed in the hope that it will be useful,
LocalMixing.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
LocalMixingNetCDF.cpp: * This file is part of QES-Winds
LocalMixingNetCDF.cpp: * GPL-3.0 License
LocalMixingNetCDF.cpp: * QES-Winds is free software: you can redistribute it and/or modify
LocalMixingNetCDF.cpp: * QES-Winds is distributed in the hope that it will be useful,
LocalMixingNetCDF.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
LocalMixingNetCDF.cpp:  mixLengthInput = new NetCDFInput(WID->turbParams->filename);
LocalMixingNetCDF.cpp:  mixLengthInput->getDimensionSize("x", nx_f);
LocalMixingNetCDF.cpp:  mixLengthInput->getDimensionSize("y", ny_f);
LocalMixingNetCDF.cpp:  mixLengthInput->getDimensionSize("z", nz_f);
LocalMixingNetCDF.cpp:  if (nx_f != WGD->nx - 1 || ny_f != WGD->ny - 1 || nz_f != WGD->nz - 1) {
LocalMixingNetCDF.cpp:    std::cout << "[ERROR] \t domain size error in " << WID->turbParams->filename << std::endl;
LocalMixingNetCDF.cpp:  mixLengthInput->getVariable(WID->turbParams->varname, NcVar_mixlength);
LocalMixingNetCDF.cpp:    mixLengthInput->getVariableData(WID->turbParams->varname, start, count, WGD->mixingLengths);
LocalMixingNetCDF.cpp:    std::cout << "[ERROR] \t no field " << WID->turbParams->varname << " in "
LocalMixingNetCDF.cpp:              << WID->turbParams->filename << std::endl;
LocalMixingNetCDF.h: * This file is part of QES-Winds
LocalMixingNetCDF.h: * GPL-3.0 License
LocalMixingNetCDF.h: * QES-Winds is free software: you can redistribute it and/or modify
LocalMixingNetCDF.h: * QES-Winds is distributed in the hope that it will be useful,
LocalMixingNetCDF.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
LocalMixingOptix.cpp: * This file is part of QES-Winds
LocalMixingOptix.cpp: * GPL-3.0 License
LocalMixingOptix.cpp: * QES-Winds is free software: you can redistribute it and/or modify
LocalMixingOptix.cpp: * QES-Winds is distributed in the hope that it will be useful,
LocalMixingOptix.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
LocalMixingOptix.cpp:  int nx = WGD->nx;
LocalMixingOptix.cpp:  int ny = WGD->ny;
LocalMixingOptix.cpp:  int nz = WGD->nz;
LocalMixingOptix.cpp:  float dx = WGD->dx;
LocalMixingOptix.cpp:  float dy = WGD->dy;
LocalMixingOptix.cpp:  float dz = WGD->dz;
LocalMixingOptix.cpp:  if (WGD->allBuildingsV.size() > 0) {
LocalMixingOptix.cpp:    // WID->buildings->buildings.size(); bIdx++)
LocalMixingOptix.cpp:    for (auto bIdx = 0u; bIdx < WGD->allBuildingsV.size(); bIdx++) {
LocalMixingOptix.cpp:      for (auto pIdx = 0u; pIdx < WGD->allBuildingsV[bIdx]->polygonVertices.size(); pIdx++) {
LocalMixingOptix.cpp:        // Building has base_height -- should be the "ground"
LocalMixingOptix.cpp:        if (pIdx == WGD->allBuildingsV[bIdx]->polygonVertices.size() - 1) {// wrap around case for last vertices
LocalMixingOptix.cpp:          Triangle *tri1 = new Triangle(Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[pIdx].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[pIdx].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height),
LocalMixingOptix.cpp:                                        Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[0].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[0].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height),
LocalMixingOptix.cpp:                                        Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[0].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[0].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height + WGD->allBuildingsV[bIdx]->H));
LocalMixingOptix.cpp:          Triangle *tri2 = new Triangle(Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[pIdx].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[pIdx].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height + WGD->allBuildingsV[bIdx]->H),
LocalMixingOptix.cpp:                                        Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[0].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[0].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height + WGD->allBuildingsV[bIdx]->H),
LocalMixingOptix.cpp:                                        Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[0].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[0].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height));
LocalMixingOptix.cpp:          Triangle *tri1 = new Triangle(Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[pIdx].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[pIdx].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height),
LocalMixingOptix.cpp:                                        Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[pIdx + 1].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[pIdx + 1].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height),
LocalMixingOptix.cpp:                                        Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[pIdx + 1].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[pIdx + 1].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height + WGD->allBuildingsV[bIdx]->H));
LocalMixingOptix.cpp:          Triangle *tri2 = new Triangle(Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[pIdx].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[pIdx].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height + WGD->allBuildingsV[bIdx]->H),
LocalMixingOptix.cpp:                                        Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[pIdx + 1].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[pIdx + 1].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height + WGD->allBuildingsV[bIdx]->H),
LocalMixingOptix.cpp:                                        Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[pIdx + 1].x_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->polygonVertices[pIdx + 1].y_poly,
LocalMixingOptix.cpp:                                                WGD->allBuildingsV[bIdx]->base_height));
LocalMixingOptix.cpp:      Vector3 baseRoofPt(WGD->allBuildingsV[bIdx]->polygonVertices[0].x_poly,
LocalMixingOptix.cpp:                         WGD->allBuildingsV[bIdx]->polygonVertices[0].y_poly,
LocalMixingOptix.cpp:                         WGD->allBuildingsV[bIdx]->height_eff);
LocalMixingOptix.cpp:      for (auto pIdx = 1u; pIdx < WGD->allBuildingsV[bIdx]->polygonVertices.size() - 1; pIdx++) {
LocalMixingOptix.cpp:                                         Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[pIdx].x_poly,
LocalMixingOptix.cpp:                                                 WGD->allBuildingsV[bIdx]->polygonVertices[pIdx].y_poly,
LocalMixingOptix.cpp:                                                 WGD->allBuildingsV[bIdx]->height_eff),
LocalMixingOptix.cpp:                                         Vector3(WGD->allBuildingsV[bIdx]->polygonVertices[pIdx + 1].x_poly,
LocalMixingOptix.cpp:                                                 WGD->allBuildingsV[bIdx]->polygonVertices[pIdx + 1].y_poly,
LocalMixingOptix.cpp:                                                 WGD->allBuildingsV[bIdx]->height_eff));
LocalMixingOptix.cpp:  if (WID->simParams->DTE_heightField == nullptr) {
LocalMixingOptix.cpp:  if (WID->simParams->DTE_heightField) {
LocalMixingOptix.cpp:    allTriangles.resize(WID->simParams->DTE_heightField->getTris().size());
LocalMixingOptix.cpp:    // std::copy(WID->simParams->DTE_heightField->getTris().begin(), WID->simParams->DTE_heightField->getTris().end(), allTriangles.begin());
LocalMixingOptix.cpp:    for (int i = 0; i < WID->simParams->DTE_heightField->getTris().size(); i++) {
LocalMixingOptix.cpp:      allTriangles[i] = WID->simParams->DTE_heightField->getTris()[i];
LocalMixingOptix.cpp:  // OptixRayTrace optixRayTracer(WID->simParams->DTE_mesh->getTris());
LocalMixingOptix.cpp:  std::cout << "--------------------Before OptiX calls-------------------------" << std::endl;
LocalMixingOptix.cpp:  OptixRayTrace optixRayTracer(m_mixingLengthMesh->getTris());
LocalMixingOptix.cpp:  optixRayTracer.calculateMixingLength(WID->turbParams->mlSamplesPerAirCell, nx, ny, nz, dx, dy, dz, WGD->icellflag, WGD->mixingLengths);
LocalMixingOptix.cpp:  std::cout << "--------------------End of OptiX calls-------------------------" << std::endl;
LocalMixingOptix.cpp:  if (WID->turbParams->save2file) {
LocalMixingOptix.h: * This file is part of QES-Winds
LocalMixingOptix.h: * GPL-3.0 License
LocalMixingOptix.h: * QES-Winds is free software: you can redistribute it and/or modify
LocalMixingOptix.h: * QES-Winds is distributed in the hope that it will be useful,
LocalMixingOptix.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
LocalMixingSerial.cpp: * This file is part of QES-Winds
LocalMixingSerial.cpp: * GPL-3.0 License
LocalMixingSerial.cpp: * QES-Winds is free software: you can redistribute it and/or modify
LocalMixingSerial.cpp: * QES-Winds is distributed in the hope that it will be useful,
LocalMixingSerial.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
LocalMixingSerial.cpp:  int nx = WGD->nx;
LocalMixingSerial.cpp:  int ny = WGD->ny;
LocalMixingSerial.cpp:  int nz = WGD->nz;
LocalMixingSerial.cpp:  float dz = WGD->dz;
LocalMixingSerial.cpp:  float dy = WGD->dy;
LocalMixingSerial.cpp:  float dx = WGD->dx;
LocalMixingSerial.cpp:  // x-grid (face-center & cell-center)
LocalMixingSerial.cpp:  x_cc.resize(nx - 1, 0);
LocalMixingSerial.cpp:  // y-grid (face-center & cell-center)
LocalMixingSerial.cpp:  y_cc.resize(ny - 1, 0);
LocalMixingSerial.cpp:  // z-grid (face-center & cell-center)
LocalMixingSerial.cpp:  z_cc.resize(nz - 1, 0);
LocalMixingSerial.cpp:  // x cell-center
LocalMixingSerial.cpp:  x_cc = WGD->x;
LocalMixingSerial.cpp:  // x face-center (this assume constant dx for the moment, same as QES-winds)
LocalMixingSerial.cpp:  for (int i = 1; i < nx - 1; i++) {
LocalMixingSerial.cpp:    x_fc[i] = 0.5 * (WGD->x[i - 1] + WGD->x[i]);
LocalMixingSerial.cpp:  x_fc[0] = x_fc[1] - dx;
LocalMixingSerial.cpp:  x_fc[nx - 1] = x_fc[nx - 2] + dx;
LocalMixingSerial.cpp:  // y cell-center
LocalMixingSerial.cpp:  y_cc = WGD->y;
LocalMixingSerial.cpp:  // y face-center (this assume constant dy for the moment, same as QES-winds)
LocalMixingSerial.cpp:  for (int i = 1; i < ny - 1; i++) {
LocalMixingSerial.cpp:    y_fc[i] = 0.5 * (WGD->y[i - 1] + WGD->y[i]);
LocalMixingSerial.cpp:  y_fc[0] = y_fc[1] - dy;
LocalMixingSerial.cpp:  y_fc[ny - 1] = y_fc[ny - 2] + dy;
LocalMixingSerial.cpp:  // z cell-center
LocalMixingSerial.cpp:  z_cc = WGD->z;
LocalMixingSerial.cpp:  // z face-center (with ghost cell under the ground)
LocalMixingSerial.cpp:    z_fc[i] = WGD->z_face[i - 1];
LocalMixingSerial.cpp:  z_fc[0] = z_fc[1] - dz;
LocalMixingSerial.cpp:    //float max_z=*std::max_element(WGD->terrain.begin(),WGD->terrain.end());
LocalMixingSerial.cpp:    the following code works based on the icellflag -> works for both the
LocalMixingSerial.cpp:  for (int i = 1; i < nx - 2; i++) {
LocalMixingSerial.cpp:    for (int j = 1; j < ny - 2; j++) {
LocalMixingSerial.cpp:      for (int k = 0; k < nz - 2; k++) {
LocalMixingSerial.cpp:        int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:        if ((WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2) && max_z < z_cc[k]) {
LocalMixingSerial.cpp:  int max_height = nz - 2;
LocalMixingSerial.cpp:  for (int k = 0; k < nz - 1; ++k) {
LocalMixingSerial.cpp:  for (int i = 1; i < nx - 2; i++) {
LocalMixingSerial.cpp:    for (int j = 1; j < ny - 2; j++) {
LocalMixingSerial.cpp:      for (int k = 0; k < nz - 2; k++) {
LocalMixingSerial.cpp:        int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:        if ((WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2)) {
LocalMixingSerial.cpp:            WGD->mixingLengths[icell_cent] = z_cc[k] - WGD->terrain[i + j * (nx - 1)];
LocalMixingSerial.cpp:            WGD->mixingLengths[icell_cent] = z_cc[k];
LocalMixingSerial.cpp:          if (WGD->mixingLengths[icell_cent] < 0.0) {
LocalMixingSerial.cpp:            WGD->mixingLengths[icell_cent] = 0.0;
LocalMixingSerial.cpp:  int k1 = std::min(max_height - 1, nz - 2);
LocalMixingSerial.cpp:  int k2 = std::min(k1 + k1 / 5, nz - 2);
LocalMixingSerial.cpp:  for (int i = 1; i < nx - 2; ++i) {
LocalMixingSerial.cpp:    for (int j = 1; j < ny - 2; ++j) {
LocalMixingSerial.cpp:      int id1 = i + j * (nx - 1) + k1 * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:      int id2 = i + j * (nx - 1) + k2 * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:      // slope m = (L(z2)-L(z1))/(z2-z1)
LocalMixingSerial.cpp:      float slope = (WGD->mixingLengths[id2] - WGD->mixingLengths[id1]) / (z_cc[k2] - z_cc[k1]);
LocalMixingSerial.cpp:      // linear interp: L(z) = L(z1) + m*(z-z1)
LocalMixingSerial.cpp:        int id_cc = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:        WGD->mixingLengths[id_cc] = WGD->mixingLengths[id1] + (z_cc[k] - z_cc[k1]) * slope;
LocalMixingSerial.cpp:  if (WID->turbParams->save2file) {
LocalMixingSerial.cpp:  int nx = WGD->nx;
LocalMixingSerial.cpp:  int ny = WGD->ny;
LocalMixingSerial.cpp:  int nz = WGD->nz;
LocalMixingSerial.cpp:  for (int i = 1; i < nx - 2; i++) {
LocalMixingSerial.cpp:    for (int j = 1; j < ny - 2; j++) {
LocalMixingSerial.cpp:      for (int k = 1; k < nz - 2; k++) {
LocalMixingSerial.cpp:        int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:        if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
LocalMixingSerial.cpp:          if (WGD->icellflag[icell_cent - (nx - 1) * (ny - 1)] == 0 || WGD->icellflag[icell_cent - (nx - 1) * (ny - 1)] == 2) {
LocalMixingSerial.cpp:          if (WGD->icellflag[icell_cent + (nx - 1) * (ny - 1)] == 0 || WGD->icellflag[icell_cent + (nx - 1) * (ny - 1)] == 2) {
LocalMixingSerial.cpp:          if (WGD->icellflag[icell_cent - 1] == 0 || WGD->icellflag[icell_cent - 1] == 2) {
LocalMixingSerial.cpp:          if (WGD->icellflag[icell_cent + 1] == 0 || WGD->icellflag[icell_cent + 1] == 2) {
LocalMixingSerial.cpp:          if (WGD->icellflag[icell_cent - (nx - 1)] == 0 || WGD->icellflag[icell_cent - (nx - 1)] == 2) {
LocalMixingSerial.cpp:          if (WGD->icellflag[icell_cent + (nx - 1)] == 0 || WGD->icellflag[icell_cent + (nx - 1)] == 2) {
LocalMixingSerial.cpp:    int idxp = id_cc - (nx - 1) * (ny - 1) + 1;
LocalMixingSerial.cpp:    int idxm = id_cc - (nx - 1) * (ny - 1) - 1;
LocalMixingSerial.cpp:    int idyp = id_cc - (nx - 1) * (ny - 1) + (nx - 1);
LocalMixingSerial.cpp:    int idym = id_cc - (nx - 1) * (ny - 1) - (nx - 1);
LocalMixingSerial.cpp:    int k = (int)(id_cc / ((nx - 1) * (ny - 1)));
LocalMixingSerial.cpp:    int j = (int)((id_cc - k * (nx - 1) * (ny - 1)) / (nx - 1));
LocalMixingSerial.cpp:    int i = id_cc - j * (nx - 1) - k * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:    int maxdist = max_height - k;
LocalMixingSerial.cpp:    WGD->mixingLengths[id_cc] = z_cc[k] - z_fc[k];
LocalMixingSerial.cpp:    if (WGD->icellflag[idxp] == 2 && WGD->icellflag[idxm] == 2 && WGD->icellflag[idyp] == 2 && WGD->icellflag[idym] == 2) {
LocalMixingSerial.cpp:      // terrain on all 4 corner -> nothing to do
LocalMixingSerial.cpp:    } else if (WGD->icellflag[idxp] == 0 && WGD->icellflag[idxm] == 0 && WGD->icellflag[idyp] == 0 && WGD->icellflag[idym] == 0) {
LocalMixingSerial.cpp:      // building on all 4 corner -> propagate verically
LocalMixingSerial.cpp:        int id = i + j * (nx - 1) + (kk + k) * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:        float dist = sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2) + pow((z2 - z1), 2));
LocalMixingSerial.cpp:        WGD->mixingLengths[id] = std::min(dist, static_cast<float>(WGD->mixingLengths[id]));
LocalMixingSerial.cpp:        int i1 = std::max(i - maxdist - kk, 1);
LocalMixingSerial.cpp:        int i2 = std::min(i + maxdist + kk, nx - 2);
LocalMixingSerial.cpp:        int j1 = std::max(j - maxdist - kk, 1);
LocalMixingSerial.cpp:        int j2 = std::min(j + maxdist + kk, ny - 2);
LocalMixingSerial.cpp:            int id = ii + jj * (nx - 1) + (kk + k) * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:            float dist = sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2) + pow((z2 - z1), 2));
LocalMixingSerial.cpp:            WGD->mixingLengths[id] = std::min(dist, static_cast<float>(WGD->mixingLengths[id]));
LocalMixingSerial.cpp:    int k = (int)(id_cc / ((nx - 1) * (ny - 1)));
LocalMixingSerial.cpp:    int j = (int)((id_cc - k * (nx - 1) * (ny - 1)) / (nx - 1));
LocalMixingSerial.cpp:    int i = id_cc - j * (nx - 1) - k * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:    if (i + k < nx - 1) {
LocalMixingSerial.cpp:      maxdist = nx - 1 - i;
LocalMixingSerial.cpp:    WGD->mixingLengths[id_cc] = x_cc.at(i) - x_fc.at(i);
LocalMixingSerial.cpp:      // int k2 = std::min(k+ii+1,nz-2);
LocalMixingSerial.cpp:      int j1 = std::max(j - ii, 0);
LocalMixingSerial.cpp:      int j2 = std::min(j + ii + 1, ny - 2);
LocalMixingSerial.cpp:          int id = (i + ii) + jj * (nx - 1) + (kk) * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:          float dist = sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2) + pow((z2 - z1), 2));
LocalMixingSerial.cpp:          WGD->mixingLengths[id] = std::min(dist, static_cast<float>(WGD->mixingLengths[id]));
LocalMixingSerial.cpp:    int k = (int)(id_cc / ((nx - 1) * (ny - 1)));
LocalMixingSerial.cpp:    int j = (int)((id_cc - k * (nx - 1) * (ny - 1)) / (nx - 1));
LocalMixingSerial.cpp:    int i = id_cc - j * (nx - 1) - k * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:    if (i - k > 0) {
LocalMixingSerial.cpp:    WGD->mixingLengths[id_cc] = x_fc.at(i + 1) - x_cc.at(i);
LocalMixingSerial.cpp:    for (int ii = 0; ii >= -maxdist; ii--) {
LocalMixingSerial.cpp:      // int k2 = std::min(k-ii+1,nz-2);
LocalMixingSerial.cpp:      int j2 = std::min(j - ii + 1, ny - 2);
LocalMixingSerial.cpp:          int id = (i + 1 + ii) + jj * (nx - 1) + (kk) * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:          float dist = sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2) + pow((z2 - z1), 2));
LocalMixingSerial.cpp:          WGD->mixingLengths[id] = std::min(dist, static_cast<float>(WGD->mixingLengths[id]));
LocalMixingSerial.cpp:    int k = (int)(id_cc / ((nx - 1) * (ny - 1)));
LocalMixingSerial.cpp:    int j = (int)((id_cc - k * (nx - 1) * (ny - 1)) / (nx - 1));
LocalMixingSerial.cpp:    int i = id_cc - j * (nx - 1) - k * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:    if (j + k < ny - 1) {
LocalMixingSerial.cpp:      maxdist = ny - 1 - j;
LocalMixingSerial.cpp:    WGD->mixingLengths[id_cc] = y_cc[j] - y_fc[j];
LocalMixingSerial.cpp:      // int k2 = std::min(k+jj+1,nz-2);
LocalMixingSerial.cpp:      int i1 = std::max(i - jj, 0);
LocalMixingSerial.cpp:      int i2 = std::min(i + jj + 1, nx - 2);
LocalMixingSerial.cpp:          int id = ii + (j + jj) * (nx - 1) + (kk) * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:          float dist = sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2) + pow((z2 - z1), 2));
LocalMixingSerial.cpp:          WGD->mixingLengths[id] = std::min(dist, static_cast<float>(WGD->mixingLengths[id]));
LocalMixingSerial.cpp:    int k = (int)(id_cc / ((nx - 1) * (ny - 1)));
LocalMixingSerial.cpp:    int j = (int)((id_cc - k * (nx - 1) * (ny - 1)) / (nx - 1));
LocalMixingSerial.cpp:    int i = id_cc - j * (nx - 1) - k * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:    if (j - k > 0) {
LocalMixingSerial.cpp:    WGD->mixingLengths[id_cc] = y_fc[j + 1] - y_cc[j];
LocalMixingSerial.cpp:    for (int jj = 0; jj >= -maxdist; jj--) {
LocalMixingSerial.cpp:      // int k2 = std::min(k-jj+1,nz-2);
LocalMixingSerial.cpp:      int i2 = std::min(i - jj + 1, nx - 2);
LocalMixingSerial.cpp:          int id = ii + (j + 1 + jj) * (nx - 1) + (kk) * (nx - 1) * (ny - 1);
LocalMixingSerial.cpp:          float dist = sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2) + pow((z2 - z1), 2));
LocalMixingSerial.cpp:          WGD->mixingLengths[id] = std::min(dist, static_cast<float>(WGD->mixingLengths[id]));
LocalMixingSerial.h: * This file is part of QES-Winds
LocalMixingSerial.h: * GPL-3.0 License
LocalMixingSerial.h: * QES-Winds is free software: you can redistribute it and/or modify
LocalMixingSerial.h: * QES-Winds is distributed in the hope that it will be useful,
LocalMixingSerial.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Mesh.cpp: * This file is part of QES-Winds
Mesh.cpp: * GPL-3.0 License
Mesh.cpp: * QES-Winds is free software: you can redistribute it and/or modify
Mesh.cpp: * QES-Winds is distributed in the hope that it will be useful,
Mesh.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Mesh.cpp:  return triangleBVH->heightToTri(x, y);
Mesh.cpp:  for (int k = 0; k < dimZ - 1; k++) {
Mesh.cpp:    for (int j = 0; j < dimY - 1; j++) {
Mesh.cpp:      for (int i = 0; i < dimX - 1; i++) {
Mesh.cpp:        int icell_idx = i + j * (dimX - 1) + k * (dimY - 1) * (dimX - 1);
Mesh.cpp:          SphereDirections sd(512, -1, 1, 0, 2 * M_PI);
Mesh.cpp:          //               float t1 = -1;
Mesh.cpp:            bool isHit = triangleBVH->rayHit(ray, hit);
Mesh.cpp:  std::cout << "--------------Enters the tempOPTIXMethod--------------------" << std::endl;
Mesh.h: * This file is part of QES-Winds
Mesh.h: * GPL-3.0 License
Mesh.h: * QES-Winds is free software: you can redistribute it and/or modify
Mesh.h: * QES-Winds is distributed in the hope that it will be useful,
Mesh.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Mesh.h:    this->triangleBVH = BVH::createBVH(tris);
Mesh.h:    //  this->optixRayTracer = new OptixRayTrace(tris);
Mesh.h:   * Gets the height from a location on the xy-plane
Mesh.h:   * @param x x-position
Mesh.h:   * @param y y-position
MetParams.h: * This file is part of QES-Winds
MetParams.h: * GPL-3.0 License
MetParams.h: * QES-Winds is free software: you can redistribute it and/or modify
MetParams.h: * QES-Winds is distributed in the hope that it will be useful,
MetParams.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
NonLocalMixing.cpp: * This file is part of QES-Winds
NonLocalMixing.cpp: * GPL-3.0 License
NonLocalMixing.cpp: * QES-Winds is free software: you can redistribute it and/or modify
NonLocalMixing.cpp: * QES-Winds is distributed in the hope that it will be useful,
NonLocalMixing.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
NonLocalMixing.cpp:  int nx = WGD->nx;
NonLocalMixing.cpp:  int ny = WGD->ny;
NonLocalMixing.cpp:  int nz = WGD->nz;
NonLocalMixing.cpp:  Lr_face.resize(polygonVertices.size(), -1.0);// Length of wake for each face
NonLocalMixing.cpp:  float epsilon = 10e-10;
NonLocalMixing.cpp:    std::cout << "[WARNING] building ill-defined (no area) -> use local mixing (building id=" << building_id << ")" << std::endl;
NonLocalMixing.cpp:  if (k_start < 1 || k_start > nz - 2 || k_end < 1 || k_end > nz - 2) {
NonLocalMixing.cpp:    // exit if building start/end point is ill-defined (computed in polygonWake.cpp)
NonLocalMixing.cpp:    std::cout << "[WARNING] building ill-defined (k out of bound) -> use local mixing (building id=" << building_id << ")" << std::endl;
NonLocalMixing.cpp:  if ( height_eff >= WGD->z[nz-1] ) {
NonLocalMixing.cpp:      std::cout << "domain = "<< WGD->z[0] << " " << WGD->z[nz-2] << " " << WGD->z[nz-1] << std::endl;
NonLocalMixing.cpp:      // exit if building above top domain is ill-defined (computed in polygonWake.cpp)
NonLocalMixing.cpp:      std::cout<< "[WARNING] building ill-defined -> use local mixing (building id="<< building_id << ")" <<std::endl;
NonLocalMixing.cpp:  for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
NonLocalMixing.cpp:    // Finding faces that are eligible for applying the far-wake parameterizations
NonLocalMixing.cpp:    // angle between two points should be in -180 to 0 degree
NonLocalMixing.cpp:  for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
NonLocalMixing.cpp:      index_previous = (id + polygonVertices.size() - 2) % (polygonVertices.size() - 1);// Index of previous face
NonLocalMixing.cpp:      index_next = (id + 1) % (polygonVertices.size() - 1);// Index of next face
NonLocalMixing.cpp:        Lr_node[id + 1] = ((yi[index_next] - yi[index_next + 1]) * Lr_face[index_next] + (yi[id] - yi[index_next]) * Lr_face[id]) / (yi[id] - yi[index_next + 1]);
NonLocalMixing.cpp:        Lr_node[id] = ((yi[id] - yi[index_next]) * Lr_face[id] + (yi[index_previous] - yi[id]) * Lr_face[index_previous]) / (yi[index_previous] - yi[index_next]);
NonLocalMixing.cpp:        Lr_node[id] = ((yi[id] - yi[index_next]) * Lr_face[id] + (yi[index_previous] - yi[id]) * Lr_face[index_previous]) / (yi[index_previous] - yi[index_next]);
NonLocalMixing.cpp:        Lr_node[id + 1] = ((yi[index_next] - yi[index_next + 1]) * Lr_face[index_next] + (yi[id] - yi[index_next]) * Lr_face[id]) / (yi[id] - yi[index_next + 1]);
NonLocalMixing.cpp:      Lr_ave += Lr_face[id] * (yi[id] - yi[index_next]);
NonLocalMixing.cpp:      total_seg_length += (yi[id] - yi[index_next]);
NonLocalMixing.cpp:    if ((polygonVertices[id + 1].x_poly > polygonVertices[0].x_poly - 0.1) && (polygonVertices[id + 1].x_poly < polygonVertices[0].x_poly + 0.1)
NonLocalMixing.cpp:        && (polygonVertices[id + 1].y_poly > polygonVertices[0].y_poly - 0.1) && (polygonVertices[id + 1].y_poly < polygonVertices[0].y_poly + 0.1)) {
NonLocalMixing.cpp:    if (base_height <= WGD->z.at(k)) {
NonLocalMixing.cpp:  for (auto k = k_start; k < WGD->nz - 2; k++) {
NonLocalMixing.cpp:    if (height_eff < WGD->z.at(k + 1)) {
NonLocalMixing.cpp:    if (0.75 * H + base_height <= WGD->z.at(k)) {
NonLocalMixing.cpp:  u_h = 0.5 * (WGD->u[icell_face] + WGD->u[icell_face + 1]);
NonLocalMixing.cpp:  v_h = 0.5 * (WGD->v[icell_face] + WGD->v[icell_face + nx]);
NonLocalMixing.cpp:  // w_h=0.5*(WGD->w[icell_face]+WGD->w[icell_face+nx*ny]);
NonLocalMixing.cpp:  float dxy = scale_factor * WGD->dxy;
NonLocalMixing.cpp:  for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
NonLocalMixing.cpp:    xp_i[id] = cos(upwind_dir) * (polygonVertices[id].x_poly - building_cent_x) + sin(upwind_dir) * (polygonVertices[id].y_poly - building_cent_y);
NonLocalMixing.cpp:    yp_i[id] = -sin(upwind_dir) * (polygonVertices[id].x_poly - building_cent_x) + cos(upwind_dir) * (polygonVertices[id].y_poly - building_cent_y);
NonLocalMixing.cpp:  int minIndex = std::min_element(yp_i.begin(), yp_i.end()) - yp_i.begin();
NonLocalMixing.cpp:  int maxIndex = std::max_element(yp_i.begin(), yp_i.end()) - yp_i.begin();
NonLocalMixing.cpp:  // min (right) and max (left) x-postion of the outer point of the polybuilding
NonLocalMixing.cpp:  // if xp < 0 -> add small amount to ensure point is inside
NonLocalMixing.cpp:  // if xp > 0 -> substract small amount ot ensure point is inside
NonLocalMixing.cpp:    xp_r -= 0.5 * dxy;
NonLocalMixing.cpp:    xp_l -= 0.5 * dxy;
NonLocalMixing.cpp:  // min (right) and max (left) y-postion of the outer point of the polybuilding
NonLocalMixing.cpp:  yp_l = yp_i[maxIndex] - 0.5 * dxy;
NonLocalMixing.cpp:   // x-coord of maximun downstream vertex
NonLocalMixing.cpp:   maxIndex = std::max_element(xp_i.begin(),xp_i.end()) - xp_i.begin();
NonLocalMixing.cpp:   xp_d=xp_i[maxIndex]-0.5*dxy;
NonLocalMixing.cpp:   x_r = cos(upwind_dir)*xp_r - sin(upwind_dir)*yp_r + building_cent_x;
NonLocalMixing.cpp:   int i_r = floor(x_r/WGD->dx);
NonLocalMixing.cpp:   int j_r = floor(y_r/WGD->dy);
NonLocalMixing.cpp:   for (auto k=k_top+1; k>=k_bottom; k--) {
NonLocalMixing.cpp:   icell_cent = i_r + j_r*(nx-1) + k*(ny-1)*(nx-1);
NonLocalMixing.cpp:   TGD->iturbflag[icell_cent]=12;
NonLocalMixing.cpp:   x_l = cos(upwind_dir)*xp_l - sin(upwind_dir)*yp_l + building_cent_x;
NonLocalMixing.cpp:   int i_l = floor(x_l/WGD->dx);
NonLocalMixing.cpp:   int j_l = floor(y_l/WGD->dy);
NonLocalMixing.cpp:   for (auto k=k_top+1; k>=k_bottom; k--) {
NonLocalMixing.cpp:   icell_cent = i_l + j_l*(nx-1) + k*(ny-1)*(nx-1);
NonLocalMixing.cpp:   TGD->iturbflag[icell_cent]=12;
NonLocalMixing.cpp:  yp_ref_r = yp_r - 3.0 * dxy;
NonLocalMixing.cpp:  x_ref_r = cos(upwind_dir) * xp_ref_r - sin(upwind_dir) * yp_ref_r + building_cent_x;
NonLocalMixing.cpp:  int i_ref_r = floor(x_ref_r / WGD->dx);
NonLocalMixing.cpp:  int j_ref_r = floor(y_ref_r / WGD->dy);
NonLocalMixing.cpp:  if (i_ref_r >= WGD->nx - 2 && i_ref_r <= 0 && j_ref_r >= WGD->ny - 2 && j_ref_r <= 0) {
NonLocalMixing.cpp:    std::cout << "[WARNING] right ref point outside domain -> use local mixing (building id=" << building_id << ")" << std::endl;
NonLocalMixing.cpp:  for (auto k = k_top + 1; k >= k_bottom; k--) {
NonLocalMixing.cpp:    icell_cent = i_ref_r + j_ref_r * (nx - 1) + k * (ny - 1) * (nx - 1);
NonLocalMixing.cpp:    // TGD->iturbflag[icell_cent]=12;
NonLocalMixing.cpp:  x_ref_l = cos(upwind_dir) * xp_ref_l - sin(upwind_dir) * yp_ref_l + building_cent_x;
NonLocalMixing.cpp:  int i_ref_l = floor(x_ref_l / WGD->dx);
NonLocalMixing.cpp:  int j_ref_l = floor(y_ref_l / WGD->dy);
NonLocalMixing.cpp:  if (i_ref_l >= WGD->nx - 2 && i_ref_l <= 0 && j_ref_l >= WGD->ny - 2 && j_ref_l <= 0) {
NonLocalMixing.cpp:    std::cout << "[WARNING] left ref point outside domain -> use local mixing (building id=" << building_id << ")" << std::endl;
NonLocalMixing.cpp:  for (auto k = k_top + 1; k >= k_bottom; k--) {
NonLocalMixing.cpp:    icell_cent = i_ref_l + j_ref_l * (nx - 1) + k * (ny - 1) * (nx - 1);
NonLocalMixing.cpp:    // TGD->iturbflag[icell_cent]=12;
NonLocalMixing.cpp:  for (auto k = k_top; k >= k_bottom; k--) {
NonLocalMixing.cpp:    z_build = WGD->z[k] - base_height;
NonLocalMixing.cpp:    u_h = 0.5 * (WGD->u[icell_face] + WGD->u[icell_face + 1]);
NonLocalMixing.cpp:    v_h = 0.5 * (WGD->v[icell_face] + WGD->v[icell_face + nx]);
NonLocalMixing.cpp:    // w_h=0.5*(WGD->w[icell_face]+WGD->w[icell_face+nx*ny]);
NonLocalMixing.cpp:    u_h = 0.5 * (WGD->u[icell_face] + WGD->u[icell_face + 1]);
NonLocalMixing.cpp:    v_h = 0.5 * (WGD->v[icell_face] + WGD->v[icell_face + nx]);
NonLocalMixing.cpp:    // w_h=0.5*(WGD->w[icell_face]+WGD->w[icell_face+nx*ny]);
NonLocalMixing.cpp:        for (auto y_id = 0; y_id <= 2 * ceil(abs(yi[id] - yi[id + 1]) / WGD->dxy); y_id++) {
NonLocalMixing.cpp:          yc = yi[id] - 0.5 * y_id * WGD->dxy;
NonLocalMixing.cpp:          Lr_local = Lr_node[id] + (yc - yi[id]) * (Lr_node[id + 1] - Lr_node[id]) / (yi[id + 1] - yi[id]);
NonLocalMixing.cpp:            x_wall = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (yc - yi[id]) + xi[id];
NonLocalMixing.cpp:          x_id_min = -1;
NonLocalMixing.cpp:          for (auto x_id = 1; x_id <= ceil(Lr_local / WGD->dxy); x_id++) {
NonLocalMixing.cpp:            xc = x_id * WGD->dxy;
NonLocalMixing.cpp:            int i = ((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx;
NonLocalMixing.cpp:            int j = ((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy;
NonLocalMixing.cpp:            if (i >= WGD->nx - 2 && i <= 0 && j >= WGD->ny - 2 && j <= 0) {
NonLocalMixing.cpp:            int icell_cent = i + j * (WGD->nx - 1) + kk * (WGD->nx - 1) * (WGD->ny - 1);
NonLocalMixing.cpp:            if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2 && x_id_min < 0) {
NonLocalMixing.cpp:            if ((WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2) && x_id_min > 0) {
NonLocalMixing.cpp:          x_id_min = -1;
NonLocalMixing.cpp:          for (auto x_id = 1; x_id <= 2 * ceil(farwake_factor * Lr_local / WGD->dxy); x_id++) {
NonLocalMixing.cpp:            xc = 0.5 * x_id * WGD->dxy;
NonLocalMixing.cpp:            int i = ((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx;
NonLocalMixing.cpp:            int j = ((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy;
NonLocalMixing.cpp:            if (i >= WGD->nx - 2 || i <= 0 || j >= WGD->ny - 2 || j <= 0) {
NonLocalMixing.cpp:            icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
NonLocalMixing.cpp:            if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2 && x_id_min < 0) {
NonLocalMixing.cpp:            if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2) {
NonLocalMixing.cpp:                if (WGD->ibuilding_flag[icell_cent] == building_id) {
NonLocalMixing.cpp:                  x_id_min = -1;
NonLocalMixing.cpp:                } else if (WGD->icellflag[i + j * (WGD->nx - 1) + kk * (WGD->nx - 1) * (WGD->ny - 1)] == 0 || WGD->icellflag[i + j * (WGD->nx - 1) + kk * (WGD->nx - 1) * (WGD->ny - 1)] == 2) {
NonLocalMixing.cpp:            if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
NonLocalMixing.cpp:              i_u = std::round(((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx);
NonLocalMixing.cpp:              j_u = ((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy;
NonLocalMixing.cpp:              if (i_u < WGD->nx - 1 && i_u > 0 && j_u < WGD->ny - 1 && j_u > 0) {
NonLocalMixing.cpp:                xp = i_u * WGD->dx - building_cent_x;
NonLocalMixing.cpp:                yp = (j_u + 0.5) * WGD->dy - building_cent_y;
NonLocalMixing.cpp:                yu = -xp * sin(upwind_dir) + yp * cos(upwind_dir);
NonLocalMixing.cpp:                Lr_local_u = Lr_node[id] + (yu - yi[id]) * (Lr_node[id + 1] - Lr_node[id]) / (yi[id + 1] - yi[id]);
NonLocalMixing.cpp:                  x_wall_u = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (yu - yi[id]) + xi[id];
NonLocalMixing.cpp:                xu -= x_wall_u;
NonLocalMixing.cpp:                  dn_u = sqrt((1.0 - pow((yu / y_norm), 2.0)) * (1.0 - pow((z_build / height_eff), 2.0)) * pow((canyon_factor * Lr_local_u), 2.0));
NonLocalMixing.cpp:              i_v = ((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx;
NonLocalMixing.cpp:              j_v = std::round(((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy);
NonLocalMixing.cpp:              if (i_v < WGD->nx - 1 && i_v > 0 && j_v < WGD->ny - 1 && j_v > 0) {
NonLocalMixing.cpp:                xp = (i_v + 0.5) * WGD->dx - building_cent_x;
NonLocalMixing.cpp:                yp = j_v * WGD->dy - building_cent_y;
NonLocalMixing.cpp:                yv = -xp * sin(upwind_dir) + yp * cos(upwind_dir);
NonLocalMixing.cpp:                Lr_local_v = Lr_node[id] + (yv - yi[id]) * (Lr_node[id + 1] - Lr_node[id]) / (yi[id + 1] - yi[id]);
NonLocalMixing.cpp:                  x_wall_v = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (yv - yi[id]) + xi[id];
NonLocalMixing.cpp:                xv -= x_wall_v;
NonLocalMixing.cpp:                  dn_v = sqrt((1.0 - pow((yv / y_norm), 2.0)) * (1.0 - pow((z_build / height_eff), 2.0)) * pow((canyon_factor * Lr_local_v), 2.0));
NonLocalMixing.cpp:              i_w = ceil(((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx) - 1;
NonLocalMixing.cpp:              j_w = ceil(((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy) - 1;
NonLocalMixing.cpp:              if (i_w < WGD->nx - 2 && i_w > 0 && j_w < WGD->ny - 2 && j_w > 0) {
NonLocalMixing.cpp:                xp = (i_w + 0.5) * WGD->dx - building_cent_x;
NonLocalMixing.cpp:                yp = (j_w + 0.5) * WGD->dy - building_cent_y;
NonLocalMixing.cpp:                yw = -xp * sin(upwind_dir) + yp * cos(upwind_dir);
NonLocalMixing.cpp:                Lr_local_w = Lr_node[id] + (yw - yi[id]) * (Lr_node[id + 1] - Lr_node[id]) / (yi[id + 1] - yi[id]);
NonLocalMixing.cpp:                  x_wall_w = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (yw - yi[id]) + xi[id];
NonLocalMixing.cpp:                xw -= x_wall_w;
NonLocalMixing.cpp:                  dn_w = sqrt((1.0 - pow(yw / y_norm, 2.0)) * (1.0 - pow(z_build / height_eff, 2.0)) * pow(canyon_factor * Lr_local_w, 2.0));
NonLocalMixing.cpp:                icell_cent = i_w + j_w * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
NonLocalMixing.cpp:                icell_face = i_w + j_w * WGD->nx + k * WGD->nx * WGD->ny;
NonLocalMixing.cpp:                if (dn_w > 0.0 && w_wake_flag == 1 && yw <= yi[id] && yw >= yi[id + 1] && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
NonLocalMixing.cpp:                  i_cl = ceil((cos(upwind_dir) * xw + building_cent_x) / WGD->dx) - 1;
NonLocalMixing.cpp:                  j_cl = ceil((sin(upwind_dir) * xw + building_cent_y) / WGD->dy) - 1;
NonLocalMixing.cpp:                  if (i_cl < WGD->nx - 2 && i_cl > 0 && j_cl < WGD->ny - 2 && j_cl > 0) {
NonLocalMixing.cpp:                    icell_cent_cl = i_cl + j_cl * (nx - 1) + k * (ny - 1) * (nx - 1);
NonLocalMixing.cpp:                    u_h = 0.5 * (WGD->u[icell_face_cl] + WGD->u[icell_face_cl + 1]);
NonLocalMixing.cpp:                    v_h = 0.5 * (WGD->v[icell_face_cl] + WGD->v[icell_face_cl + nx]);
NonLocalMixing.cpp:                    // w_h=0.5*(WGD->w[icell_face_cl]+WGD->w[icell_face_cl+nx*ny]);
NonLocalMixing.cpp:                    // TGD->iturbflag[icell_cent_cl]=12;
NonLocalMixing.cpp:                  dU_ref_H = max(abs(U_ref_l - U_a), abs(U_ref_r - U_a));
NonLocalMixing.cpp:                  u_h = 0.5 * (WGD->u[icell_face] + WGD->u[icell_face + 1]);
NonLocalMixing.cpp:                  v_h = 0.5 * (WGD->v[icell_face] + WGD->v[icell_face + nx]);
NonLocalMixing.cpp:                  // w_h=0.5*(WGD->w[icell_face]+WGD->w[icell_face+nx*ny]);
NonLocalMixing.cpp:                      TGD->txx[icell_cent] = sigUConst * sigUConst * ustar2;
NonLocalMixing.cpp:                      TGD->tyy[icell_cent] = sigVConst * sigVConst * ustar2;
NonLocalMixing.cpp:                      TGD->tzz[icell_cent] = sigWConst * sigWConst * ustar2;
NonLocalMixing.cpp:                      TGD->txy[icell_cent] = abs(yw) / (0.5 * width_eff) * ustar2;
NonLocalMixing.cpp:                      TGD->tyz[icell_cent] = 0.0;
NonLocalMixing.cpp:                      TGD->txz[icell_cent] = 0.0;
NonLocalMixing.cpp:                      TGD->Lm[icell_cent] = width_eff;
NonLocalMixing.cpp:                      TGD->iturbflag[icell_cent] = 11;
NonLocalMixing.cpp:                      TGD->tke[icell_cent] = 0.5 * (TGD->txx[icell_cent] + TGD->tyy[icell_cent] + TGD->tzz[icell_cent]);
NonLocalMixing.cpp:                      TGD->CoEps[icell_cent] = 5.7 * pow(ustar, 3.0) / (TGD->Lm[icell_cent]);
NonLocalMixing.cpp:                      TGD->txx[icell_cent] = sigUConst * sigUConst * ustar2;
NonLocalMixing.cpp:                      TGD->tyy[icell_cent] = sigVConst * sigVConst * ustar2;
NonLocalMixing.cpp:                      TGD->tzz[icell_cent] = sigWConst * sigWConst * ustar2;
NonLocalMixing.cpp:                      TGD->txy[icell_cent] = abs(yw) / (0.5 * width_eff) * ustar2;
NonLocalMixing.cpp:                      TGD->tyz[icell_cent] = 0.0;
NonLocalMixing.cpp:                      TGD->txz[icell_cent] = 0.0;
NonLocalMixing.cpp:                      TGD->Lm[icell_cent] = width_eff;
NonLocalMixing.cpp:                      TGD->iturbflag[icell_cent] = 11;
NonLocalMixing.cpp:                      TGD->txx[icell_cent] = sigUConst * sigUConst * ustar2;
NonLocalMixing.cpp:                      TGD->tyy[icell_cent] = sigVConst * sigVConst * ustar2;
NonLocalMixing.cpp:                      TGD->tzz[icell_cent] = sigWConst * sigWConst * ustar2;
NonLocalMixing.cpp:                      TGD->txy[icell_cent] = 0;
NonLocalMixing.cpp:                      TGD->tyz[icell_cent] = -ustar2 * sin(upwind_dir);// projection with wind dir
NonLocalMixing.cpp:                      TGD->txz[icell_cent] = -ustar2 * cos(upwind_dir);// projection with wind dir
NonLocalMixing.cpp:                      TGD->Lm[icell_cent] = 0.75 * H;
NonLocalMixing.cpp:                      TGD->iturbflag[icell_cent] = 12;
NonLocalMixing.cpp:                    TGD->tke[icell_cent] = 0.5 * (TGD->txx[icell_cent] + TGD->tyy[icell_cent] + TGD->tzz[icell_cent]);
NonLocalMixing.cpp:                    TGD->CoEps[icell_cent] = 5.7 * pow(ustar, 3.0) / (TGD->Lm[icell_cent]);
OptixRayTrace.cpp: * This file is part of QES-Winds
OptixRayTrace.cpp: * GPL-3.0 License
OptixRayTrace.cpp: * QES-Winds is free software: you can redistribute it and/or modify
OptixRayTrace.cpp: * QES-Winds is distributed in the hope that it will be useful,
OptixRayTrace.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
OptixRayTrace.cpp:#define TEST 0// Set to true for ground-only AS
OptixRayTrace.cpp:  return ((x + y - 1) / y) * y;
OptixRayTrace.cpp:  // need to translate tris --> to a vector array of measurable size type
OptixRayTrace.cpp:  std::vector<Vertex> trisArray(tris.size() * 3);// each triangle 3 Vertex-es
OptixRayTrace.cpp:    trisArray[tempIdx] = { (*(tris[i]->a))[0], (*(tris[i]->a))[1], (*(tris[i]->a))[2] };
OptixRayTrace.cpp:    trisArray[tempIdx] = { (*(tris[i]->b))[0], (*(tris[i]->b))[1], (*(tris[i]->b))[2] };
OptixRayTrace.cpp:    trisArray[tempIdx] = { (*(tris[i]->c))[0], (*(tris[i]->c))[1], (*(tris[i]->c))[2] };
OptixRayTrace.cpp:    for (int k = 0; k < dimZ - 1; k++) {
OptixRayTrace.cpp:      for (int j = 0; j < dimY - 1; j++) {
OptixRayTrace.cpp:        for (int i = 0; i < dimX - 1; i++) {
OptixRayTrace.cpp:          int icell_idx = i + j * (dimX - 1) + k * (dimY - 1) * (dimX - 1);
OptixRayTrace.cpp:                          state.nx - 1,
OptixRayTrace.cpp:                          state.ny - 1,
OptixRayTrace.cpp:                          state.nz - 1));
OptixRayTrace.cu: * This file is part of QES-Winds
OptixRayTrace.cu: * GPL-3.0 License
OptixRayTrace.cu: * QES-Winds is free software: you can redistribute it and/or modify
OptixRayTrace.cu: * QES-Winds is distributed in the hope that it will be useful,
OptixRayTrace.cu: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
OptixRayTrace.cu:  //  const uint32_t linear_idx = idx.x + idx.y*(dim.x-1) + idx.z*(dim.y-1)*(dim.x-1);
OptixRayTrace.cu:      make_float3(0, 0, -1),
OptixRayTrace.cu:      make_float3(-1, 0, 0),
OptixRayTrace.cu:      make_float3(0, -1, 0)
OptixRayTrace.cu:        // Trignometric-Polar Method
OptixRayTrace.h: * This file is part of QES-Winds
OptixRayTrace.h: * GPL-3.0 License
OptixRayTrace.h: * QES-Winds is free software: you can redistribute it and/or modify
OptixRayTrace.h: * QES-Winds is distributed in the hope that it will be useful,
OptixRayTrace.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
OptixRayTrace.h:   * @param numSamples The probablistic sampling of per-cell launch
OptixRayTrace.h:   * @note Non-test version of AS.
PolyBuilding.cpp: * This file is part of QES-Winds
PolyBuilding.cpp: * GPL-3.0 License
PolyBuilding.cpp: * QES-Winds is free software: you can redistribute it and/or modify
PolyBuilding.cpp: * QES-Winds is distributed in the hope that it will be useful,
PolyBuilding.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
PolyBuilding.cpp:  polygonVertices = WID->buildings->SHPData->m_polygons[id];
PolyBuilding.cpp:  H = WID->buildings->SHPData->m_features[WID->buildings->shpHeightField][id] * WID->buildings->heightFactor;
PolyBuilding.cpp:  base_height = WGD->base_height[id];
PolyBuilding.cpp:  building_cent_x = 0.0;// x-coordinate of the centroid of the building
PolyBuilding.cpp:  building_cent_y = 0.0;// y-coordinate of the centroid of the building
PolyBuilding.cpp:  for (auto i = 0; i < polygonVertices.size() - 1; i++) {
PolyBuilding.cpp:  building_cent_x /= polygonVertices.size() - 1;
PolyBuilding.cpp:  building_cent_y /= polygonVertices.size() - 1;
PolyBuilding.cpp:  i_building_cent = std::round(building_cent_x / WGD->dx) - 1;// Index of building centroid in x-direction
PolyBuilding.cpp:  j_building_cent = std::round(building_cent_y / WGD->dy) - 1;// Index of building centroid in y-direction
PolyBuilding.cpp:    normal_x.resize(polygonVertices.size() - 1, 0.0);
PolyBuilding.cpp:    normal_y.resize(polygonVertices.size() - 1, 0.0);
PolyBuilding.cpp:    for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
PolyBuilding.cpp:      normal_x[id] = polygonVertices[id + 1].y_poly - polygonVertices[id].y_poly;
PolyBuilding.cpp:      normal_y[id] = polygonVertices[id].x_poly - polygonVertices[id + 1].x_poly;
PolyBuilding.cpp:      float norm = pow(normal_x[id] * normal_x[id] + normal_y[id] * normal_y[id], -0.5);
PolyBuilding.cpp:    for (size_t id = 0; id < polygonVertices.size() - 2; id++) {
PolyBuilding.cpp:      if (std::abs(scalProd) < std::abs(cos(0.5 * M_PI - tol))) {
PolyBuilding.cpp: * for building cells. It applies the Stair-step method to define building bounds.
PolyBuilding.cpp:  int mesh_type_flag = WID->simParams->meshTypeFlag;
PolyBuilding.cpp:  i_start = (x_min / WGD->dx);// Index of building start location in x-direction
PolyBuilding.cpp:  i_end = (x_max / WGD->dx) + 1;// Index of building end location in x-direction
PolyBuilding.cpp:  j_start = (y_min / WGD->dy);// Index of building start location in y-direction
PolyBuilding.cpp:  j_end = (y_max / WGD->dy) + 1;// Index of building end location in y-direction
PolyBuilding.cpp:  // Define start index of the building in z-direction
PolyBuilding.cpp:  for (auto k = 1; k < WGD->z.size(); k++) {
PolyBuilding.cpp:    if (base_height <= WGD->z_face[k]) {
PolyBuilding.cpp:  // Define end index of the building in z-direction
PolyBuilding.cpp:  for (auto k = 0; k < WGD->z.size(); k++) {
PolyBuilding.cpp:    if (height_eff < WGD->z[k + 1]) {
PolyBuilding.cpp:  // Define cut end index of the building in z-direction
PolyBuilding.cpp:  for (auto k = 0; k < WGD->z.size(); k++) {
PolyBuilding.cpp:    if (height_eff <= WGD->z_face[k + 1]) {
PolyBuilding.cpp:  // Based on Wm. Randolph Franklin, "PNPOLY - Point Inclusion in Polygon Test"
PolyBuilding.cpp:    y_cent = (j + 0.5) * WGD->dy;// Center of cell y coordinate
PolyBuilding.cpp:      x_cent = (i + 0.5) * WGD->dx;// Center of cell x coordinate
PolyBuilding.cpp:      while (vert_id < polygonVertices.size() - 1) {
PolyBuilding.cpp:          ray_intersect = (y_cent - polygonVertices[vert_id].y_poly) / (polygonVertices[vert_id + 1].y_poly - polygonVertices[vert_id].y_poly);
PolyBuilding.cpp:          if (x_cent < (polygonVertices[vert_id].x_poly + ray_intersect * (polygonVertices[vert_id + 1].x_poly - polygonVertices[vert_id].x_poly))) {
PolyBuilding.cpp:          int icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolyBuilding.cpp:          if (WID->simParams->readCoefficientsFlag == 0) {
PolyBuilding.cpp:            WGD->icellflag[icell_cent] = 0;
PolyBuilding.cpp:          WGD->ibuilding_flag[icell_cent] = building_number;
PolyBuilding.cpp:        WGD->icellflag_footprint[i + j * (WGD->nx - 1)] = 0;
PolyBuilding.cpp:  if (mesh_type_flag == 1 && WID->simParams->readCoefficientsFlag == 0)// Cut-cell method for buildings
PolyBuilding.cpp:    for (auto id = 0; id < polygonVertices.size() - 1; id++) {
PolyBuilding.cpp:      i_face_start[id] = (x_min_face[id] / WGD->dx) - 1;
PolyBuilding.cpp:      i_face_end[id] = std::floor(x_max_face[id] / WGD->dx);
PolyBuilding.cpp:      j_face_start[id] = (y_min_face[id] / WGD->dy) - 1;
PolyBuilding.cpp:      j_face_end[id] = std::floor(y_max_face[id] / WGD->dy);
PolyBuilding.cpp:        slope[id] = (polygonVertices[id + 1].y_poly - polygonVertices[id].y_poly) / (polygonVertices[id + 1].x_poly - polygonVertices[id].x_poly);
PolyBuilding.cpp:        slope[id] = (polygonVertices[id + 1].y_poly - polygonVertices[id].y_poly) / (polygonVertices[id + 1].x_poly - polygonVertices[id].x_poly + 0.000001);
PolyBuilding.cpp:    for (auto id = 0; id < polygonVertices.size() - 1; id++) {
PolyBuilding.cpp:          x1i = i * WGD->dx;
PolyBuilding.cpp:          x2i = (i + 1) * WGD->dx;
PolyBuilding.cpp:          y1j = j * WGD->dy;
PolyBuilding.cpp:          y2j = (j + 1) * WGD->dy;
PolyBuilding.cpp:          i_face_first[id] = polygonVertices[id].x_poly / WGD->dx;
PolyBuilding.cpp:          j_face_first[id] = polygonVertices[id].y_poly / WGD->dy;
PolyBuilding.cpp:          i_face_second[id] = polygonVertices[id + 1].x_poly / WGD->dx;
PolyBuilding.cpp:          j_face_second[id] = polygonVertices[id + 1].y_poly / WGD->dy;
PolyBuilding.cpp:              y1i_intersect = slope[id] * (x1i - polygonVertices[id].x_poly) + polygonVertices[id].y_poly;
PolyBuilding.cpp:              y1i_intersect = slope[id] * (x2i - polygonVertices[id].x_poly) + polygonVertices[id].y_poly;
PolyBuilding.cpp:              x1j_intersect = ((y1j - polygonVertices[id].y_poly) / slope[id]) + polygonVertices[id].x_poly;
PolyBuilding.cpp:              x1j_intersect = ((y2j - polygonVertices[id].y_poly) / slope[id]) + polygonVertices[id].x_poly;
PolyBuilding.cpp:            index_next = (id + 1) % (polygonVertices.size() - 1);// Index of next face
PolyBuilding.cpp:              y2i_intersect = slope[index_next] * (x1i - polygonVertices[index_next].x_poly) + polygonVertices[index_next].y_poly;
PolyBuilding.cpp:              y2i_intersect = slope[index_next] * (x2i - polygonVertices[index_next].x_poly) + polygonVertices[index_next].y_poly;
PolyBuilding.cpp:              x2j_intersect = ((y1j - polygonVertices[index_next].y_poly) / slope[index_next]) + polygonVertices[index_next].x_poly;
PolyBuilding.cpp:              x2j_intersect = ((y2j - polygonVertices[index_next].y_poly) / slope[index_next]) + polygonVertices[index_next].x_poly;
PolyBuilding.cpp:            while (x2i >= polygonVertices[index_next + 1].x_poly && x1i <= polygonVertices[index_next + 1].x_poly && count != polygonVertices.size() - 2 && y2j >= polygonVertices[index_next + 1].y_poly && y1j <= polygonVertices[index_next + 1].y_poly && index_next != polygonVertices.size() - 1) {
PolyBuilding.cpp:              index_next = (index_next + 1) % (polygonVertices.size() - 1);
PolyBuilding.cpp:                y2i_intersect = slope[index_next] * (x1i - polygonVertices[index_next].x_poly) + polygonVertices[index_next].y_poly;
PolyBuilding.cpp:                y2i_intersect = slope[index_next] * (x2i - polygonVertices[index_next].x_poly) + polygonVertices[index_next].y_poly;
PolyBuilding.cpp:                x2j_intersect = ((y1j - polygonVertices[index_next].y_poly) / slope[index_next]) + polygonVertices[index_next].x_poly;
PolyBuilding.cpp:                x2j_intersect = ((y2j - polygonVertices[index_next].y_poly) / slope[index_next]) + polygonVertices[index_next].x_poly;
PolyBuilding.cpp:              icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolyBuilding.cpp:              if (WGD->icellflag[icell_cent] == 8 || WGD->icellflag[icell_cent] == 0) {
PolyBuilding.cpp:                WGD->terrain_volume_frac[icell_cent] = 1.0;
PolyBuilding.cpp:                WGD->e[icell_cent] = 1.0;
PolyBuilding.cpp:                WGD->f[icell_cent] = 1.0;
PolyBuilding.cpp:                WGD->g[icell_cent] = 1.0;
PolyBuilding.cpp:                WGD->h[icell_cent] = 1.0;
PolyBuilding.cpp:                WGD->m[icell_cent] = 1.0;
PolyBuilding.cpp:                WGD->n[icell_cent] = 1.0;
PolyBuilding.cpp:              if (WGD->icellflag[icell_cent] != 2) {
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] != 7) {
PolyBuilding.cpp:                  WGD->icellflag[icell_cent] = 7;
PolyBuilding.cpp:                  counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                    counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:              if (WGD->icellflag[icell_cent] == 7) {
PolyBuilding.cpp:                cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                  if (height_eff - WGD->z_face[k_cut_end - 1] < WGD->dz_array[k]) {
PolyBuilding.cpp:                    cut_points[counter].z_solid = height_eff - WGD->z_face[k_cut_end - 1];
PolyBuilding.cpp:                  cut_points[counter].intersect.push_back(cutVert(face_intersect[ii].x_cut - i * WGD->dx, face_intersect[ii].y_cut - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert(face_intersect[ii].x_cut - i * WGD->dx, face_intersect[ii].y_cut - j * WGD->dy, 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert(face_intersect[ii].x_cut - i * WGD->dx, face_intersect[ii].y_cut - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_behind.push_back(cutVert(face_intersect[ii].x_cut - i * WGD->dx, face_intersect[ii].y_cut - j * WGD->dy, 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_behind.push_back(cutVert(face_intersect[ii].x_cut - i * WGD->dx, face_intersect[ii].y_cut - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_front.push_back(cutVert(face_intersect[ii].x_cut - i * WGD->dx, face_intersect[ii].y_cut - j * WGD->dy, 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_front.push_back(cutVert(face_intersect[ii].x_cut - i * WGD->dx, face_intersect[ii].y_cut - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_right.push_back(cutVert(face_intersect[ii].x_cut - i * WGD->dx, face_intersect[ii].y_cut - j * WGD->dy, 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_right.push_back(cutVert(face_intersect[ii].x_cut - i * WGD->dx, face_intersect[ii].y_cut - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_left.push_back(cutVert(face_intersect[ii].x_cut - i * WGD->dx, face_intersect[ii].y_cut - j * WGD->dy, 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_left.push_back(cutVert(face_intersect[ii].x_cut - i * WGD->dx, face_intersect[ii].y_cut - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert(x1i_intersect - i * WGD->dx, y1i_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert(x2i_intersect - i * WGD->dx, y2i_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert(x1i_intersect - i * WGD->dx, y1i_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert(x2i_intersect - i * WGD->dx, y2i_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_behind.push_back(cutVert(x1i_intersect - i * WGD->dx, y1i_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_behind.push_back(cutVert(x2i_intersect - i * WGD->dx, y2i_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_behind.push_back(cutVert(x1i_intersect - i * WGD->dx, y1i_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_behind.push_back(cutVert(x2i_intersect - i * WGD->dx, y2i_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert(x1i_intersect - i * WGD->dx, y1i_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert(x2i_intersect - i * WGD->dx, y2i_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert(x1i_intersect - i * WGD->dx, y1i_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert(x2i_intersect - i * WGD->dx, y2i_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_front.push_back(cutVert(x1i_intersect - i * WGD->dx, y1i_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_front.push_back(cutVert(x2i_intersect - i * WGD->dx, y2i_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_front.push_back(cutVert(x1i_intersect - i * WGD->dx, y1i_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_front.push_back(cutVert(x2i_intersect - i * WGD->dx, y2i_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert(x1j_intersect - i * WGD->dx, y1j_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert(x2j_intersect - i * WGD->dx, y2j_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert(x1j_intersect - i * WGD->dx, y1j_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert(x2j_intersect - i * WGD->dx, y2j_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_right.push_back(cutVert(x1j_intersect - i * WGD->dx, y1j_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_right.push_back(cutVert(x2j_intersect - i * WGD->dx, y2j_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_right.push_back(cutVert(x1j_intersect - i * WGD->dx, y1j_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_right.push_back(cutVert(x2j_intersect - i * WGD->dx, y2j_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert(x1j_intersect - i * WGD->dx, y1j_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert(x2j_intersect - i * WGD->dx, y2j_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert(x1j_intersect - i * WGD->dx, y1j_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert(x2j_intersect - i * WGD->dx, y2j_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_left.push_back(cutVert(x1j_intersect - i * WGD->dx, y1j_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_left.push_back(cutVert(x2j_intersect - i * WGD->dx, y2j_intersect - j * WGD->dy, 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_left.push_back(cutVert(x1j_intersect - i * WGD->dx, y1j_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_left.push_back(cutVert(x2j_intersect - i * WGD->dx, y2j_intersect - j * WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:                    y2i = (j - 1) * WGD->dy;
PolyBuilding.cpp:                    y2i = (j + 2) * WGD->dy;
PolyBuilding.cpp:                    y1i = (j - 1) * WGD->dy;
PolyBuilding.cpp:                    y1i = (j + 2) * WGD->dy;
PolyBuilding.cpp:                    y2i = (j - 1) * WGD->dy;
PolyBuilding.cpp:                    y2i = (j + 2) * WGD->dy;
PolyBuilding.cpp:                    y1i = (j - 1) * WGD->dy;
PolyBuilding.cpp:                    y1i = (j + 2) * WGD->dy;
PolyBuilding.cpp:                y1i = (j - 1) * WGD->dy;
PolyBuilding.cpp:                y2i = (j + 2) * WGD->dy;
PolyBuilding.cpp:                y2i = (j - 1) * WGD->dy;
PolyBuilding.cpp:                y1i = (j + 2) * WGD->dy;
PolyBuilding.cpp:              y1i = slope[id] * (x1i - polygonVertices[id].x_poly) + polygonVertices[id].y_poly;
PolyBuilding.cpp:              y2i = slope[id] * (x2i - polygonVertices[id].x_poly) + polygonVertices[id].y_poly;
PolyBuilding.cpp:              x1j = ((y1j - polygonVertices[id].y_poly) / slope[id]) + polygonVertices[id].x_poly;
PolyBuilding.cpp:              x2j = ((y2j - polygonVertices[id].y_poly) / slope[id]) + polygonVertices[id].x_poly;
PolyBuilding.cpp:          if (y1i > j * WGD->dy && y1i < (j + 1) * WGD->dy && x1i != x2i) {
PolyBuilding.cpp:            if (y2i >= j * WGD->dy && y2i <= (j + 1) * WGD->dy) {
PolyBuilding.cpp:                icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 8 || WGD->icellflag[icell_cent] == 0) {
PolyBuilding.cpp:                  WGD->terrain_volume_frac[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->e[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->f[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->g[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->h[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->m[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->n[icell_cent] = 1.0;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] != 2) {
PolyBuilding.cpp:                  if (WGD->icellflag[icell_cent] != 7) {
PolyBuilding.cpp:                    WGD->icellflag[icell_cent] = 7;
PolyBuilding.cpp:                    counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                      counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 7) {
PolyBuilding.cpp:                  cut_points[counter].intersect.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  /*if ( ((WGD->icellflag[icell_cent-(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                     ((WGD->icellflag[icell_cent-(WGD->nx-1)-1] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)-1] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)-1] == building_number) ||
PolyBuilding.cpp:                     ((WGD->icellflag[icell_cent-(WGD->nx-1)+1] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)+1] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)+1] == building_number))
PolyBuilding.cpp:                  cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                    if (height_eff - WGD->z_face[k_cut_end - 1] < WGD->dz_array[k]) {
PolyBuilding.cpp:                      cut_points[counter].z_solid = height_eff - WGD->z_face[k_cut_end - 1];
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_behind.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_behind.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_front.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_front.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent+(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+(WGD->nx-1)-1] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)-1] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)-1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+(WGD->nx-1)+1] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)+1] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)+1] == building_number))
PolyBuilding.cpp:                    cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                      if ( height_eff-WGD->z_face[k_cut_end-1] < WGD->dz_array[k])
PolyBuilding.cpp:                        cut_points[counter].z_solid = height_eff-WGD->z_face[k_cut_end-1];
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:            else if (y2i < j * WGD->dy) {
PolyBuilding.cpp:                icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 8 || WGD->icellflag[icell_cent] == 0) {
PolyBuilding.cpp:                  WGD->terrain_volume_frac[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->e[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->f[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->g[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->h[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->m[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->n[icell_cent] = 1.0;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] != 2) {
PolyBuilding.cpp:                  if (WGD->icellflag[icell_cent] != 7) {
PolyBuilding.cpp:                    WGD->icellflag[icell_cent] = 7;
PolyBuilding.cpp:                    counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                      counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 7) {
PolyBuilding.cpp:                  cut_points[counter].intersect.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent-(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-1] == 0 || WGD->icellflag[icell_cent-1] == 7) && WGD->ibuilding_flag[icell_cent-1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-(WGD->nx-1)-1] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)-1] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)-1] == building_number))
PolyBuilding.cpp:                  cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                    if (height_eff - WGD->z_face[k_cut_end - 1] < WGD->dz_array[k]) {
PolyBuilding.cpp:                      cut_points[counter].z_solid = height_eff - WGD->z_face[k_cut_end - 1];
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_right.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_right.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_behind.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_behind.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent+(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)] == building_number ) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+1] == 0 || WGD->icellflag[icell_cent+1] == 7) && WGD->ibuilding_flag[icell_cent+1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+(WGD->nx-1)+1] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)+1] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)+1] == building_number))
PolyBuilding.cpp:                    cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                      if ( height_eff-WGD->z_face[k_cut_end-1] < WGD->dz_array[k])
PolyBuilding.cpp:                        cut_points[counter].z_solid = height_eff-WGD->z_face[k_cut_end-1];
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_right.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_right.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:            else if (y2i > (j + 1) * WGD->dy) {
PolyBuilding.cpp:                icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 8 || WGD->icellflag[icell_cent] == 0) {
PolyBuilding.cpp:                  WGD->terrain_volume_frac[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->e[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->f[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->g[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->h[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->m[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->n[icell_cent] = 1.0;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] != 2) {
PolyBuilding.cpp:                  if (WGD->icellflag[icell_cent] != 7) {
PolyBuilding.cpp:                    WGD->icellflag[icell_cent] = 7;
PolyBuilding.cpp:                    counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                      counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 7) {
PolyBuilding.cpp:                  cut_points[counter].intersect.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent+(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)] == building_number)  ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-1] == 0 || WGD->icellflag[icell_cent-1] == 7) && WGD->ibuilding_flag[icell_cent-1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+(WGD->nx-1)-1] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)-1] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)-1] == building_number))
PolyBuilding.cpp:                  cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                    if (height_eff - WGD->z_face[k_cut_end - 1] < WGD->dz_array[k]) {
PolyBuilding.cpp:                      cut_points[counter].z_solid = height_eff - WGD->z_face[k_cut_end - 1];
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_left.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_left.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_behind.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_behind.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent-(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+1] == 0 || WGD->icellflag[icell_cent+1] == 7) && WGD->ibuilding_flag[icell_cent+1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-(WGD->nx-1)+1] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)+1] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)+1] == building_number))
PolyBuilding.cpp:                    cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                      if ( height_eff-WGD->z_face[k_cut_end-1] < WGD->dz_array[k])
PolyBuilding.cpp:                        cut_points[counter].z_solid = height_eff-WGD->z_face[k_cut_end-1];
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_behind.push_back(cutVert((x1i-i*WGD->dx), (y1i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_left.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_left.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:          if (y2i > j * WGD->dy && y2i < (j + 1) * WGD->dy && x1i != x2i) {
PolyBuilding.cpp:            if (y1i <= j * WGD->dy) {
PolyBuilding.cpp:                icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 8 || WGD->icellflag[icell_cent] == 0) {
PolyBuilding.cpp:                  WGD->terrain_volume_frac[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->e[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->f[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->g[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->h[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->m[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->n[icell_cent] = 1.0;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] != 2) {
PolyBuilding.cpp:                  if (WGD->icellflag[icell_cent] != 7) {
PolyBuilding.cpp:                    WGD->icellflag[icell_cent] = 7;
PolyBuilding.cpp:                    counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                      counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 7) {
PolyBuilding.cpp:                  cut_points[counter].intersect.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent-(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+1] == 0 || WGD->icellflag[icell_cent+1] == 7) && WGD->ibuilding_flag[icell_cent+1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-(WGD->nx-1)+1] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)+1] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)+1] == building_number))
PolyBuilding.cpp:                    if (y1i == j*WGD->dy)
PolyBuilding.cpp:                  cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                    if (height_eff - WGD->z_face[k_cut_end - 1] < WGD->dz_array[k]) {
PolyBuilding.cpp:                      cut_points[counter].z_solid = height_eff - WGD->z_face[k_cut_end - 1];
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_right.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_right.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_front.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_front.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent+(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-1] == 0 || WGD->icellflag[icell_cent-1] == 7) && WGD->ibuilding_flag[icell_cent-1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+(WGD->nx-1)-1] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)-1] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)-1] == building_number))
PolyBuilding.cpp:                    if (y1i == j*WGD->dy)
PolyBuilding.cpp:                    cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                      if ( height_eff-WGD->z_face[k_cut_end-1] < WGD->dz_array[k])
PolyBuilding.cpp:                        cut_points[counter].z_solid = height_eff-WGD->z_face[k_cut_end-1];
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_right.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_right.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:            if (y1i >= (j + 1) * WGD->dy) {
PolyBuilding.cpp:                icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 8 || WGD->icellflag[icell_cent] == 0) {
PolyBuilding.cpp:                  WGD->terrain_volume_frac[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->e[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->f[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->g[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->h[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->m[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->n[icell_cent] = 1.0;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] != 2) {
PolyBuilding.cpp:                  if (WGD->icellflag[icell_cent] != 7) {
PolyBuilding.cpp:                    WGD->icellflag[icell_cent] = 7;
PolyBuilding.cpp:                    counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                      counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 7) {
PolyBuilding.cpp:                  cut_points[counter].intersect.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent+(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+1] == 0 || WGD->icellflag[icell_cent+1] == 7) && WGD->ibuilding_flag[icell_cent+1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+(WGD->nx-1)+1] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)+1] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)+1] == building_number))
PolyBuilding.cpp:                    if (y1i == (j+1)*WGD->dy)
PolyBuilding.cpp:                  cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                    if (height_eff - WGD->z_face[k_cut_end - 1] < WGD->dz_array[k]) {
PolyBuilding.cpp:                      cut_points[counter].z_solid = height_eff - WGD->z_face[k_cut_end - 1];
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_left.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_left.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_front.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_front.push_back(cutVert((x2i - i * WGD->dx), (y2i - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent-(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-1] == 0 || WGD->icellflag[icell_cent-1] == 7) && WGD->ibuilding_flag[icell_cent-1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-(WGD->nx-1)-1] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)-1] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)-1] == building_number))
PolyBuilding.cpp:                    if (y1i == (j+1)*WGD->dy)
PolyBuilding.cpp:                    cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                      if ( height_eff-WGD->z_face[k_cut_end-1] < WGD->dz_array[k])
PolyBuilding.cpp:                        cut_points[counter].z_solid = height_eff-WGD->z_face[k_cut_end-1];
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_left.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_left.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_front.push_back(cutVert((x2i-i*WGD->dx), (y2i-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:          if (y1i == j * WGD->dy && y2i == (j + 1) * WGD->dy && x1i != x2i) {
PolyBuilding.cpp:            if (x1j == i * WGD->dx && x2j == (i + 1) * WGD->dx) {
PolyBuilding.cpp:                icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 8 || WGD->icellflag[icell_cent] == 0) {
PolyBuilding.cpp:                  WGD->terrain_volume_frac[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->e[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->f[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->g[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->h[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->m[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->n[icell_cent] = 1.0;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] != 2) {
PolyBuilding.cpp:                  if (WGD->icellflag[icell_cent] != 7) {
PolyBuilding.cpp:                    WGD->icellflag[icell_cent] = 7;
PolyBuilding.cpp:                    counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                      counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 7) {
PolyBuilding.cpp:                  cut_points[counter].intersect.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent-(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+1] == 0 || WGD->icellflag[icell_cent+1] == 7) && WGD->ibuilding_flag[icell_cent+1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-(WGD->nx-1)+1] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)+1] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)+1] == building_number))
PolyBuilding.cpp:                    cut_points[counter].z_solid = WGD->dz_array[k];*/
PolyBuilding.cpp:                    if (height_eff - WGD->z_face[k_cut_end - 1] < WGD->dz_array[k]) {
PolyBuilding.cpp:                      cut_points[counter].z_solid = height_eff - WGD->z_face[k_cut_end - 1];
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent+(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-1] == 0 || WGD->icellflag[icell_cent-1] == 7) && WGD->ibuilding_flag[icell_cent-1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+(WGD->nx-1)-1] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)-1] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)-1] == building_number))
PolyBuilding.cpp:                    cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                      if ( height_eff-WGD->z_face[k_cut_end-1] < WGD->dz_array[k])
PolyBuilding.cpp:                        cut_points[counter].z_solid = height_eff-WGD->z_face[k_cut_end-1];
PolyBuilding.cpp:          if (y1i == (j + 1) * WGD->dy && y2i == j * WGD->dy && x1i != x2i) {
PolyBuilding.cpp:            if (x1j == (i + 1) * WGD->dx && x2j == i * WGD->dx) {
PolyBuilding.cpp:                icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 8 || WGD->icellflag[icell_cent] == 0) {
PolyBuilding.cpp:                  WGD->terrain_volume_frac[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->e[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->f[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->g[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->h[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->m[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->n[icell_cent] = 1.0;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] != 2) {
PolyBuilding.cpp:                  if (WGD->icellflag[icell_cent] != 7) {
PolyBuilding.cpp:                    WGD->icellflag[icell_cent] = 7;
PolyBuilding.cpp:                    counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                      counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 7) {
PolyBuilding.cpp:                  cut_points[counter].intersect.push_back(cutVert((x1i - i * WGD->dx), (y1i - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent-(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-1] == 0 || WGD->icellflag[icell_cent-1] == 7) && WGD->ibuilding_flag[icell_cent-1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-(WGD->nx-1)-1] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)-1] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)-1] == building_number))
PolyBuilding.cpp:                    cut_points[counter].z_solid = WGD->dz_array[k];*/
PolyBuilding.cpp:                    if (height_eff - WGD->z_face[k_cut_end - 1] < WGD->dz_array[k]) {
PolyBuilding.cpp:                      cut_points[counter].z_solid = height_eff - WGD->z_face[k_cut_end - 1];
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent+(WGD->nx-1)] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+1] == 0 || WGD->icellflag[icell_cent+1] == 7) && WGD->ibuilding_flag[icell_cent+1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+(WGD->nx-1)+1] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)+1] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)+1] == building_number))
PolyBuilding.cpp:                    cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                      if ( height_eff-WGD->z_face[k_cut_end-1] < WGD->dz_array[k])
PolyBuilding.cpp:                        cut_points[counter].z_solid = height_eff-WGD->z_face[k_cut_end-1];
PolyBuilding.cpp:          if ((y1i > (j + 1) * WGD->dy || y1i < j * WGD->dy) && (y2i > (j + 1) * WGD->dy || y2i < j * WGD->dy)) {
PolyBuilding.cpp:            if (x1j > i * WGD->dx && x1j < (i + 1) * WGD->dx && x2j > i * WGD->dx && x2j < (i + 1) * WGD->dx) {
PolyBuilding.cpp:                icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 8 || WGD->icellflag[icell_cent] == 0) {
PolyBuilding.cpp:                  WGD->terrain_volume_frac[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->e[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->f[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->g[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->h[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->m[icell_cent] = 1.0;
PolyBuilding.cpp:                  WGD->n[icell_cent] = 1.0;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] != 2) {
PolyBuilding.cpp:                  if (WGD->icellflag[icell_cent] != 7) {
PolyBuilding.cpp:                    WGD->icellflag[icell_cent] = 7;
PolyBuilding.cpp:                    counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                      counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                if (WGD->icellflag[icell_cent] == 7) {
PolyBuilding.cpp:                  cut_points[counter].intersect.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent-1] == 0 || WGD->icellflag[icell_cent-1] == 7) && WGD->ibuilding_flag[icell_cent-1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-(WGD->nx-1)-1] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)-1] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)-1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+(WGD->nx-1)-1] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)-1] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)-1] == building_number))
PolyBuilding.cpp:                  cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                    if (height_eff - WGD->z_face[k_cut_end - 1] < WGD->dz_array[k]) {
PolyBuilding.cpp:                      cut_points[counter].z_solid = height_eff - WGD->z_face[k_cut_end - 1];
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_below.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_above.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_right.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_right.push_back(cutVert((x1j - i * WGD->dx), (y1j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  cut_points[counter].face_left.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), 0.0));
PolyBuilding.cpp:                  cut_points[counter].face_left.push_back(cutVert((x2j - i * WGD->dx), (y2j - j * WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_right.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_right.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                    cut_points[counter].face_left.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_left.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                  /*if (((WGD->icellflag[icell_cent+1] == 0 || WGD->icellflag[icell_cent+1] == 7) && WGD->ibuilding_flag[icell_cent+1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent-(WGD->nx-1)+1] == 0 || WGD->icellflag[icell_cent-(WGD->nx-1)+1] == 7) && WGD->ibuilding_flag[icell_cent-(WGD->nx-1)+1] == building_number) ||
PolyBuilding.cpp:                      ((WGD->icellflag[icell_cent+(WGD->nx-1)+1] == 0 || WGD->icellflag[icell_cent+(WGD->nx-1)+1] == 7) && WGD->ibuilding_flag[icell_cent+(WGD->nx-1)+1] == building_number))
PolyBuilding.cpp:                    cut_points[counter].z_solid = WGD->dz_array[k];
PolyBuilding.cpp:                      if ( height_eff-WGD->z_face[k_cut_end-1] < WGD->dz_array[k])
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                    cut_points[counter].face_below.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_above.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_right.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_right.push_back(cutVert((x1j-i*WGD->dx), (y1j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:                      cut_points[counter].face_left.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), 0.0));
PolyBuilding.cpp:                      cut_points[counter].face_left.push_back(cutVert((x2j-i*WGD->dx), (y2j-j*WGD->dy), cut_points[counter].z_solid));
PolyBuilding.cpp:        int k = cut_cell_id[id] / ((WGD->nx - 1) * (WGD->ny - 1));
PolyBuilding.cpp:        int j = (cut_cell_id[id] - k * (WGD->nx - 1) * (WGD->ny - 1)) / (WGD->nx - 1);
PolyBuilding.cpp:        int i = cut_cell_id[id] - k * (WGD->nx - 1) * (WGD->ny - 1) - j * (WGD->nx - 1);
PolyBuilding.cpp:          y_face = (j + jj) * WGD->dy;// Center of cell y coordinate
PolyBuilding.cpp:            x_face = (i + ii) * WGD->dx;// Center of cell x coordinate
PolyBuilding.cpp:            while (vert_id < polygonVertices.size() - 1) {
PolyBuilding.cpp:                ray_intersect = (y_face - polygonVertices[vert_id].y_poly) / (polygonVertices[vert_id + 1].y_poly - polygonVertices[vert_id].y_poly);
PolyBuilding.cpp:                if (x_face < (polygonVertices[vert_id].x_poly + ray_intersect * (polygonVertices[vert_id + 1].x_poly - polygonVertices[vert_id].x_poly))) {
PolyBuilding.cpp:                cut_points[id].face_below.push_back(cutVert(0.0, WGD->dy, 0.0));
PolyBuilding.cpp:                cut_points[id].face_behind.push_back(cutVert(0.0, WGD->dy, 0.0));
PolyBuilding.cpp:                cut_points[id].face_behind.push_back(cutVert(0.0, WGD->dy, cut_points[id].z_solid));
PolyBuilding.cpp:                cut_points[id].face_left.push_back(cutVert(0.0, WGD->dy, 0.0));
PolyBuilding.cpp:                cut_points[id].face_left.push_back(cutVert(0.0, WGD->dy, cut_points[id].z_solid));
PolyBuilding.cpp:                  cut_points[id].face_above.push_back(cutVert(0.0, WGD->dy, cut_points[id].z_solid));
PolyBuilding.cpp:                cut_points[id].face_below.push_back(cutVert(WGD->dx, WGD->dy, 0.0));
PolyBuilding.cpp:                cut_points[id].face_front.push_back(cutVert(WGD->dx, WGD->dy, 0.0));
PolyBuilding.cpp:                cut_points[id].face_front.push_back(cutVert(WGD->dx, WGD->dy, cut_points[id].z_solid));
PolyBuilding.cpp:                cut_points[id].face_left.push_back(cutVert(WGD->dx, WGD->dy, 0.0));
PolyBuilding.cpp:                cut_points[id].face_left.push_back(cutVert(WGD->dx, WGD->dy, cut_points[id].z_solid));
PolyBuilding.cpp:                  cut_points[id].face_above.push_back(cutVert(WGD->dx, WGD->dy, cut_points[id].z_solid));
PolyBuilding.cpp:                cut_points[id].face_below.push_back(cutVert(WGD->dx, 0.0, 0.0));
PolyBuilding.cpp:                cut_points[id].face_front.push_back(cutVert(WGD->dx, 0.0, 0.0));
PolyBuilding.cpp:                cut_points[id].face_front.push_back(cutVert(WGD->dx, 0.0, cut_points[id].z_solid));
PolyBuilding.cpp:                cut_points[id].face_right.push_back(cutVert(WGD->dx, 0.0, 0.0));
PolyBuilding.cpp:                cut_points[id].face_right.push_back(cutVert(WGD->dx, 0.0, cut_points[id].z_solid));
PolyBuilding.cpp:                  cut_points[id].face_above.push_back(cutVert(WGD->dx, 0.0, cut_points[id].z_solid));
PolyBuilding.cpp:    if (height_eff - WGD->z_face[k - 1] < WGD->dz_array[k]) {
PolyBuilding.cpp:          icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolyBuilding.cpp:          if (WGD->icellflag[icell_cent - (WGD->nx - 1) * (WGD->ny - 1)] == 0 && WGD->icellflag[icell_cent - (WGD->nx - 1) * (WGD->ny - 1)] != 7 && WGD->ibuilding_flag[icell_cent - (WGD->nx - 1) * (WGD->ny - 1)] == building_number) {
PolyBuilding.cpp:            if (WGD->icellflag[icell_cent] != 7) {
PolyBuilding.cpp:              WGD->icellflag[icell_cent] = 7;
PolyBuilding.cpp:              counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:                counter = cut_cell_id.size() - 1;
PolyBuilding.cpp:            cut_points[counter].z_solid = height_eff - WGD->z_face[k - 1];
PolyBuilding.cpp:            if (WGD->icellflag[icell_cent] == 7) {
PolyBuilding.cpp:              cut_points[counter].intersect.push_back(cutVert(WGD->dx, WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:              cut_points[counter].face_below.push_back(cutVert(0.0, WGD->dy, 0.0));
PolyBuilding.cpp:              cut_points[counter].face_below.push_back(cutVert(WGD->dx, 0.0, 0.0));
PolyBuilding.cpp:              cut_points[counter].face_below.push_back(cutVert(WGD->dx, WGD->dy, 0.0));
PolyBuilding.cpp:              cut_points[counter].face_behind.push_back(cutVert(0.0, WGD->dy, 0.0));
PolyBuilding.cpp:              cut_points[counter].face_behind.push_back(cutVert(0.0, WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:              cut_points[counter].face_front.push_back(cutVert(WGD->dx, 0.0, 0.0));
PolyBuilding.cpp:              cut_points[counter].face_front.push_back(cutVert(WGD->dx, WGD->dy, 0.0));
PolyBuilding.cpp:              cut_points[counter].face_front.push_back(cutVert(WGD->dx, 0.0, cut_points[counter].z_solid));
PolyBuilding.cpp:              cut_points[counter].face_front.push_back(cutVert(WGD->dx, WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:              cut_points[counter].face_right.push_back(cutVert(WGD->dx, 0.0, 0.0));
PolyBuilding.cpp:              cut_points[counter].face_right.push_back(cutVert(WGD->dx, 0.0, cut_points[counter].z_solid));
PolyBuilding.cpp:              cut_points[counter].face_left.push_back(cutVert(0.0, WGD->dy, 0.0));
PolyBuilding.cpp:              cut_points[counter].face_left.push_back(cutVert(WGD->dx, WGD->dy, 0.0));
PolyBuilding.cpp:              cut_points[counter].face_left.push_back(cutVert(0.0, WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:              cut_points[counter].face_left.push_back(cutVert(WGD->dx, WGD->dy, cut_points[counter].z_solid));
PolyBuilding.cpp:        int k = cut_cell_id[id] / ((WGD->nx - 1) * (WGD->ny - 1));
PolyBuilding.cpp:        int j = (cut_cell_id[id] - k * (WGD->nx - 1) * (WGD->ny - 1)) / (WGD->nx - 1);
PolyBuilding.cpp:        int i = cut_cell_id[id] - k * (WGD->nx - 1) * (WGD->ny - 1) - j * (WGD->nx - 1);
PolyBuilding.cpp:        S_cut = sqrt(pow(cut_points[id].s_behind - cut_points[id].s_front, 2.0) + pow(cut_points[id].s_right - cut_points[id].s_left, 2.0)
PolyBuilding.cpp:                     + pow(cut_points[id].s_below - cut_points[id].s_above, 2.0));
PolyBuilding.cpp:          cut_points[id].ni = (cut_points[id].s_behind - cut_points[id].s_front) / S_cut;
PolyBuilding.cpp:          cut_points[id].nj = (cut_points[id].s_right - cut_points[id].s_left) / S_cut;
PolyBuilding.cpp:          cut_points[id].nk = (cut_points[id].s_below - cut_points[id].s_above) / S_cut;
PolyBuilding.cpp:          solid_V_frac += (cut_points[id].face_behind[0].x_cut * (-1) * cut_points[id].s_behind) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
PolyBuilding.cpp:          solid_V_frac += (cut_points[id].face_front[0].x_cut * (1) * cut_points[id].s_front) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
PolyBuilding.cpp:          solid_V_frac += (cut_points[id].face_right[0].y_cut * (-1) * cut_points[id].s_right) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
PolyBuilding.cpp:          solid_V_frac += (cut_points[id].face_left[0].y_cut * (1) * cut_points[id].s_left) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
PolyBuilding.cpp:          solid_V_frac += (cut_points[id].face_below[0].z_cut * (-1) * cut_points[id].s_below) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
PolyBuilding.cpp:          solid_V_frac += (cut_points[id].face_above[0].z_cut * (1) * cut_points[id].s_above) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
PolyBuilding.cpp:        solid_V_frac += ((cut_points[id].intersect[0].x_cut * (cut_points[id].ni) * S_cut) + (cut_points[id].intersect[0].y_cut * (cut_points[id].nj) * S_cut) + (cut_points[id].intersect[0].z_cut * (cut_points[id].nk) * S_cut)) / (3 * WGD->dx * WGD->dy * WGD->dz_array[k]);
PolyBuilding.cpp:        WGD->building_volume_frac[cut_cell_id[id]] -= solid_V_frac;
PolyBuilding.cpp:        WGD->ni[cut_cell_id[id]] = cut_points[id].ni;
PolyBuilding.cpp:        WGD->nj[cut_cell_id[id]] = cut_points[id].nj;
PolyBuilding.cpp:        WGD->nk[cut_cell_id[id]] = cut_points[id].nk;
PolyBuilding.cpp:        if (WGD->building_volume_frac[cut_cell_id[id]] < 0.0) {
PolyBuilding.cpp:          WGD->building_volume_frac[cut_cell_id[id]] = 0.0;
PolyBuilding.cpp:      angle[i] = (180 / M_PI) * atan2((face_points[i].z_cut - centroid[2]), (face_points[i].y_cut - centroid[1]));
PolyBuilding.cpp:      angle[i] = (180 / M_PI) * atan2((face_points[i].z_cut - centroid[2]), (face_points[i].x_cut - centroid[0]));
PolyBuilding.cpp:      angle[i] = (180 / M_PI) * atan2((face_points[i].y_cut - centroid[1]), (face_points[i].x_cut - centroid[0]));
PolyBuilding.cpp:  // Call sort to sort points based on the angles (from -180 to 180)
PolyBuilding.cpp:  angleR.resize(angle.size() - angle.size() / 2);
PolyBuilding.cpp:  face_points_R.resize(face_points.size() - face_points.size() / 2);
PolyBuilding.cpp:    k = cutcell_index / ((WGD->nx - 1) * (WGD->ny - 1));
PolyBuilding.cpp:    j = (cutcell_index - k * (WGD->nx - 1) * (WGD->ny - 1)) / (WGD->nx - 1);
PolyBuilding.cpp:    i = cutcell_index - k * (WGD->nx - 1) * (WGD->ny - 1) - j * (WGD->nx - 1);
PolyBuilding.cpp:    // calculate area fraction coefficient for each face of the cut-cell
PolyBuilding.cpp:    for (int i = 0; i < face_points.size() - 1; i++) {
PolyBuilding.cpp:      coeff += (0.5 * (face_points[i + 1].y_cut + face_points[i].y_cut) * (face_points[i + 1].z_cut - face_points[i].z_cut)) / (WGD->dy * WGD->dz_array[k]) + (0.5 * (face_points[i + 1].x_cut + face_points[i].x_cut) * (face_points[i + 1].z_cut - face_points[i].z_cut)) / (WGD->dx * WGD->dz_array[k]) + (0.5 * (face_points[i + 1].x_cut + face_points[i].x_cut) * (face_points[i + 1].y_cut - face_points[i].y_cut)) / (WGD->dx * WGD->dy);
PolyBuilding.cpp:    coeff += (0.5 * (face_points[0].y_cut + face_points[face_points.size() - 1].y_cut) * (face_points[0].z_cut - face_points[face_points.size() - 1].z_cut)) / (WGD->dy * WGD->dz_array[k]) + (0.5 * (face_points[0].x_cut + face_points[face_points.size() - 1].x_cut) * (face_points[0].z_cut - face_points[face_points.size() - 1].z_cut)) / (WGD->dx * WGD->dz_array[k]) + (0.5 * (face_points[0].x_cut + face_points[face_points.size() - 1].x_cut) * (face_points[0].y_cut - face_points[face_points.size() - 1].y_cut)) / (WGD->dx * WGD->dy);
PolyBuilding.cpp:  coeff = 1.0 - coeff;
PolyBuilding.cpp:      S = (1.0 - coeff) * (WGD->dy * WGD->dz_array[k]);
PolyBuilding.cpp:      if (WGD->f[cutcell_index] == 1.0) {
PolyBuilding.cpp:        WGD->f[cutcell_index] = coeff;
PolyBuilding.cpp:        WGD->f[cutcell_index] -= (1.0 - coeff);
PolyBuilding.cpp:        if (WGD->f[cutcell_index] < 0.0) {
PolyBuilding.cpp:          WGD->f[cutcell_index] = 0.0;
PolyBuilding.cpp:      S = (1.0 - coeff) * (WGD->dy * WGD->dz_array[k]);
PolyBuilding.cpp:      if (WGD->e[cutcell_index] == 1.0) {
PolyBuilding.cpp:        WGD->e[cutcell_index] = coeff;
PolyBuilding.cpp:        WGD->e[cutcell_index] -= (1.0 - coeff);
PolyBuilding.cpp:        if (WGD->e[cutcell_index] < 0.0) {
PolyBuilding.cpp:          WGD->e[cutcell_index] = 0.0;
PolyBuilding.cpp:      S = (1.0 - coeff) * (WGD->dx * WGD->dz_array[k]);
PolyBuilding.cpp:      if (WGD->h[cutcell_index] == 1.0) {
PolyBuilding.cpp:        WGD->h[cutcell_index] = coeff;
PolyBuilding.cpp:        WGD->h[cutcell_index] -= (1.0 - coeff);
PolyBuilding.cpp:        if (WGD->h[cutcell_index] < 0.0) {
PolyBuilding.cpp:          WGD->h[cutcell_index] = 0.0;
PolyBuilding.cpp:      S = (1.0 - coeff) * (WGD->dx * WGD->dz_array[k]);
PolyBuilding.cpp:      if (WGD->g[cutcell_index] == 1.0) {
PolyBuilding.cpp:        WGD->g[cutcell_index] = coeff;
PolyBuilding.cpp:        WGD->g[cutcell_index] -= (1.0 - coeff);
PolyBuilding.cpp:        if (WGD->g[cutcell_index] < 0.0) {
PolyBuilding.cpp:          WGD->g[cutcell_index] = 0.0;
PolyBuilding.cpp:      S = (1.0 - coeff) * (WGD->dx * WGD->dy);
PolyBuilding.cpp:      if (WGD->n[cutcell_index] == 1.0) {
PolyBuilding.cpp:        WGD->n[cutcell_index] = coeff;
PolyBuilding.cpp:        WGD->n[cutcell_index] -= (1.0 - coeff);
PolyBuilding.cpp:        if (WGD->n[cutcell_index] < 0.0) {
PolyBuilding.cpp:          WGD->n[cutcell_index] = 0.0;
PolyBuilding.cpp:      S = (1.0 - coeff) * (WGD->dx * WGD->dy);
PolyBuilding.cpp:      if (WGD->m[cutcell_index] == 1.0) {
PolyBuilding.cpp:        WGD->m[cutcell_index] = coeff;
PolyBuilding.cpp:        WGD->m[cutcell_index] -= (1.0 - coeff);
PolyBuilding.cpp:        if (WGD->m[cutcell_index] < 0.0) {
PolyBuilding.cpp:          WGD->m[cutcell_index] = 0.0;
PolyBuilding.h: * This file is part of QES-Winds
PolyBuilding.h: * GPL-3.0 License
PolyBuilding.h: * QES-Winds is free software: you can redistribute it and/or modify
PolyBuilding.h: * QES-Winds is distributed in the hope that it will be useful,
PolyBuilding.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
PolyBuilding.h:   * for building cells. It applies the Stair-step method to define building bounds.
PolyBuilding.h:   * More information: "Improvements to a fast-response WINDSan wind model, M. Nelson et al. (2008)"
PolyBuilding.h:   * More information: "Improvements to a fast-response WINDSan wind model, M. Nelson et al. (2008)"
PolyBuilding.h:   * More information: "Improvements to a fast-response WINDSan wind model, M. Nelson et al. (2008)"
PolyBuilding.h:   * New model base on "Evaluation of the QUIC-URB fast response urban wind model for a cubical building 
PolyBuilding.h:   * More information: "Comprehensive Evaluation of Fast-Response, Reynolds-Averaged Navier–Stokes, and Large-Eddy Simulation
PolyBuilding.h:   * Methods Against High-Spatial-Resolution Wind-Tunnel Data in Step-Down Street Canyons, A. N. Hayati et al. (2017)"
PolygonQUICBuilding.h:    // x_start += WID->simParams->halo_x;
PolygonQUICBuilding.h:    // y_start += WID->simParams->halo_y;
PolygonQUICBuilding.h:    // setPolybuilding(WGD->nx, WGD->ny, WGD->dx, WGD->dy, WGD->u0, WGD->v0, WGD->z);
PolygonWake.cpp: * This file is part of QES-Winds
PolygonWake.cpp: * GPL-3.0 License
PolygonWake.cpp: * QES-Winds is free software: you can redistribute it and/or modify
PolygonWake.cpp: * QES-Winds is distributed in the hope that it will be useful,
PolygonWake.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
PolygonWake.cpp:  Lr_face.resize(polygonVertices.size(), -1.0);// Length of wake for each face
PolygonWake.cpp:  float epsilon = 10e-10;
PolygonWake.cpp:  //u_temp.resize(WGD->nx * WGD->ny, 0.0);
PolygonWake.cpp:  //v_temp.resize(WGD->nx * WGD->ny, 0.0);
PolygonWake.cpp:  int index_building_face = i_building_cent + j_building_cent * WGD->nx + (k_end)*WGD->nx * WGD->ny;
PolygonWake.cpp:  u0_h = WGD->u0[index_building_face];// u velocity at the height of building at the centroid
PolygonWake.cpp:  v0_h = WGD->v0[index_building_face];// v velocity at the height of building at the centroid
PolygonWake.cpp:    xi[id] = (polygonVertices[id].x_poly - building_cent_x) * cos(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * sin(upwind_dir);
PolygonWake.cpp:    yi[id] = -(polygonVertices[id].x_poly - building_cent_x) * sin(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * cos(upwind_dir);
PolygonWake.cpp:  for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
PolygonWake.cpp:    polygon_area += 0.5 * (polygonVertices[id].x_poly * polygonVertices[id + 1].y_poly - polygonVertices[id].y_poly * polygonVertices[id + 1].x_poly);
PolygonWake.cpp:  width_eff = polygon_area / (x2 - x1);// Effective width of the building
PolygonWake.cpp:  length_eff = polygon_area / (y2 - y1);// Effective length of the building
PolygonWake.cpp:  for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
PolygonWake.cpp:    upwind_rel_dir[id] = atan2(yi[id + 1] - yi[id], xi[id + 1] - xi[id]) + 0.5 * M_PI;
PolygonWake.cpp:      upwind_rel_dir[id] -= 2 * M_PI;
PolygonWake.cpp:  if (rectangular_flag && WID->simParams->rooftopFlag == 2) {
PolygonWake.cpp:    int id_valid = -1;
PolygonWake.cpp:    // Rooftop applies if upcoming wind angle is in -/+30 degrees of perpendicular direction of the face
PolygonWake.cpp:    for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
PolygonWake.cpp:      if (abs(upwind_rel_dir[id]) >= M_PI - tolRT) {
PolygonWake.cpp:      for (auto y_id = 0; y_id <= 2 * ceil(abs(yi[id_valid] - yi[id_valid + 1]) / WGD->dxy); y_id++) {
PolygonWake.cpp:        yc = MIN_S(yi[id_valid], yi[id_valid + 1]) + 0.5 * y_id * WGD->dxy;
PolygonWake.cpp:          x_wall = ((xi[id_valid + 1] - xi[id_valid]) / (yi[id_valid + 1] - yi[id_valid])) * (yc - yi[id_valid]) + xi[id_valid];
PolygonWake.cpp:        for (auto x_id = ceil(Lr / WGD->dxy) + 1; x_id >= 1; x_id--) {
PolygonWake.cpp:          xc = -x_id * WGD->dxy;
PolygonWake.cpp:          int i = ceil(((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x)) / WGD->dx - 1;
PolygonWake.cpp:          int j = ceil(((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y)) / WGD->dy - 1;
PolygonWake.cpp:          if (i < WGD->nx - 2 && i > 0 && j < WGD->ny - 2 && j > 0) {
PolygonWake.cpp:            int icell_cent = i + j * (WGD->nx - 1) + (k_end - 1) * (WGD->nx - 1) * (WGD->ny - 1);
PolygonWake.cpp:            if (WGD->icellflag[icell_cent] == 0) {
PolygonWake.cpp:              //std::cout << ID << " FOUND BUILDING " << WGD->ibuilding_flag[icell_cent] << std::endl;
PolygonWake.cpp:      if (bldg_upwind >= ceil(abs(yi[id_valid] - yi[id_valid + 1]) / WGD->dxy)) {
PolygonWake.cpp:        // Smaller of the effective height (height_eff) and the effective cross-wind width (Weff)
PolygonWake.cpp:        // Larger of the effective height (height_eff) and the effective cross-wind width (Weff)
PolygonWake.cpp:        // Smaller of the effective length (length_eff) and the effective cross-wind width (Weff)
PolygonWake.cpp:          shell_height = vd * sqrt(1.0 - pow((0.5 * R_cx - hd) / (0.5 * R_cx), 2.0));// Additional height because of the rooftop
PolygonWake.cpp:  for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
PolygonWake.cpp:    // Finding faces that are eligible for applying the far-wake parameterizations
PolygonWake.cpp:    // angle between two points should be in -180 to 0 degree
PolygonWake.cpp:  for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
PolygonWake.cpp:      index_previous = (id + polygonVertices.size() - 2) % (polygonVertices.size() - 1);// Index of previous face
PolygonWake.cpp:      index_next = (id + 1) % (polygonVertices.size() - 1);// Index of next face
PolygonWake.cpp:        Lr_node[id + 1] = ((yi[index_next] - yi[index_next + 1]) * Lr_face[index_next] + (yi[id] - yi[index_next]) * Lr_face[id])
PolygonWake.cpp:                          / (yi[id] - yi[index_next + 1]);
PolygonWake.cpp:        Lr_node[id] = ((yi[id] - yi[index_next]) * Lr_face[id] + (yi[index_previous] - yi[id]) * Lr_face[index_previous])
PolygonWake.cpp:                      / (yi[index_previous] - yi[index_next]);
PolygonWake.cpp:        Lr_node[id] = ((yi[id] - yi[index_next]) * Lr_face[id] + (yi[index_previous] - yi[id]) * Lr_face[index_previous])
PolygonWake.cpp:                      / (yi[index_previous] - yi[index_next]);
PolygonWake.cpp:        Lr_node[id + 1] = ((yi[index_next] - yi[index_next + 1]) * Lr_face[index_next] + (yi[id] - yi[index_next]) * Lr_face[id])
PolygonWake.cpp:                          / (yi[id] - yi[index_next + 1]);
PolygonWake.cpp:      Lr_ave += Lr_face[id] * (yi[id] - yi[index_next]);
PolygonWake.cpp:      total_seg_length += (yi[id] - yi[index_next]);
PolygonWake.cpp:    if ((polygonVertices[id + 1].x_poly > polygonVertices[0].x_poly - 0.1) && (polygonVertices[id + 1].x_poly < polygonVertices[0].x_poly + 0.1)
PolygonWake.cpp:        && (polygonVertices[id + 1].y_poly > polygonVertices[0].y_poly - 0.1) && (polygonVertices[id + 1].y_poly < polygonVertices[0].y_poly + 0.1)) {
PolygonWake.cpp:    if (base_height <= WGD->z[k]) {
PolygonWake.cpp:  for (auto k = k_start; k < WGD->nz - 2; k++) {
PolygonWake.cpp:    if (wake_height < WGD->z[k + 1]) {
PolygonWake.cpp:    if (0.75 * H + base_height <= WGD->z[k]) {
PolygonWake.cpp:  for (auto k = k_top; k >= k_bottom; k--) {
PolygonWake.cpp:    z_build = WGD->z[k] - base_height;
PolygonWake.cpp:        for (auto y_id = 0; y_id <= 2 * ceil(abs(yi[id] - yi[id + 1]) / WGD->dxy); y_id++) {
PolygonWake.cpp:          yc = yi[id] - 0.5 * y_id * WGD->dxy;
PolygonWake.cpp:          Lr_local = Lr_node[id] + (yc - yi[id]) * (Lr_node[id + 1] - Lr_node[id]) / (yi[id + 1] - yi[id]);
PolygonWake.cpp:            x_wall = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (yc - yi[id]) + xi[id];
PolygonWake.cpp:          x_id_min = -1;
PolygonWake.cpp:          for (auto x_id = 1; x_id <= ceil(Lr_local / WGD->dxy); x_id++) {
PolygonWake.cpp:            xc = x_id * WGD->dxy;
PolygonWake.cpp:            int i = ((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx;
PolygonWake.cpp:            int j = ((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy;
PolygonWake.cpp:            if (i >= WGD->nx - 2 || i <= 0 || j >= WGD->ny - 2 || j <= 0) {
PolygonWake.cpp:            int icell_cent = i + j * (WGD->nx - 1) + kk * (WGD->nx - 1) * (WGD->ny - 1);
PolygonWake.cpp:            if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2 && x_id_min < 0) {
PolygonWake.cpp:            if ((WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2) && x_id_min > 0) {
PolygonWake.cpp:          x_id_min = -1;
PolygonWake.cpp:          for (auto x_id = 1; x_id <= 2 * ceil(farwake_factor * Lr_local / WGD->dxy); x_id++) {
PolygonWake.cpp:            xc = 0.5 * x_id * WGD->dxy;
PolygonWake.cpp:            int i = ((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx;
PolygonWake.cpp:            int j = ((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy;
PolygonWake.cpp:            if (i >= WGD->nx - 2 || i <= 0 || j >= WGD->ny - 2 || j <= 0) {
PolygonWake.cpp:            icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolygonWake.cpp:            if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2 && x_id_min < 0) {
PolygonWake.cpp:            if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2) {
PolygonWake.cpp:                if (WGD->ibuilding_flag[icell_cent] == building_id) {
PolygonWake.cpp:                  x_id_min = -1;
PolygonWake.cpp:                } else if (WGD->icellflag[i + j * (WGD->nx - 1) + kk * (WGD->nx - 1) * (WGD->ny - 1)] == 0
PolygonWake.cpp:                           || WGD->icellflag[i + j * (WGD->nx - 1) + kk * (WGD->nx - 1) * (WGD->ny - 1)] == 2) {
PolygonWake.cpp:            if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
PolygonWake.cpp:              i_u = std::round(((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx);
PolygonWake.cpp:              j_u = ((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy;
PolygonWake.cpp:              if (i_u < WGD->nx - 1 && i_u > 0 && j_u < WGD->ny - 1 && j_u > 0) {
PolygonWake.cpp:                xp = i_u * WGD->dx - building_cent_x;
PolygonWake.cpp:                yp = (j_u + 0.5) * WGD->dy - building_cent_y;
PolygonWake.cpp:                yu = -xp * sin(upwind_dir) + yp * cos(upwind_dir);
PolygonWake.cpp:                Lr_local_u = Lr_node[id] + (yu - yi[id]) * (Lr_node[id + 1] - Lr_node[id]) / (yi[id + 1] - yi[id]);
PolygonWake.cpp:                  x_wall_u = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (yu - yi[id]) + xi[id];
PolygonWake.cpp:                xu -= x_wall_u;
PolygonWake.cpp:                  dn_u = sqrt((1.0 - pow((yu / y_norm), 2.0)) * (1.0 - pow((z_build / wake_height), 2.0)) * pow((canyon_factor * Lr_local_u), 2.0));
PolygonWake.cpp:                icell_cent = i_u + j_u * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolygonWake.cpp:                icell_face = i_u + j_u * WGD->nx + k * WGD->nx * WGD->ny;
PolygonWake.cpp:                    && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
PolygonWake.cpp:                    farwake_vel = WGD->u0[icell_face] * (1.0 - pow((dn_u / (xu + WGD->wake_factor * dn_u)), farwake_exp));
PolygonWake.cpp:                      WGD->w0[i + j * WGD->nx + k * WGD->nx * WGD->ny] = 0.0;
PolygonWake.cpp:                    WGD->u0[icell_face] = -u0_h * MIN_S(pow((1.0 - xu / (WGD->cavity_factor * dn_u)), 2.0), 1.0)
PolygonWake.cpp:                                          * MIN_S(sqrt(1.0 - abs(yu / y_norm)), 1.0);
PolygonWake.cpp:                      std::cout << "WGD->u0[icell_face]:   " << WGD->u0[icell_face] << std::endl;
PolygonWake.cpp:                    // std::cout << "WGD->u0[icell_face]:   " << WGD->u0[icell_face] << std::endl;
PolygonWake.cpp:                    WGD->w0[i + j * WGD->nx + k * WGD->nx * WGD->ny] = 0.0;
PolygonWake.cpp:              i_v = ((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx;
PolygonWake.cpp:              j_v = std::round(((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy);
PolygonWake.cpp:              if (i_v < WGD->nx - 1 && i_v > 0 && j_v < WGD->ny - 1 && j_v > 0) {
PolygonWake.cpp:                xp = (i_v + 0.5) * WGD->dx - building_cent_x;
PolygonWake.cpp:                yp = j_v * WGD->dy - building_cent_y;
PolygonWake.cpp:                yv = -xp * sin(upwind_dir) + yp * cos(upwind_dir);
PolygonWake.cpp:                Lr_local_v = Lr_node[id] + (yv - yi[id]) * (Lr_node[id + 1] - Lr_node[id]) / (yi[id + 1] - yi[id]);
PolygonWake.cpp:                  x_wall_v = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (yv - yi[id]) + xi[id];
PolygonWake.cpp:                xv -= x_wall_v;
PolygonWake.cpp:                  dn_v = sqrt((1.0 - pow((yv / y_norm), 2.0)) * (1.0 - pow((z_build / wake_height), 2.0)) * pow((canyon_factor * Lr_local_v), 2.0));
PolygonWake.cpp:                icell_cent = i_v + j_v * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolygonWake.cpp:                icell_face = i_v + j_v * WGD->nx + k * WGD->nx * WGD->ny;
PolygonWake.cpp:                    && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
PolygonWake.cpp:                    farwake_vel = WGD->v0[icell_face] * (1.0 - pow((dn_v / (xv + WGD->wake_factor * dn_v)), farwake_exp));
PolygonWake.cpp:                      WGD->w0[i + j * WGD->nx + k * WGD->nx * WGD->ny] = 0.0;
PolygonWake.cpp:                    WGD->v0[icell_face] = -v0_h * MIN_S(pow((1.0 - xv / (WGD->cavity_factor * dn_v)), 2.0), 1.0)
PolygonWake.cpp:                                          * MIN_S(sqrt(1.0 - abs(yv / y_norm)), 1.0);
PolygonWake.cpp:                      std::cout << "MIN_S(pow((1.0-xv/(WGD->cavity_factor*dn_v)),2.0),1.0):   " 
PolygonWake.cpp:                                << MIN_S(pow((1.0-xv/(WGD->cavity_factor*dn_v)),2.0),1.0) << std::endl;
PolygonWake.cpp:                      std::cout << "MIN_S(sqrt(1.0-abs(yv/y_norm)),1.0):   " << MIN_S(sqrt(1.0-abs(yv/y_norm)),1.0) << std::endl;
PolygonWake.cpp:                      std::cout << "WGD->v0[icell_face]:   " << WGD->v0[icell_face] << std::endl;
PolygonWake.cpp:                    // std::cout << "WGD->v0[icell_face]:   " << WGD->v0[icell_face] << std::endl;
PolygonWake.cpp:                    WGD->w0[icell_face] = 0.0;
PolygonWake.cpp:              i_w = ceil(((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx) - 1;
PolygonWake.cpp:              j_w = ceil(((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy) - 1;
PolygonWake.cpp:              if (i_w < WGD->nx - 2 && i_w > 0 && j_w < WGD->ny - 2 && j_w > 0) {
PolygonWake.cpp:                xp = (i_w + 0.5) * WGD->dx - building_cent_x;
PolygonWake.cpp:                yp = (j_w + 0.5) * WGD->dy - building_cent_y;
PolygonWake.cpp:                yw = -xp * sin(upwind_dir) + yp * cos(upwind_dir);
PolygonWake.cpp:                Lr_local_w = Lr_node[id] + (yw - yi[id]) * (Lr_node[id + 1] - Lr_node[id]) / (yi[id + 1] - yi[id]);
PolygonWake.cpp:                  x_wall_w = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (yw - yi[id]) + xi[id];
PolygonWake.cpp:                xw -= x_wall_w;
PolygonWake.cpp:                  dn_w = sqrt((1.0 - pow(yw / y_norm, 2.0)) * (1.0 - pow(z_build / wake_height, 2.0)) * pow(canyon_factor * Lr_local_w, 2.0));
PolygonWake.cpp:                icell_cent = i_w + j_w * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
PolygonWake.cpp:                icell_face = i_w + j_w * WGD->nx + k * WGD->nx * WGD->ny;
PolygonWake.cpp:                    && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
PolygonWake.cpp:                      if ((WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
PolygonWake.cpp:                        WGD->icellflag[icell_cent] = 5;
PolygonWake.cpp:                    if ((WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
PolygonWake.cpp:                      WGD->icellflag[icell_cent] = 4;
PolygonWake.cpp:    WGD->u0[u0_mod_id[x_id]] = u0_modified[x_id];
PolygonWake.cpp:    WGD->v0[v0_mod_id[y_id]] = v0_modified[y_id];
Ray.h: * This file is part of QES-Winds
Ray.h: * GPL-3.0 License
Ray.h: * QES-Winds is free software: you can redistribute it and/or modify
Ray.h: * QES-Winds is distributed in the hope that it will be useful,
Ray.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
RectangularBuilding.h: * This file is part of QES-Winds
RectangularBuilding.h: * GPL-3.0 License
RectangularBuilding.h: * QES-Winds is free software: you can redistribute it and/or modify
RectangularBuilding.h: * QES-Winds is distributed in the hope that it will be useful,
RectangularBuilding.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
RectangularBuilding.h:    // x_start += WID->simParams->halo_x;
RectangularBuilding.h:    // y_start += WID->simParams->halo_y;
RectangularBuilding.h:    polygonVertices[1].x_poly = x_start - W * sin(building_rotation);
RectangularBuilding.h:    // setPolybuilding(WGD->nx, WGD->ny, WGD->dx, WGD->dy, WGD->u0, WGD->v0, WGD->z);
Rooftop.cpp: * This file is part of QES-Winds
Rooftop.cpp: * GPL-3.0 License
Rooftop.cpp: * QES-Winds is free software: you can redistribute it and/or modify
Rooftop.cpp: * QES-Winds is distributed in the hope that it will be useful,
Rooftop.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Rooftop.cpp:  if (WID->simParams->rooftopFlag == 1) {
Rooftop.cpp:    // everything uses log-law
Rooftop.cpp:  } else if (WID->simParams->rooftopFlag == 2) {
Rooftop.cpp:  int index_building_face = i_building_cent + j_building_cent * WGD->nx + (k_end)*WGD->nx * WGD->ny;
Rooftop.cpp:  u0_h = WGD->u0[index_building_face];// u velocity at the height of building at the centroid
Rooftop.cpp:  v0_h = WGD->v0[index_building_face];// v velocity at the height of building at the centroid
Rooftop.cpp:    xi[id] = (polygonVertices[id].x_poly - building_cent_x) * cos(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * sin(upwind_dir);
Rooftop.cpp:    yi[id] = -(polygonVertices[id].x_poly - building_cent_x) * sin(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * cos(upwind_dir);
Rooftop.cpp:  for (auto k = k_end; k < WGD->nz - 1; k++) {
Rooftop.cpp:    if (1.5 * (H + base_height) < WGD->z_face[k]) {
Rooftop.cpp:  if (k_ref < WGD->nz - 1) {
Rooftop.cpp:    // Smaller of H and the effective cross-wind width (Weff)
Rooftop.cpp:    // Larger of H and the effective cross-wind width (Weff)
Rooftop.cpp:      if (H + base_height + vd < WGD->z[k]) {
Rooftop.cpp:      for (auto j = j_start; j < j_end - 1; j++) {
Rooftop.cpp:        for (auto i = i_start; i < i_end - 1; i++) {
Rooftop.cpp:          icell_cent = i + j * (WGD->nx - 1) + (k_end - 1) * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:          if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 7)// Cell below is building
Rooftop.cpp:            icell_cent = (i - 1) + j * (WGD->nx - 1) + (k_end - 1) * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:            if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 7)// Cell behind is building
Rooftop.cpp:            icell_cent = i + (j - 1) * (WGD->nx - 1) + (k_end - 1) * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:            if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 7)// Cell on right is building
Rooftop.cpp:          icell_cent = i + j * (WGD->nx - 1) + k_end * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:          if (WGD->icellflag[icell_cent] == 4 || WGD->icellflag[icell_cent] == 6) {
Rooftop.cpp:          if ((u_flag + v_flag + w_flag) > 0 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
Rooftop.cpp:            x_u = (i * WGD->dx - building_cent_x) * cos(upwind_dir) + ((j + 0.5) * WGD->dy - building_cent_y) * sin(upwind_dir);
Rooftop.cpp:            y_u = -(i * WGD->dx - building_cent_x) * sin(upwind_dir) + ((j + 0.5) * WGD->dy - building_cent_y) * cos(upwind_dir);
Rooftop.cpp:            x_v = ((i + 0.5) * WGD->dx - building_cent_x) * cos(upwind_dir) + (j * WGD->dy - building_cent_y) * sin(upwind_dir);
Rooftop.cpp:            y_v = -((i + 0.5) * WGD->dx - building_cent_x) * sin(upwind_dir) + (j * WGD->dy - building_cent_y) * cos(upwind_dir);
Rooftop.cpp:            h_x = abs(x_u - x_front);
Rooftop.cpp:            h_y = abs(y_u - y_front);
Rooftop.cpp:            h_x = abs(x_v - x_front);
Rooftop.cpp:            h_y = abs(y_v - y_front);
Rooftop.cpp:            for (auto k = k_end - 1; k < WGD->nz - 2; k++) {
Rooftop.cpp:              if ((z_ref_u + H + base_height) < WGD->z[k + 1] && k_shell_u < 1) {
Rooftop.cpp:              if ((z_ref_v + H + base_height) < WGD->z[k + 1] && k_shell_v < 1) {
Rooftop.cpp:            if (k_shell_u <= k_end - 1) {
Rooftop.cpp:              denom_u = 1.0 / log((WGD->z[k_shell_u] - (H + base_height)) / WGD->z0);
Rooftop.cpp:            if (k_shell_v <= k_end - 1) {
Rooftop.cpp:              denom_v = 1.0 / log((WGD->z[k_shell_v] - (H + base_height)) / WGD->z0);
Rooftop.cpp:            icell_face = i + j * WGD->nx + k_shell_u * WGD->nx * WGD->ny;
Rooftop.cpp:            velocity_mag_u = WGD->u0[icell_face];
Rooftop.cpp:            icell_face = i + j * WGD->nx + k_shell_v * WGD->nx * WGD->ny;
Rooftop.cpp:            velocity_mag_v = WGD->v0[icell_face];
Rooftop.cpp:              icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:              if (WGD->icellflag[icell_cent] == 0) {
Rooftop.cpp:                z_roof = WGD->z[k] - (H + base_height);
Rooftop.cpp:                    icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
Rooftop.cpp:                    WGD->u0[icell_face] = velocity_mag_u * log(z_roof / WGD->z0) * denom_u;
Rooftop.cpp:                    if (w_flag == 1 && (WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
Rooftop.cpp:                      icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:                      WGD->icellflag[icell_cent] = 10;
Rooftop.cpp:                    icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
Rooftop.cpp:                    WGD->v0[icell_face] = velocity_mag_v * log(z_roof / WGD->z0) * denom_v;
Rooftop.cpp:                    if (w_flag == 1 && (WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
Rooftop.cpp:                      icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:                      WGD->icellflag[icell_cent] = 10;
Rooftop.cpp:      for (auto id = 0; id < polygonVertices.size() - 1; id++) {
Rooftop.cpp:        upwind_rel_dir[id] = atan2(yi[id + 1] - yi[id], xi[id + 1] - xi[id]) + 0.5 * M_PI;
Rooftop.cpp:          upwind_rel_dir[id] -= 2 * M_PI;
Rooftop.cpp:        if (abs(upwind_rel_dir[id]) >= M_PI - tol) {
Rooftop.cpp:          for (auto j = j_start; j < j_end - 1; j++) {
Rooftop.cpp:            for (auto i = i_start; i < i_end - 1; i++) {
Rooftop.cpp:              icell_cent = i + j * (WGD->nx - 1) + (k_end - 1) * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:              if (WGD->icellflag[icell_cent] == 0)// Cell below is building
Rooftop.cpp:                icell_cent = (i - 1) + j * (WGD->nx - 1) + (k_end - 1) * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:                if (WGD->icellflag[icell_cent] == 0)// Cell behind is building
Rooftop.cpp:                icell_cent = i + (j - 1) * (WGD->nx - 1) + (k_end - 1) * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:                if (WGD->icellflag[icell_cent] == 0)// Cell on right is building
Rooftop.cpp:              icell_cent = i + j * (WGD->nx - 1) + k_end * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:              if (WGD->icellflag[icell_cent] == 4 || WGD->icellflag[icell_cent] == 6) {
Rooftop.cpp:              if ((u_flag + v_flag + w_flag) > 0 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
Rooftop.cpp:                x_u = (i * WGD->dx - building_cent_x) * cos(upwind_dir) + ((j + 0.5) * WGD->dy - building_cent_y) * sin(upwind_dir);
Rooftop.cpp:                y_u = -(i * WGD->dx - building_cent_x) * sin(upwind_dir) + ((j + 0.5) * WGD->dy - building_cent_y) * cos(upwind_dir);
Rooftop.cpp:                x_v = ((i + 0.5) * WGD->dx - building_cent_x) * cos(upwind_dir) + (j * WGD->dy - building_cent_y) * sin(upwind_dir);
Rooftop.cpp:                y_v = -((i + 0.5) * WGD->dx - building_cent_x) * sin(upwind_dir) + (j * WGD->dy - building_cent_y) * cos(upwind_dir);
Rooftop.cpp:                h_x = abs(x_u - x_front);
Rooftop.cpp:                h_y = abs(y_u - y_front);
Rooftop.cpp:                h_x = abs(x_v - x_front);
Rooftop.cpp:                h_y = abs(y_v - y_front);
Rooftop.cpp:                for (auto k = k_end - 1; k < WGD->nz; k++) {
Rooftop.cpp:                  if ((z_ref_u + H + base_height) < WGD->z[k + 1] && k_shell_u < 1) {
Rooftop.cpp:                  if ((z_ref_v + H + base_height) < WGD->z[k + 1] && k_shell_v < 1) {
Rooftop.cpp:                shell_heightu_part = 1.0 - pow((0.5 * R_cx - hd_u) / (0.5 * R_cx), 2.0);
Rooftop.cpp:                shell_heightv_part = 1.0 - pow((0.5 * R_cx - hd_v) / (0.5 * R_cx), 2.0);
Rooftop.cpp:                if (k_shell_u <= k_end - 1) {
Rooftop.cpp:                  denom_u = 1.0 / log((WGD->z[k_shell_u] - (H + base_height)) / WGD->z0);
Rooftop.cpp:                if (k_shell_v <= k_end - 1) {
Rooftop.cpp:                  denom_v = 1.0 / log((WGD->z[k_shell_v] - (H + base_height)) / WGD->z0);
Rooftop.cpp:                icell_face = i + j * WGD->nx + k_shell_u * WGD->nx * WGD->ny;
Rooftop.cpp:                velocity_mag_u = WGD->u0[icell_face];
Rooftop.cpp:                icell_face = i + j * WGD->nx + k_shell_v * WGD->nx * WGD->ny;
Rooftop.cpp:                velocity_mag_v = WGD->v0[icell_face];
Rooftop.cpp:                  z_roof = WGD->z[k] - (H + base_height);
Rooftop.cpp:                  icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:                  if (WGD->icellflag[icell_cent] == 0) {
Rooftop.cpp:                        icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
Rooftop.cpp:                        u0_roof = WGD->u0[icell_face];
Rooftop.cpp:                        WGD->u0[icell_face] = velocity_mag_u * log(z_roof / WGD->z0) * denom_u;
Rooftop.cpp:                        if (w_flag == 1 && (WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
Rooftop.cpp:                          icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:                          WGD->icellflag[icell_cent] = 10;
Rooftop.cpp:                        icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
Rooftop.cpp:                        WGD->u0[icell_face] = -u0_roof * abs((shell_height_u - z_roof) / vd);
Rooftop.cpp:                        if (w_flag == 1 && (WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
Rooftop.cpp:                          icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:                          WGD->icellflag[icell_cent] = 10;
Rooftop.cpp:                        icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
Rooftop.cpp:                        v0_roof = WGD->v0[icell_face];
Rooftop.cpp:                        WGD->v0[icell_face] = velocity_mag_v * log(z_roof / WGD->z0) * denom_v;
Rooftop.cpp:                        if (w_flag == 1 && (WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
Rooftop.cpp:                          icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:                          WGD->icellflag[icell_cent] = 10;
Rooftop.cpp:                        icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
Rooftop.cpp:                        WGD->v0[icell_face] = -v0_roof * abs((shell_height_v - z_roof) / vd);
Rooftop.cpp:                        if (w_flag == 1 && (WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
Rooftop.cpp:                          icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Rooftop.cpp:                          WGD->icellflag[icell_cent] = 10;
Rooftop.cpp:        /*else if (abs(upwind_rel_dir[id]) < M_PI-tol && abs(upwind_rel_dir[id]) >= M_PI-wing_tol)
Rooftop.cpp:          roof_angle = 2.94*exp(0.0297*abs(upwind_rel_dir[id]-0.5*M_PI));
Rooftop.cpp:          for (auto j = j_start; j < j_end-1; j++)
Rooftop.cpp:            for (auto i = i_start; i < i_end-1; i++)
Rooftop.cpp:              //std::cout << "k_end-1:  "<< k_end-1 << std::endl;
Rooftop.cpp:              icell_cent = i + j*(WGD->nx-1) + (k_end-1)*(WGD->nx-1)*(WGD->ny-1);
Rooftop.cpp:              if (WGD->icellflag[icell_cent] == 0)
Rooftop.cpp:                icell_cent = (i-1) + j*(WGD->nx-1) + (k_end-1)*(WGD->nx-1)*(WGD->ny-1);
Rooftop.cpp:                if (WGD->icellflag[icell_cent] == 0)
Rooftop.cpp:                icell_cent = i + (j-1)*(WGD->nx-1) + (k_end-1)*(WGD->nx-1)*(WGD->ny-1);
Rooftop.cpp:                if (WGD->icellflag[icell_cent] == 0)
Rooftop.cpp:              icell_cent = i + j*(WGD->nx-1) + k_end*(WGD->nx-1)*(WGD->ny-1);
Rooftop.cpp:              if (WGD->icellflag[icell_cent] == 4 || WGD->icellflag[icell_cent] == 6)
Rooftop.cpp:              x_u = (i*WGD->dx-building_cent_x)*cos(upwind_dir) + ((j+0.5)*WGD->dy-building_cent_y)*sin(upwind_dir);
Rooftop.cpp:              //std::cout << "WGD->icellflag[icell_cent]:  " << WGD->icellflag[icell_cent] << std::endl;
Rooftop.cpp:              if ((u_flag+v_flag+w_flag) > 0 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2)
Rooftop.cpp:                x_u = (i*WGD->dx-building_cent_x)*cos(upwind_dir) + ((j+0.5)*WGD->dy-building_cent_y)*sin(upwind_dir);
Rooftop.cpp:                y_u = -(i*WGD->dx-building_cent_x)*sin(upwind_dir) + ((j+0.5)*WGD->dy-building_cent_y)*cos(upwind_dir);
Rooftop.cpp:                x_v = ((i+0.5)*WGD->dx-building_cent_x)*cos(upwind_dir) + (j*WGD->dy-building_cent_y)*sin(upwind_dir);
Rooftop.cpp:                y_v = -((i+0.5)*WGD->dx-building_cent_x)*sin(upwind_dir) + (j*WGD->dy-building_cent_y)*cos(upwind_dir);
Rooftop.cpp:                x_w = ((i+0.5)*WGD->dx-building_cent_x)*cos(upwind_dir) + ((j+0.5)*WGD->dy-building_cent_y)*sin(upwind_dir);
Rooftop.cpp:                y_w = -((i+0.5)*WGD->dx-building_cent_x)*sin(upwind_dir) + ((j+0.5)*WGD->dy-building_cent_y)*cos(upwind_dir);
Rooftop.cpp:                h_xu = abs(x_u-x_front);
Rooftop.cpp:                h_yu = abs(y_u-y_front);
Rooftop.cpp:                //std::cout << "building_cent_x:  " << i*WGD->dx*cos(upwind_dir) << std::endl;
Rooftop.cpp:                //std::cout << "building_cent_y:  " << ((j+0.5)*WGD->dy-building_cent_y)*cos(upwind_dir) << std::endl;
Rooftop.cpp:                h_xv = abs(x_v-x_front);
Rooftop.cpp:                h_yv = abs(y_v-y_front);
Rooftop.cpp:                h_xw = abs(x_w-x_front);
Rooftop.cpp:                h_yw = abs(y_w-y_front);
Rooftop.cpp:                  icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
Rooftop.cpp:                  if (WGD->icellflag[icell_cent] == 0)
Rooftop.cpp:                    z_roof = WGD->z[k]-(H+base_height);
Rooftop.cpp:                    icell_face = i_building_cent + j_building_cent*WGD->nx + k*WGD->nx*WGD->ny;
Rooftop.cpp:                    velocity_mag = sqrt(pow(WGD->u0[icell_face], 2.0)+pow(WGD->v0[icell_face], 2.0));
Rooftop.cpp:                          icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;
Rooftop.cpp:                          WGD->u0[icell_face] = velocity_mag*cos(upwind_rel_dir[id]);
Rooftop.cpp:                          icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;
Rooftop.cpp:                          WGD->u0[icell_face] = velocity_mag*cos(upwind_rel_dir[id]+M_PI);
Rooftop.cpp:                          icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;
Rooftop.cpp:                          WGD->u0[icell_face] = velocity_mag*cos(upwind_rel_dir[id]+0.5*M_PI);
Rooftop.cpp:                          icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;
Rooftop.cpp:                          WGD->u0[icell_face] = velocity_mag*cos(upwind_rel_dir[id]+1.5*M_PI);
Rooftop.cpp:                          icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;
Rooftop.cpp:                          WGD->v0[icell_face] = velocity_mag*sin(upwind_rel_dir[id]);
Rooftop.cpp:                          icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;
Rooftop.cpp:                          WGD->v0[icell_face] = velocity_mag*sin(upwind_rel_dir[id]+M_PI);
Rooftop.cpp:                          icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;
Rooftop.cpp:                          WGD->v0[icell_face] = velocity_mag*sin(upwind_rel_dir[id]+0.5*M_PI);
Rooftop.cpp:                          icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;
Rooftop.cpp:                          WGD->v0[icell_face] = velocity_mag*sin(upwind_rel_dir[id]+1.5*M_PI);
Rooftop.cpp:                        icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;
Rooftop.cpp:                        WGD->w0[icell_face] = 0.1*velocity_mag*((hd_wx-h_xw)/hd_wx)*(1.0-abs((z_roof-hd_wx)/hd_wx));
Rooftop.cpp:                        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
Rooftop.cpp:                        WGD->icellflag[icell_cent] = 12;
Rooftop.cpp:                        icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;
Rooftop.cpp:                        WGD->w0[icell_face] = 0.1*velocity_mag*((hd_wy-h_yw)/hd_wy)*(1.0-abs((z_roof-hd_wy)/hd_wy));
Rooftop.cpp:                        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
Rooftop.cpp:                        WGD->icellflag[icell_cent] = 12;
Sensor.cpp: * This file is part of QES-Winds
Sensor.cpp: * GPL-3.0 License
Sensor.cpp: * QES-Winds is free software: you can redistribute it and/or modify
Sensor.cpp: * QES-Winds is distributed in the hope that it will be useful,
Sensor.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Sensor.cpp:  int num_sites = WID->metParams->sensors.size();
Sensor.cpp:  // if the value is -1, means that the timestep information is missing for the sensor
Sensor.cpp:  std::vector<int> time_id(num_sites, -1);
Sensor.cpp:  for (auto i = 0; i < WID->metParams->sensors.size(); i++) {
Sensor.cpp:    for (auto j = 0; j < WID->metParams->sensors[i]->TS.size(); j++) {
Sensor.cpp:      if (WGD->sensortime[index] == WID->metParams->sensors[i]->TS[j]->timeEpoch) {
Sensor.cpp:    if (time_id[i] == -1) {
Sensor.cpp:      num_sites -= 1;
Sensor.cpp:    if (time_id[i] != -1) {
Sensor.cpp:  std::vector<std::vector<float>> u_prof(num_sites, std::vector<float>(WGD->nz, 0.0));
Sensor.cpp:  std::vector<std::vector<float>> v_prof(num_sites, std::vector<float>(WGD->nz, 0.0));
Sensor.cpp:  // Loop through all sites and create velocity profiles (WGD->u0,WGD->v0)
Sensor.cpp:  for (auto i = 0; i < WID->metParams->sensors.size(); i++) {
Sensor.cpp:    if (time_id[i] == -1) {
Sensor.cpp:    average__one_overL += WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL / num_sites;
Sensor.cpp:    if (WID->simParams->UTMx != 0 && WID->simParams->UTMy != 0) {
Sensor.cpp:      if (WID->metParams->sensors[i]->site_coord_flag == 1) {
Sensor.cpp:        WID->metParams->sensors[i]->site_UTM_x = WID->metParams->sensors[i]->site_xcoord * acos(WGD->theta) + WID->metParams->sensors[i]->site_ycoord * asin(WGD->theta) + WID->simParams->UTMx;
Sensor.cpp:        WID->metParams->sensors[i]->site_UTM_y = WID->metParams->sensors[i]->site_xcoord * asin(WGD->theta) + WID->metParams->sensors[i]->site_ycoord * acos(WGD->theta) + WID->simParams->UTMy;
Sensor.cpp:        WID->metParams->sensors[i]->site_UTM_zone = WID->simParams->UTMZone;
Sensor.cpp:        UTMConverter(WID->metParams->sensors[i]->site_lon, WID->metParams->sensors[i]->site_lat, WID->metParams->sensors[i]->site_UTM_x, WID->metParams->sensors[i]->site_UTM_y, WID->metParams->sensors[i]->site_UTM_zone, 1);
Sensor.cpp:      if (WID->metParams->sensors[i]->site_coord_flag == 2) {
Sensor.cpp:        UTMConverter(WID->metParams->sensors[i]->site_lon, WID->metParams->sensors[i]->site_lat, WID->metParams->sensors[i]->site_UTM_x, WID->metParams->sensors[i]->site_UTM_y, WID->metParams->sensors[i]->site_UTM_zone, 1);
Sensor.cpp:        WID->metParams->sensors[i]->site_xcoord = WID->metParams->sensors[i]->site_UTM_x - WID->simParams->UTMx;
Sensor.cpp:        WID->metParams->sensors[i]->site_ycoord = WID->metParams->sensors[i]->site_UTM_y - WID->simParams->UTMy;
Sensor.cpp:      getConvergence(WID->metParams->sensors[i]->site_lon, WID->metParams->sensors[i]->site_lat, WID->metParams->sensors[i]->site_UTM_zone, convergence);
Sensor.cpp:    int idx = i - count;// id of the available sensors for the running timestep of the code
Sensor.cpp:    site_theta[idx] = (270.0 - WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[0]) * M_PI / 180.0;
Sensor.cpp:    site_i[idx] = WID->metParams->sensors[i]->site_xcoord / WGD->dx;
Sensor.cpp:    site_j[idx] = WID->metParams->sensors[i]->site_ycoord / WGD->dy;
Sensor.cpp:    site_id[idx] = site_i[idx] + site_j[idx] * WGD->nx;
Sensor.cpp:    if (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] > 0) {
Sensor.cpp:      blending_height += WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] / num_sites;
Sensor.cpp:      if (WID->metParams->sensors[i]->TS[time_id[i]]->site_blayer_flag == 4) {
Sensor.cpp:        while (id < WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref.size() && WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[id] > 0 && counter < 1) {
Sensor.cpp:          blending_height += WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[id] / num_sites;
Sensor.cpp:    if (WID->metParams->sensors[i]->TS[time_id[i]]->site_blayer_flag == 0) {
Sensor.cpp:      for (auto k = WGD->terrain_face_id[site_id[idx]]; k < WGD->nz; k++) {
Sensor.cpp:        u_prof[idx][k] = cos(site_theta[idx]) * WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0];
Sensor.cpp:        v_prof[idx][k] = sin(site_theta[idx]) * WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0];
Sensor.cpp:    if (WID->metParams->sensors[i]->TS[time_id[i]]->site_blayer_flag == 1) {
Sensor.cpp:      // vector, and not WGD->nz since z.size can be equal to
Sensor.cpp:      // WGD->nz+1 from what I can tell.  We access z[k]
Sensor.cpp:      for (auto k = WGD->terrain_face_id[site_id[idx]]; k < WGD->z.size(); k++) {
Sensor.cpp:        if (k == WGD->terrain_face_id[site_id[idx]]) {
Sensor.cpp:          if (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL >= 0) {
Sensor.cpp:            psi = 4.7 * WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL;
Sensor.cpp:            x_temp = pow((1.0 - 15.0 * WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL), 0.25);
Sensor.cpp:            psi = -2.0 * log(0.5 * (1.0 + x_temp)) - log(0.5 * (1.0 + pow(x_temp, 2.0))) + 2.0 * atan(x_temp) - 0.5 * M_PI;
Sensor.cpp:          u_star = WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0] * vk / (log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] + WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) + psi);
Sensor.cpp:        if ((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL >= 0) {
Sensor.cpp:          psi = 4.7 * (WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL;
Sensor.cpp:          x_temp = pow((1.0 - 15.0 * (WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL), 0.25);
Sensor.cpp:          psi = -2.0 * log(0.5 * (1.0 + x_temp)) - log(0.5 * (1.0 + pow(x_temp, 2.0))) + 2.0 * atan(x_temp) - 0.5 * M_PI;
Sensor.cpp:        u_prof[idx][k] = (cos(site_theta[idx]) * u_star / vk) * (log(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) + WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) + psi);
Sensor.cpp:        v_prof[idx][k] = (sin(site_theta[idx]) * u_star / vk) * (log(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) + WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) + psi);
Sensor.cpp:    if (WID->metParams->sensors[i]->TS[time_id[i]]->site_blayer_flag == 2) {
Sensor.cpp:      for (auto k = WGD->terrain_face_id[site_id[idx]]; k < WGD->nz; k++) {
Sensor.cpp:        u_prof[idx][k] = cos(site_theta[idx]) * WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0] * pow(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0]), WID->metParams->sensors[i]->TS[time_id[i]]->site_p);
Sensor.cpp:        v_prof[idx][k] = sin(site_theta[idx]) * WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0] * pow(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0]), WID->metParams->sensors[i]->TS[time_id[i]]->site_p);
Sensor.cpp:    if (WID->metParams->sensors[i]->TS[time_id[i]]->site_blayer_flag == 3) {
Sensor.cpp:      for (auto k = WGD->terrain_face_id[site_id[idx]]; k < WGD->nz; k++) {
Sensor.cpp:        if (k == WGD->terrain_face_id[site_id[idx]]) {
Sensor.cpp:          if (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL > 0) {
Sensor.cpp:            psi = 4.7 * WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL;
Sensor.cpp:            x_temp = pow((1.0 - 15.0 * WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL), 0.25);
Sensor.cpp:            psi = -2.0 * log(0.5 * (1.0 + x_temp)) - log(0.5 * (1.0 + pow(x_temp, 2.0))) + 2.0 * atan(x_temp) - 0.5 * M_PI;
Sensor.cpp:          u_star = WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0] * vk / (log(WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) + psi);
Sensor.cpp:          canopy_d = WGD->canopyBisection(u_star, WID->metParams->sensors[i]->TS[time_id[i]]->site_z0, WID->metParams->sensors[i]->TS[time_id[i]]->site_canopy_H, WID->metParams->sensors[i]->TS[time_id[i]]->site_atten_coeff, vk, psi);
Sensor.cpp:          if (WID->metParams->sensors[i]->TS[time_id[i]]->site_canopy_H * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL > 0) {
Sensor.cpp:            psi = 4.7 * (WID->metParams->sensors[i]->TS[time_id[i]]->site_canopy_H - canopy_d) * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL;
Sensor.cpp:            x_temp = pow((1.0 - 15.0 * (WID->metParams->sensors[i]->TS[time_id[i]]->site_canopy_H - canopy_d) * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL), 0.25);
Sensor.cpp:            psi = -2.0 * log(0.5 * (1.0 + x_temp)) - log(0.5 * (1.0 + pow(x_temp, 2.0))) + 2.0 * atan(x_temp) - 0.5 * M_PI;
Sensor.cpp:          u_H = (u_star / vk) * (log((WID->metParams->sensors[i]->TS[time_id[i]]->site_canopy_H - canopy_d) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) + psi);
Sensor.cpp:          if (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] < WID->metParams->sensors[i]->TS[time_id[i]]->site_canopy_H) {
Sensor.cpp:            WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0] /= u_H * exp(WID->metParams->sensors[i]->TS[time_id[i]]->site_atten_coeff * (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] / WID->metParams->sensors[i]->TS[time_id[i]]->site_canopy_H) - 1.0);
Sensor.cpp:            if (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL > 0) {
Sensor.cpp:              psi = 4.7 * (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] - canopy_d) * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL;
Sensor.cpp:              x_temp = pow(1.0 - 15.0 * (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] - canopy_d) * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL, 0.25);
Sensor.cpp:              psi = -2.0 * log(0.5 * (1.0 + x_temp)) - log(0.5 * (1.0 + pow(x_temp, 2.0))) + 2.0 * atan(x_temp) - 0.5 * M_PI;
Sensor.cpp:            WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0] /= ((u_star / vk) * (log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] - canopy_d) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) + psi));
Sensor.cpp:          u_star *= WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0];
Sensor.cpp:          u_H *= WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0];
Sensor.cpp:        if ((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) < WID->metParams->sensors[i]->TS[time_id[i]]->site_canopy_H) {
Sensor.cpp:          u_prof[idx][k] = cos(site_theta[idx]) * u_H * exp(WID->metParams->sensors[i]->TS[time_id[i]]->site_atten_coeff * (((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) / WID->metParams->sensors[i]->TS[time_id[i]]->site_canopy_H) - 1.0));
Sensor.cpp:          v_prof[idx][k] = sin(site_theta[idx]) * u_H * exp(WID->metParams->sensors[i]->TS[time_id[i]]->site_atten_coeff * (((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) / WID->metParams->sensors[i]->TS[time_id[i]]->site_canopy_H) - 1.0));
Sensor.cpp:        if ((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) > WID->metParams->sensors[i]->TS[time_id[i]]->site_canopy_H) {
Sensor.cpp:          if ((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL > 0) {
Sensor.cpp:            psi = 4.7 * ((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) - canopy_d) * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL;
Sensor.cpp:            x_temp = pow(1.0 - 15.0 * ((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) - canopy_d) * WID->metParams->sensors[i]->TS[time_id[i]]->site_one_overL, 0.25);
Sensor.cpp:            psi = -2.0 * log(0.5 * (1.0 + x_temp)) - log(0.5 * (1.0 + pow(x_temp, 2.0))) + 2.0 * atan(x_temp) - 0.5 * M_PI;
Sensor.cpp:          u_prof[idx][k] = (cos(site_theta[idx]) * u_star / vk) * (log(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) - canopy_d) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) + psi);
Sensor.cpp:          v_prof[idx][k] = (sin(site_theta[idx]) * u_star / vk) * (log(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) - canopy_d) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) + psi);
Sensor.cpp:    if (WID->metParams->sensors[i]->TS[time_id[i]]->site_blayer_flag == 4) {
Sensor.cpp:      int z_size = WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref.size();
Sensor.cpp:      int ii = -1;
Sensor.cpp:      site_theta[idx] = (270.0 - WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[0]) * M_PI / 180.0;
Sensor.cpp:      // Needs to be nz-1 for [0, n-1] indexing
Sensor.cpp:      for (auto k = WGD->terrain_face_id[site_id[idx]]; k < WGD->nz - 1; k++) {
Sensor.cpp:        if ((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) < WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] || z_size == 1) {
Sensor.cpp:          u_prof[idx][k] = (WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0] * cos(site_theta[idx]) / log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] + WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0))
Sensor.cpp:                           * log(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) + WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0);
Sensor.cpp:          v_prof[idx][k] = (WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[0] * sin(site_theta[idx]) / log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[0] + WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0))
Sensor.cpp:                           * log(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) + WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0);
Sensor.cpp:          if ((ii < z_size - 2) && ((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) >= WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1])) {
Sensor.cpp:            if (abs(WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[ii + 1] - WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[ii]) > 180.0) {
Sensor.cpp:              if (WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[ii + 1] > WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[ii]) {
Sensor.cpp:                wind_dir = (WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[ii + 1] - 360.0 - WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[ii + 1])
Sensor.cpp:                           / (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1] - WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii]);
Sensor.cpp:                wind_dir = (WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[ii + 1] + 360.0 - WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[ii + 1])
Sensor.cpp:                           / (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1] - WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii]);
Sensor.cpp:              wind_dir = (WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[ii + 1] - WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[ii])
Sensor.cpp:                         / (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1] - WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii]);
Sensor.cpp:            u_star = vk * WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii] / log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii] + z0_high) / z0_high);
Sensor.cpp:            u_new_high = (u_star / vk) * log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii] + z0_high) / z0_high);
Sensor.cpp:            z0_low = 1e-9;
Sensor.cpp:            u_star = vk * WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii] / log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii] + z0_low) / z0_low);
Sensor.cpp:            u_new_low = (u_star / vk) * log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1] + z0_low) / z0_low);
Sensor.cpp:            if (WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii + 1] > u_new_low && WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii + 1] < u_new_high) {
Sensor.cpp:              u_star = vk * WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii] / log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii] + WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0);
Sensor.cpp:              u_new = (u_star / vk) * log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1] + WID->metParams->sensors[i]->TS[time_id[i]]->site_z0) / WID->metParams->sensors[i]->TS[time_id[i]]->site_z0);
Sensor.cpp:              while (iter < 200 && abs(u_new - WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii]) > 0.0001 * WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii]) {
Sensor.cpp:                u_star = vk * WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii] / log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii] + z0_new) / z0_new);
Sensor.cpp:                u_new = (u_star / vk) * log((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1] + z0_new) / z0_new);
Sensor.cpp:                if (u_new > WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1]) {
Sensor.cpp:              if (ii < z_size - 2) {
Sensor.cpp:                a1 = ((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1] - WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii])
Sensor.cpp:                        * (WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii + 2] - WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii])
Sensor.cpp:                      + (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii] - WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 2])
Sensor.cpp:                          * (WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii + 1] - WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii]))
Sensor.cpp:                     / ((WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1] - WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii])
Sensor.cpp:                          * (pow(WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 2], 2.0) - pow(WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii], 2.0))
Sensor.cpp:                        + (pow(WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1], 2.0) - pow(WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii], 2.0))
Sensor.cpp:                            * (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii] - WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 2]));
Sensor.cpp:              a2 = ((WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii + 1] - WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii])
Sensor.cpp:                    - a1 * (pow(WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1], 2.0) - pow(WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii], 2.0)))
Sensor.cpp:                   / (WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii + 1] - WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii]);
Sensor.cpp:              a3 = WID->metParams->sensors[i]->TS[time_id[i]]->site_U_ref[ii] - a1 * pow(WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii], 2.0)
Sensor.cpp:                   - a2 * WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii];
Sensor.cpp:            site_mag = (u_star / vk) * log(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) + z0_new) / z0_new);
Sensor.cpp:            site_mag = a1 * pow((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]), 2.0) + a2 * (WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) + a3;
Sensor.cpp:          site_theta[idx] = (270.0 - (WID->metParams->sensors[i]->TS[time_id[i]]->site_wind_dir[ii] + wind_dir * ((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[site_id[idx]] - 1]) - WID->metParams->sensors[i]->TS[time_id[i]]->site_z_ref[ii]))) * M_PI / 180.0;
Sensor.cpp:  x.resize(WGD->nx);
Sensor.cpp:  for (size_t i = 0; i < WGD->nx; i++) {
Sensor.cpp:    x[i] = (i - 0.5) * WGD->dx; /**< Location of face centers in x-dir */
Sensor.cpp:  y.resize(WGD->ny);
Sensor.cpp:  for (auto j = 0; j < WGD->ny; j++) {
Sensor.cpp:    y[j] = (j - 0.5) * WGD->dy; /**< Location of face centers in y-dir */
Sensor.cpp:    for (auto k = 0; k < WGD->nz; k++) {
Sensor.cpp:      for (auto j = 0; j < WGD->ny; j++) {
Sensor.cpp:        for (auto i = 0; i < WGD->nx; i++) {
Sensor.cpp:          int id = i + j * WGD->nx;
Sensor.cpp:          if (k + WGD->terrain_face_id[id] - 1 < WGD->nz) {
Sensor.cpp:            k_mod = k + WGD->terrain_face_id[id] - 1;
Sensor.cpp:          icell_face = i + j * WGD->nx + k_mod * WGD->nx * WGD->ny;/// Lineralized index for cell faced values
Sensor.cpp:          if (k + WGD->terrain_face_id[site_id[0]] - 1 > WGD->nz - 2) {
Sensor.cpp:            WGD->u0[icell_face] = u_prof[0][WGD->nz - 2];
Sensor.cpp:            WGD->v0[icell_face] = v_prof[0][WGD->nz - 2];
Sensor.cpp:            WGD->u0[icell_face] = u_prof[0][k + WGD->terrain_face_id[site_id[0]] - 1];
Sensor.cpp:            WGD->v0[icell_face] = v_prof[0][k + WGD->terrain_face_id[site_id[0]] - 1];
Sensor.cpp:          // WGD->w0[icell_face] = 0.0;         /// Perpendicular wind direction
Sensor.cpp:      std::chrono::duration<float> elapsedBarnesCPU = finishBarnesCPU - startBarnesCPU;
Sensor.cpp:      std::chrono::duration<float> elapsedBarnesGPU = finishBarnesGPU - startBarnesGPU;
Sensor.cpp:  if (WID->metParams->z0_domain_flag == 1) {
Sensor.cpp:    for (auto i = 0; i < WGD->nx; i++) {
Sensor.cpp:      for (auto j = 0; j < WGD->ny; j++) {
Sensor.cpp:        id = i + j * WGD->nx;
Sensor.cpp:        if (WGD->terrain_face_id[id] > max_terrain) {
Sensor.cpp:          max_terrain = WGD->terrain_face_id[id];
Sensor.cpp:          max_terrain_id = i + j * WGD->nx;
Sensor.cpp:    for (auto i = 0; i < WGD->nx; i++) {
Sensor.cpp:      for (auto j = 0; j < WGD->ny; j++) {
Sensor.cpp:        id = i + j * WGD->nx;
Sensor.cpp:        sum_z0 += log(((WGD->z0_domain_u[id] + WGD->z0_domain_v[id]) / 2) + WGD->z_face[WGD->terrain_face_id[id]]);
Sensor.cpp:    z0_effective = exp(sum_z0 / (WGD->nx * WGD->ny));
Sensor.cpp:    blending_height = blending_height + WGD->terrain[max_terrain_id];
Sensor.cpp:    for (auto k = 0; k < WGD->z.size(); k++) {
Sensor.cpp:      if (blending_height < WGD->z[k + 1]) {
Sensor.cpp:    blending_velocity.resize(WGD->nx * WGD->ny, 0.0);
Sensor.cpp:    blending_theta.resize(WGD->nx * WGD->ny, 0.0);
Sensor.cpp:    for (auto i = 0; i < WGD->nx; i++) {
Sensor.cpp:      for (auto j = 0; j < WGD->ny; j++) {
Sensor.cpp:        blending_id = i + j * WGD->nx + height_id * WGD->nx * WGD->ny;
Sensor.cpp:        id = i + j * WGD->nx;
Sensor.cpp:        blending_velocity[id] = sqrt(pow(WGD->u0[blending_id], 2.0) + pow(WGD->v0[blending_id], 2.0));
Sensor.cpp:        blending_theta[id] = atan2(WGD->v0[blending_id], WGD->u0[blending_id]);
Sensor.cpp:    for (auto i = 0; i < WGD->nx; i++) {
Sensor.cpp:      for (auto j = 0; j < WGD->ny; j++) {
Sensor.cpp:        id = i + j * WGD->nx;
Sensor.cpp:          x_temp = pow((1.0 - 15.0 * blending_height * average__one_overL), 0.25);
Sensor.cpp:          psi_first = -2.0 * log(0.5 * (1.0 + x_temp)) - log(0.5 * (1.0 + pow(x_temp, 2.0))) + 2.0 * atan(x_temp) - 0.5 * M_PI;
Sensor.cpp:        for (auto k = WGD->terrain_face_id[id]; k < height_id; k++) {
Sensor.cpp:          if ((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[id] - 1]) * average__one_overL >= 0) {
Sensor.cpp:            psi = 4.7 * (WGD->z[k] - WGD->z_face[WGD->terrain_face_id[id] - 1]) * average__one_overL;
Sensor.cpp:            x_temp = pow((1.0 - 15.0 * (WGD->z[k] - WGD->z_face[WGD->terrain_face_id[id] - 1]) * average__one_overL), 0.25);
Sensor.cpp:            psi = -2.0 * log(0.5 * (1.0 + x_temp)) - log(0.5 * (1.0 + pow(x_temp, 2.0))) + 2.0 * atan(x_temp) - 0.5 * M_PI;
Sensor.cpp:          icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
Sensor.cpp:          z0_domain = (WGD->z0_domain_u[id] + WGD->z0_domain_v[id]) / 2;
Sensor.cpp:          WGD->u0[icell_face] = (cos(blending_theta[id]) * u_star / vk) * (log(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[id] - 1]) + WGD->z0_domain_u[id]) / WGD->z0_domain_u[id]) + psi);
Sensor.cpp:          WGD->v0[icell_face] = (sin(blending_theta[id]) * u_star / vk) * (log(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[id] - 1]) + WGD->z0_domain_v[id]) / WGD->z0_domain_v[id]) + psi);
Sensor.cpp:        for (auto k = height_id + 1; k < WGD->nz - 1; k++) {
Sensor.cpp:          if ((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[id] - 1]) * average__one_overL >= 0) {
Sensor.cpp:            psi = 4.7 * (WGD->z[k] - WGD->z_face[WGD->terrain_face_id[id] - 1]) * average__one_overL;
Sensor.cpp:            x_temp = pow((1.0 - 15.0 * (WGD->z[k] - WGD->z_face[WGD->terrain_face_id[id] - 1]) * average__one_overL), 0.25);
Sensor.cpp:            psi = -2.0 * log(0.5 * (1.0 + x_temp)) - log(0.5 * (1.0 + pow(x_temp, 2.0))) + 2.0 * atan(x_temp) - 0.5 * M_PI;
Sensor.cpp:          icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
Sensor.cpp:          WGD->u0[icell_face] = (cos(blending_theta[id]) * u_star / vk) * (log(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[id] - 1]) + z0_effective) / z0_effective) + psi);
Sensor.cpp:          WGD->v0[icell_face] = (sin(blending_theta[id]) * u_star / vk) * (log(((WGD->z[k] - WGD->z_face[WGD->terrain_face_id[id] - 1]) + z0_effective) / z0_effective) + psi);
Sensor.cpp:  std::chrono::duration<float> elapsed_InputWindProfile = end_InputWindProfile - start_InputWindProfile;
Sensor.cpp:  x.resize(WGD->nx);
Sensor.cpp:  for (size_t i = 0; i < WGD->nx; i++) {
Sensor.cpp:    x[i] = (i - 0.5) * WGD->dx; /**< Location of face centers in x-dir */
Sensor.cpp:  y.resize(WGD->ny);
Sensor.cpp:  for (auto j = 0; j < WGD->ny; j++) {
Sensor.cpp:    y[j] = (j - 0.5) * WGD->dy; /**< Location of face centers in y-dir */
Sensor.cpp:  std::vector<float> u0_int(num_sites * WGD->nz, 0.0);
Sensor.cpp:  std::vector<float> v0_int(num_sites * WGD->nz, 0.0);
Sensor.cpp:  std::vector<std::vector<std::vector<float>>> wm(num_sites, std::vector<std::vector<float>>(WGD->nx, std::vector<float>(WGD->ny, 0.0)));
Sensor.cpp:  std::vector<std::vector<std::vector<float>>> wms(num_sites, std::vector<std::vector<float>>(WGD->nx, std::vector<float>(WGD->ny, 0.0)));
Sensor.cpp:      xc = WID->metParams->sensors[available_sensor_id[ii]]->site_xcoord - WID->metParams->sensors[available_sensor_id[i]]->site_xcoord;
Sensor.cpp:      yc = WID->metParams->sensors[available_sensor_id[ii]]->site_ycoord - WID->metParams->sensors[available_sensor_id[i]]->site_ycoord;
Sensor.cpp:  for (auto j = 0; j < WGD->ny; j++) {
Sensor.cpp:    for (auto i = 0; i < WGD->nx; i++) {
Sensor.cpp:        wm[ii][i][j] = exp((-1 / lamda) * pow(WID->metParams->sensors[available_sensor_id[ii]]->site_xcoord - x[i], 2.0) - (1 / lamda) * pow(WID->metParams->sensors[available_sensor_id[ii]]->site_ycoord - y[j], 2.0));
Sensor.cpp:        wms[ii][i][j] = exp((-1 / (s_gamma * lamda)) * pow(WID->metParams->sensors[available_sensor_id[ii]]->site_xcoord - x[i], 2.0) - (1 / (s_gamma * lamda)) * pow(WID->metParams->sensors[available_sensor_id[ii]]->site_ycoord - y[j], 2.0));
Sensor.cpp:          wm[ii][i][j] = 1e-20;
Sensor.cpp:  for (auto k = 1; k < WGD->nz; k++) {
Sensor.cpp:    for (auto j = 0; j < WGD->ny; j++) {
Sensor.cpp:      for (auto i = 0; i < WGD->nx; i++) {
Sensor.cpp:        int id = i + j * WGD->nx;
Sensor.cpp:        int idx = i + j * (WGD->nx - 1);
Sensor.cpp:        if (k + WGD->terrain_face_id[id] - 1 < WGD->nz) {
Sensor.cpp:          k_mod = k + WGD->terrain_face_id[id] - 1;
Sensor.cpp:          site_i[ii] = WID->metParams->sensors[available_sensor_id[ii]]->site_xcoord / WGD->dx;
Sensor.cpp:          site_j[ii] = WID->metParams->sensors[available_sensor_id[ii]]->site_ycoord / WGD->dy;
Sensor.cpp:          site_id[ii] = site_i[ii] + site_j[ii] * WGD->nx;
Sensor.cpp:          if (k + WGD->terrain_face_id[site_id[ii]] - 1 > WGD->nz - 2) {
Sensor.cpp:            sum_wu += wm[ii][i][j] * u_prof[ii][WGD->nz - 2];
Sensor.cpp:            sum_wv += wm[ii][i][j] * v_prof[ii][WGD->nz - 2];
Sensor.cpp:            sum_wu += wm[ii][i][j] * u_prof[ii][k + WGD->terrain_face_id[site_id[ii]] - 1];
Sensor.cpp:            sum_wv += wm[ii][i][j] * v_prof[ii][k + WGD->terrain_face_id[site_id[ii]] - 1];
Sensor.cpp:        icell_face = i + j * WGD->nx + k_mod * WGD->nx * WGD->ny;
Sensor.cpp:        WGD->u0[icell_face] = sum_wu / sum_wm;
Sensor.cpp:        WGD->v0[icell_face] = sum_wv / sum_wm;
Sensor.cpp:        WGD->w0[icell_face] = 0.0;
Sensor.cpp:    if (WID->metParams->sensors[available_sensor_id[ii]]->site_xcoord > 0 && WID->metParams->sensors[available_sensor_id[ii]]->site_xcoord < (WGD->nx - 1) * WGD->dx && WID->metParams->sensors[available_sensor_id[ii]]->site_ycoord > 0 && WID->metParams->sensors[available_sensor_id[ii]]->site_ycoord < (WGD->ny - 1) * WGD->dy) {
Sensor.cpp:      for (auto j = 0; j < WGD->ny; j++) {
Sensor.cpp:        if (y[j] < WID->metParams->sensors[available_sensor_id[ii]]->site_ycoord) {
Sensor.cpp:      for (auto i = 0; i < WGD->nx; i++) {
Sensor.cpp:        if (x[i] < WID->metParams->sensors[available_sensor_id[ii]]->site_xcoord) {
Sensor.cpp:      int id = iwork + jwork * WGD->nx;
Sensor.cpp:      for (auto k_mod = WGD->terrain_face_id[id]; k_mod < WGD->nz; k_mod++) {
Sensor.cpp:        dxx = WID->metParams->sensors[available_sensor_id[ii]]->site_xcoord - x[iwork];
Sensor.cpp:        dyy = WID->metParams->sensors[available_sensor_id[ii]]->site_ycoord - y[jwork];
Sensor.cpp:        int index_work = iwork + jwork * WGD->nx + k_mod * WGD->nx * WGD->ny;
Sensor.cpp:        u12 = (1 - (dxx / WGD->dx)) * WGD->u0[index_work + WGD->nx] + (dxx / WGD->dx) * WGD->u0[index_work + 1 + WGD->nx];
Sensor.cpp:        u34 = (1 - (dxx / WGD->dx)) * WGD->u0[index_work] + (dxx / WGD->dx) * WGD->u0[index_work + 1];
Sensor.cpp:        u0_int[k_mod + ii * WGD->nz] = (dyy / WGD->dy) * u12 + (1 - (dyy / WGD->dy)) * u34;
Sensor.cpp:        v12 = (1 - (dxx / WGD->dx)) * WGD->v0[index_work + WGD->nx] + (dxx / WGD->dx) * WGD->v0[index_work + 1 + WGD->nx];
Sensor.cpp:        v34 = (1 - (dxx / WGD->dx)) * WGD->v0[index_work] + (dxx / WGD->dx) * WGD->v0[index_work + 1];
Sensor.cpp:        v0_int[k_mod + ii * WGD->nz] = (dyy / WGD->dy) * v12 + (1 - (dyy / WGD->dy)) * v34;
Sensor.cpp:      site_i[ii] = WID->metParams->sensors[available_sensor_id[ii]]->site_xcoord / WGD->dx;
Sensor.cpp:      site_j[ii] = WID->metParams->sensors[available_sensor_id[ii]]->site_ycoord / WGD->dy;
Sensor.cpp:      site_id[ii] = site_i[ii] + site_j[ii] * WGD->nx;
Sensor.cpp:      for (auto k = 1; k < WGD->nz; k++) {
Sensor.cpp:        if (k + WGD->terrain_face_id[site_id[ii]] - 1 > WGD->nz - 2) {
Sensor.cpp:          u0_int[k + ii * WGD->nz] = u_prof[ii][WGD->nz - 2];
Sensor.cpp:          v0_int[k + ii * WGD->nz] = v_prof[ii][WGD->nz - 2];
Sensor.cpp:          u0_int[k + WGD->terrain_face_id[site_id[ii]] - 1 + ii * WGD->nz] = u_prof[ii][k + WGD->terrain_face_id[site_id[ii]] - 1];
Sensor.cpp:          v0_int[k + WGD->terrain_face_id[site_id[ii]] - 1 + ii * WGD->nz] = v_prof[ii][k + WGD->terrain_face_id[site_id[ii]] - 1];
Sensor.cpp:  for (auto k = 1; k < WGD->nz; k++) {
Sensor.cpp:    for (auto j = 0; j < WGD->ny; j++) {
Sensor.cpp:      for (auto i = 0; i < WGD->nx; i++) {
Sensor.cpp:        int id = i + j * WGD->nx;
Sensor.cpp:        if (k + WGD->terrain_face_id[id] - 1 < WGD->nz) {
Sensor.cpp:          k_mod = k + WGD->terrain_face_id[id] - 1;
Sensor.cpp:          site_i[ii] = WID->metParams->sensors[available_sensor_id[ii]]->site_xcoord / WGD->dx;
Sensor.cpp:          site_j[ii] = WID->metParams->sensors[available_sensor_id[ii]]->site_ycoord / WGD->dy;
Sensor.cpp:          site_id[ii] = site_i[ii] + site_j[ii] * WGD->nx;
Sensor.cpp:          if (k + WGD->terrain_face_id[site_id[ii]] - 1 > WGD->nz - 2) {
Sensor.cpp:            sum_wu += wm[ii][i][j] * (u_prof[ii][WGD->nz - 2] - u0_int[WGD->nz - 2 + ii * WGD->nz]);
Sensor.cpp:            sum_wv += wm[ii][i][j] * (v_prof[ii][WGD->nz - 2] - v0_int[WGD->nz - 2 + ii * WGD->nz]);
Sensor.cpp:            sum_wu += wm[ii][i][j] * (u_prof[ii][k + WGD->terrain_face_id[site_id[ii]] - 1] - u0_int[k + WGD->terrain_face_id[site_id[ii]] - 1 + ii * WGD->nz]);
Sensor.cpp:            sum_wv += wm[ii][i][j] * (v_prof[ii][k + WGD->terrain_face_id[site_id[ii]] - 1] - v0_int[k + WGD->terrain_face_id[site_id[ii]] - 1 + ii * WGD->nz]);
Sensor.cpp:          icell_face = i + j * WGD->nx + k_mod * WGD->nx * WGD->ny;
Sensor.cpp:          WGD->u0[icell_face] = WGD->u0[icell_face] + sum_wu / sum_wm;
Sensor.cpp:          WGD->v0[icell_face] = WGD->v0[icell_face] + sum_wv / sum_wm;
Sensor.cpp:                  ---------------------------------------
Sensor.cpp:    (at your option) aWGD->ny later version.
Sensor.cpp:    but WITHOUT AWGD->ny WARRANTY; without even the implied warranty of
Sensor.cpp:    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
Sensor.cpp:        by John P. SWGD->nyder, Geological Survey Bulletin 1532, USDI.
Sensor.cpp:    Each of these is 8 degrees south-north, apart from zone X which is 12 degrees south-north.
Sensor.cpp:    - north=0 for northern hemisphere and
Sensor.cpp:    - north=10000000 (10000km) for southern hemisphere. values must be in metres i.e. north=10000000.
Sensor.cpp:  e2 = 1.0 - pow((semimin / semimaj), 2.0);
Sensor.cpp:  ep2 = e2 / (1.0 - e2);
Sensor.cpp:  cm = zone * 6.0 - 183.0;
Sensor.cpp:    delam = dlon - cm;
Sensor.cpp:    if (delam < -180.0) {
Sensor.cpp:      delam = delam - 360.0;
Sensor.cpp:    f1 = (1.0 - (e2 / 4.0) - 3.0 * (e4 / 64.0) - 5.0 * (e6 / 256)) * rlat;
Sensor.cpp:    rm = semimaj * (f1 - f2 + f3 - f4);
Sensor.cpp:    if (dlat == 90.0 || dlat == -90.0) {
Sensor.cpp:      rn = semimaj / sqrt(1.0 - e2 * pow(sin(rlat), 2.0));
Sensor.cpp:      f1 = (1.0 - t + c) * pow(a, 3.0) / 6.0;
Sensor.cpp:      f2 = 5.0 - 18.0 * t + pow(t, 2.0) + 72.0 * c - 58.0 * ep2;
Sensor.cpp:      f2 = 5.0 - t + 9.0 * c + 4.0 * pow(c, 2.0);
Sensor.cpp:      f3 = 61.0 - 58.0 * t + pow(t, 2.0) + 600.0 * c - 330.0 * ep2;
Sensor.cpp:    xx = xx - east;
Sensor.cpp:    yy = yy - north;
Sensor.cpp:    e1 = sqrt(1.0 - e2);
Sensor.cpp:    e1 = (1.0 - e1) / (1.0 + e1);
Sensor.cpp:    u = 1.0 - (e2 / 4.0) - 3.0 * (e4 / 64.0) - 5.0 * (e6 / 256.0);
Sensor.cpp:    f1 = 3.0 * (e1 / 2.0) - 27.0 * pow(e1, 3.0) / 32.0;
Sensor.cpp:    f2 = (21.0 * pow(e1, 2.0) / 16.0) - 55.0 * pow(e1, 4.0) / 32.0;
Sensor.cpp:    if (dlat1 >= 90.0 || dlat1 <= -90.0) {
Sensor.cpp:      dlat1 = std::max(dlat1, -90.0f);
Sensor.cpp:      f1 = 1.0 - e2 * pow(sin(rlat1), 2.0);
Sensor.cpp:      r1 = semimaj * (1.0 - e2) / sqrt(pow(f1, 3.0));
Sensor.cpp:      f3 = 5.0 * 3.0 * t1 + 10.0 * c1 - 4.0 * pow(c1, 2.0) - 9.0 * ep2;
Sensor.cpp:      f4 = 61.0 + 90.0 * t1 + 298.0 * c1 + 45.0 * pow(t1, 2.0) - 252.0 * ep2 - 3.0 * pow(c1, 2.0);
Sensor.cpp:      rlat = rlat1 - f1 * (f2 - f3 + f4);
Sensor.cpp:      f2 = 5.0 - 2.0 * c1 + 28.0 * t1 - 3.0 * pow(c1, 2.0) + 8.0 * ep2 + 24.0 * pow(t1, 2.0);
Sensor.cpp:      rlon = cmr + (d - f1 + f2) / cos(rlat1);
Sensor.cpp:      if (dlon < -180.0) {
Sensor.cpp:        dlon = dlon - 360.0;
Sensor.cpp:  temp_lon = (6.0 * site_UTM_zone) - 183.0 - lon;
Sensor.cu: * This file is part of QES-Winds
Sensor.cu: * GPL-3.0 License
Sensor.cu: * QES-Winds is free software: you can redistribute it and/or modify
Sensor.cu: * QES-Winds is distributed in the hope that it will be useful,
Sensor.cu: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Sensor.cu:    printf("\"%s\" at %d in %s\n\treturned %d\n-> %s\n", func, line, call, (int)e, cudaGetErrorString(e));
Sensor.cu:  int i = (ii - j * (nx)*num_sites) / num_sites;
Sensor.cu:  int site_id = ii - j * (nx)*num_sites - i * num_sites;
Sensor.cu:    d_wm[ii] = exp((-1 / lamda) * pow(d_site_xcoord[site_id] - d_x[i], 2.0) - (1 / lamda) * pow(d_site_ycoord[site_id] - d_y[j], 2.0));
Sensor.cu:    d_wms[ii] = exp((-1 / (s_gamma * lamda)) * pow(d_site_xcoord[site_id] - d_x[i], 2.0) - (1 / (s_gamma * lamda)) * pow(d_site_ycoord[site_id] - d_y[j], 2.0));
Sensor.cu:          d_wm[ii + id] = 1e-20;
Sensor.cu:  int i = (ii - j * nx);
Sensor.cu:      if (k + d_terrain_face_id[ii] - 1 < nz) {
Sensor.cu:        d_k_mod[ii] = k + d_terrain_face_id[ii] - 1;
Sensor.cu:        if (k + d_terrain_face_id[d_site_id[id]] - 1 > nz - 2) {
Sensor.cu:          d_sum_wu[idx] = d_sum_wu[idx] + d_wm[id + i * num_sites + j * num_sites * nx] * d_u_prof[nz - 2 + id * nz];
Sensor.cu:          d_sum_wv[idx] = d_sum_wv[idx] + d_wm[id + i * num_sites + j * num_sites * nx] * d_v_prof[nz - 2 + id * nz];
Sensor.cu:          d_sum_wu[idx] = d_sum_wu[idx] + d_wm[id + i * num_sites + j * num_sites * nx] * d_u_prof[k + d_terrain_face_id[d_site_id[id]] - 1 + id * nz];
Sensor.cu:          d_sum_wv[idx] = d_sum_wv[idx] + d_wm[id + i * num_sites + j * num_sites * nx] * d_v_prof[k + d_terrain_face_id[d_site_id[id]] - 1 + id * nz];
Sensor.cu:    if (d_site_xcoord[ii] > 0 && d_site_xcoord[ii] < (nx - 1) * dx && d_site_ycoord[ii] > 0 && d_site_ycoord[ii] < (ny - 1) * dy) {
Sensor.cu:      d_dxx[ii] = d_site_xcoord[ii] - d_x[d_iwork[ii]];
Sensor.cu:      d_dyy[ii] = d_site_ycoord[ii] - d_y[d_jwork[ii]];
Sensor.cu:        d_u12[idx] = (1 - (d_dxx[ii] / dx)) * d_u0[index_work + nx] + (d_dxx[ii] / dx) * d_u0[index_work + 1 + nx];
Sensor.cu:        d_u34[idx] = (1 - (d_dxx[ii] / dx)) * d_u0[d_iwork[ii] + d_jwork[ii] * nx + k * nx * ny] + (d_dxx[ii] / dx) * d_u0[d_iwork[ii] + d_jwork[ii] * nx + k * nx * ny + 1];
Sensor.cu:        d_u0_int[idx] = (d_dyy[ii] / dy) * d_u12[idx] + (1 - (d_dyy[ii] / dy)) * d_u34[idx];
Sensor.cu:        d_v12[idx] = (1 - (d_dxx[ii] / dx)) * d_v0[index_work + nx] + (d_dxx[ii] / dx) * d_v0[index_work + 1 + nx];
Sensor.cu:        d_v34[idx] = (1 - (d_dxx[ii] / dx)) * d_v0[index_work] + (d_dxx[ii] / dx) * d_v0[index_work + 1];
Sensor.cu:        d_v0_int[idx] = (d_dyy[ii] / dy) * d_v12[idx] + (1 - (d_dyy[ii] / dy)) * d_v34[idx];
Sensor.cu:        if (k + d_terrain_face_id[d_site_id[ii]] - 1 > nz - 2) {
Sensor.cu:          id = nz - 2 + ii * nz;
Sensor.cu:          d_u0_int[id] = d_u_prof[nz - 2 + ii * nz];
Sensor.cu:          d_v0_int[id] = d_v_prof[nz - 2 + ii * nz];
Sensor.cu:          id = k + d_terrain_face_id[d_site_id[ii]] - 1 + ii * nz;
Sensor.cu:          d_u0_int[id] = d_u_prof[k + d_terrain_face_id[d_site_id[ii]] - 1 + ii * nz];
Sensor.cu:          d_v0_int[id] = d_v_prof[k + d_terrain_face_id[d_site_id[ii]] - 1 + ii * nz];
Sensor.cu:  int i = (ii - j * nx);
Sensor.cu:      if (k + d_terrain_face_id[ii] - 1 < nz) {
Sensor.cu:        d_k_mod[ii] = k + d_terrain_face_id[ii] - 1;
Sensor.cu:        if (k + d_terrain_face_id[d_site_id[id]] - 1 > nz - 2) {
Sensor.cu:          d_sum_wu[idx] = d_sum_wu[idx] + d_wm[id + i * num_sites + j * num_sites * nx] * (d_u_prof[nz - 2 + id * nz] - d_u0_int[nz - 2 + id * nz]);
Sensor.cu:          d_sum_wv[idx] = d_sum_wv[idx] + d_wm[id + i * num_sites + j * num_sites * nx] * (d_v_prof[nz - 2 + id * nz] - d_v0_int[nz - 2 + id * nz]);
Sensor.cu:          d_sum_wu[idx] = d_sum_wu[idx] + d_wm[id + i * num_sites + j * num_sites * nx] * (d_u_prof[k + d_terrain_face_id[d_site_id[id]] - 1 + id * nz] - d_u0_int[k + d_terrain_face_id[d_site_id[id]] - 1 + id * nz]);
Sensor.cu:          d_sum_wv[idx] = d_sum_wv[idx] + d_wm[id + i * num_sites + j * num_sites * nx] * (d_v_prof[k + d_terrain_face_id[d_site_id[id]] - 1 + id * nz] - d_v0_int[k + d_terrain_face_id[d_site_id[id]] - 1 + id * nz]);
Sensor.cu:      xc = d_site_xcoord[ii] - d_site_xcoord[i];
Sensor.cu:      yc = d_site_ycoord[ii] - d_site_ycoord[i];
Sensor.cu:  u_prof_1d.resize(num_sites * WGD->nz, 0.0);
Sensor.cu:  v_prof_1d.resize(num_sites * WGD->nz, 0.0);
Sensor.cu:  wm.resize(num_sites * WGD->nx * WGD->ny, 0.0);
Sensor.cu:  wms.resize(num_sites * WGD->nx * WGD->ny, 0.0);
Sensor.cu:  u0_int.resize(num_sites * WGD->nz, 0.0);
Sensor.cu:  v0_int.resize(num_sites * WGD->nz, 0.0);
Sensor.cu:  sum_wm.resize(WGD->nx * WGD->ny, 0.0);
Sensor.cu:  sum_wu.resize(WGD->nx * WGD->ny * WGD->nz, 0.0);
Sensor.cu:  sum_wv.resize(WGD->nx * WGD->ny * WGD->nz, 0.0);
Sensor.cu:  u12.resize(num_sites * WGD->nz, 0.0);
Sensor.cu:  u34.resize(num_sites * WGD->nz, 0.0);
Sensor.cu:  v12.resize(num_sites * WGD->nz, 0.0);
Sensor.cu:  v34.resize(num_sites * WGD->nz, 0.0);
Sensor.cu:  k_mod.resize(WGD->nx * WGD->ny, 1);
Sensor.cu:    for (auto k = 0; k < WGD->nz; k++) {
Sensor.cu:      int id = k + i * WGD->nz;
Sensor.cu:    site_xcoord[i] = WID->metParams->sensors[available_sensor_id[i]]->site_xcoord;
Sensor.cu:    site_ycoord[i] = WID->metParams->sensors[available_sensor_id[i]]->site_ycoord;
Sensor.cu:  x.resize(WGD->nx);
Sensor.cu:  for (size_t i = 0; i < WGD->nx; i++) {
Sensor.cu:    x[i] = (i - 0.5) * WGD->dx; /**< Location of face centers in x-dir */
Sensor.cu:  y.resize(WGD->ny);
Sensor.cu:  for (auto j = 0; j < WGD->ny; j++) {
Sensor.cu:    y[j] = (j - 0.5) * WGD->dy; /**< Location of face centers in y-dir */
Sensor.cu:  cudaMalloc((void **)&d_u_prof, num_sites * WGD->nz * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_v_prof, num_sites * WGD->nz * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_wm, num_sites * WGD->nx * WGD->ny * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_wms, num_sites * WGD->nx * WGD->ny * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_u0_int, num_sites * WGD->nz * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_v0_int, num_sites * WGD->nz * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_sum_wm, WGD->nx * WGD->ny * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_sum_wu, WGD->nx * WGD->ny * WGD->nz * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_sum_wv, WGD->nx * WGD->ny * WGD->nz * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_x, WGD->nx * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_y, WGD->ny * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_u0, WGD->numcell_face * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_v0, WGD->numcell_face * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_w0, WGD->numcell_face * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_u12, num_sites * WGD->nz * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_u34, num_sites * WGD->nz * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_v12, num_sites * WGD->nz * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_v34, num_sites * WGD->nz * sizeof(float));
Sensor.cu:  cudaMalloc((void **)&d_terrain_face_id, WGD->nx * WGD->ny * sizeof(int));
Sensor.cu:  cudaMalloc((void **)&d_k_mod, WGD->nx * WGD->ny * sizeof(int));
Sensor.cu:  cudaMemcpy(d_u_prof, u_prof_1d.data(), num_sites * WGD->nz * sizeof(int), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_v_prof, v_prof_1d.data(), num_sites * WGD->nz * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_wm, wm.data(), num_sites * WGD->nx * WGD->ny * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_wms, wms.data(), num_sites * WGD->nx * WGD->ny * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_u0_int, u0_int.data(), num_sites * WGD->nz * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_v0_int, v0_int.data(), num_sites * WGD->nz * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_sum_wm, sum_wm.data(), WGD->nx * WGD->ny * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_sum_wu, sum_wu.data(), WGD->nx * WGD->ny * WGD->nz * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_sum_wv, sum_wv.data(), WGD->nx * WGD->ny * WGD->nz * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_x, x.data(), WGD->nx * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_y, y.data(), WGD->ny * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_u0, WGD->u0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_v0, WGD->v0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_w0, WGD->w0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_u12, u12.data(), num_sites * WGD->nz * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_u34, u34.data(), num_sites * WGD->nz * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_v12, v12.data(), num_sites * WGD->nz * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_v34, v34.data(), num_sites * WGD->nz * sizeof(float), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_terrain_face_id, WGD->terrain_face_id.data(), WGD->nx * WGD->ny * sizeof(int), cudaMemcpyHostToDevice);
Sensor.cu:  cudaMemcpy(d_k_mod, k_mod.data(), WGD->nx * WGD->ny * sizeof(int), cudaMemcpyHostToDevice);
Sensor.cu:  BarnesScheme<<<1, 1>>>(d_u_prof, d_v_prof, d_wm, d_wms, d_u0_int, d_v0_int, d_x, d_y, d_site_xcoord, d_site_ycoord, d_sum_wm, d_sum_wu, d_sum_wv, d_u0, d_v0, d_w0, d_iwork, d_jwork, d_site_id, d_terrain_face_id, d_k_mod, d_dxx, d_dyy, d_u12, d_u34, d_v12, d_v34, num_sites, WGD->nx, WGD->ny, WGD->nz, WGD->dx, WGD->dy);
Sensor.cu:  cudaMemcpy(WGD->u0.data(), d_u0, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
Sensor.cu:  cudaMemcpy(WGD->v0.data(), d_v0, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
Sensor.cu:  cudaMemcpy(WGD->w0.data(), d_w0, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
Sensor.h: * This file is part of QES-Winds
Sensor.h: * GPL-3.0 License
Sensor.h: * QES-Winds is free software: you can redistribute it and/or modify
Sensor.h: * QES-Winds is distributed in the hope that it will be useful,
Sensor.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Sensor.h:   * @param WGD a pointer instance to the class WINDSGeneralData that contains data required to run QES-Winds
Sensor.h:   * @param WGD a pointer instance to the class WINDSGeneralData that contains data required to run QES-Winds
Sensor.h:   * @param WGD a pointer instance to the class WINDSGeneralData that contains data required to run QES-Winds
SharedMemory.cu: * This file is part of QES-Winds
SharedMemory.cu: * GPL-3.0 License
SharedMemory.cu: * QES-Winds is free software: you can redistribute it and/or modify
SharedMemory.cu: * QES-Winds is distributed in the hope that it will be useful,
SharedMemory.cu: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
SharedMemory.cu:    printf("\"%s\" at %d in %s\n\treturned %d\n-> %s\n", func, line, call, (int)e, cudaGetErrorString(e));
SharedMemory.cu:  int k = icell_cent / ((nx - 1) * (ny - 1));
SharedMemory.cu:  int j = (icell_cent - k * (nx - 1) * (ny - 1)) / (nx - 1);
SharedMemory.cu:  int i = icell_cent - k * (nx - 1) * (ny - 1) - j * (nx - 1);
SharedMemory.cu:  if ((i < nx - 1) && (j < ny - 1) && (k < nz - 1) && (i >= 0) && (j >= 0) && (k > 0)) {
SharedMemory.cu:    d_R[icell_cent] = (-2 * pow(alpha1, 2.0)) * (((d_e[icell_cent] * d_u0[icell_face + 1] - d_f[icell_cent] * d_u0[icell_face]) * dx) + ((d_g[icell_cent] * d_v0[icell_face + nx] - d_h[icell_cent] * d_v0[icell_face]) * dy) + (d_m[icell_cent] * d_dz_array[k] * 0.5 * (d_dz_array[k] + d_dz_array[k + 1]) * d_w0[icell_face + nx * ny] - d_n[icell_cent] * d_w0[icell_face] * d_dz_array[k] * 0.5 * (d_dz_array[k] + d_dz_array[k - 1])));
SharedMemory.cu:  int k = icell_cent / ((nx - 1) * (ny - 1));
SharedMemory.cu:  int j = (icell_cent - k * (nx - 1) * (ny - 1)) / (nx - 1);
SharedMemory.cu:  int i = icell_cent - k * (nx - 1) * (ny - 1) - j * (nx - 1);
SharedMemory.cu:  if ((i > 0) && (i < nx - 2) && (j > 0) && (j < ny - 2) && (k < nz - 2) && (k > 0) && ((i + j + k) % 2) == offset) {
SharedMemory.cu:    d_lambda[icell_cent] = (omega / (d_e[icell_cent] + d_f[icell_cent] + d_g[icell_cent] + d_h[icell_cent] + d_m[icell_cent] + d_n[icell_cent])) * (d_e[icell_cent] * d_lambda[icell_cent + 1] + d_f[icell_cent] * d_lambda[icell_cent - 1] + d_g[icell_cent] * d_lambda[icell_cent + (nx - 1)] + d_h[icell_cent] * d_lambda[icell_cent - (nx - 1)] + d_m[icell_cent] * d_lambda[icell_cent + (nx - 1) * (ny - 1)] + d_n[icell_cent] * d_lambda[icell_cent - (nx - 1) * (ny - 1)] - d_R[icell_cent]) + (1.0 - omega) * d_lambda[icell_cent];// SOR formulation
SharedMemory.cu:  if (ii < (nz - 1) * (ny - 1) * (nx - 1)) {
SharedMemory.cu:    d_lambda[ii] = d_lambda[ii + 1 * (nx - 1) * (ny - 1)];
SharedMemory.cu:  int d_size = (nx - 1) * (ny - 1) * (nz - 1);
SharedMemory.cu:    d_value[ii] = fabs(d_lambda[ii] - d_lambda_old[ii]);
SharedMemory.cu:  int j = (icell_face - k * nx * ny) / nx;
SharedMemory.cu:  int i = icell_face - k * nx * ny - j * nx;
SharedMemory.cu:  int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);// Lineralized index for cell centered values
SharedMemory.cu:  if ((i > 0) && (i < nx - 1) && (j > 0) && (j < ny - 1) && (k < nz - 2) && (k > 0)) {
SharedMemory.cu:    d_u[icell_face] = d_u[icell_face] + (1 / (2 * pow(alpha1, 2.0))) * d_f[icell_cent] * dx * (d_lambda[icell_cent] - d_lambda[icell_cent - 1]);
SharedMemory.cu:    d_v[icell_face] = d_v[icell_face] + (1 / (2 * pow(alpha1, 2.0))) * d_h[icell_cent] * dy * (d_lambda[icell_cent] - d_lambda[icell_cent - (nx - 1)]);
SharedMemory.cu:    d_w[icell_face] = d_w[icell_face] + (1 / (2 * pow(alpha2, 2.0))) * d_n[icell_cent] * d_dz_array[k] * (d_lambda[icell_cent] - d_lambda[icell_cent - (nx - 1) * (ny - 1)]);
SharedMemory.cu:  if ((i >= 0) && (i < nx - 1) && (j >= 0) && (j < ny - 1) && (k < nz - 1) && (k >= 1) && ((d_icellflag[icell_cent] == 0) || (d_icellflag[icell_cent] == 2))) {
SharedMemory.cu:  int numblocks = (WGD->numcell_cent / BLOCKSIZE) + 1;
SharedMemory.cu:  R.resize(WGD->numcell_cent, 0.0);
SharedMemory.cu:  lambda.resize(WGD->numcell_cent, 0.0);
SharedMemory.cu:  lambda_old.resize(WGD->numcell_cent, 0.0);
SharedMemory.cu:  std::vector<float> value(WGD->numcell_cent, 0.0);
SharedMemory.cu:  cudaMalloc((void **)&d_e, WGD->numcell_cent * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_f, WGD->numcell_cent * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_g, WGD->numcell_cent * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_h, WGD->numcell_cent * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_m, WGD->numcell_cent * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_n, WGD->numcell_cent * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_lambda, WGD->numcell_cent * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_lambda_old, WGD->numcell_cent * sizeof(float));
SharedMemory.cu:  /*cudaMalloc((void **)&d_u0, WGD->numcell_face * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_v0, WGD->numcell_face * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_w0, WGD->numcell_face * sizeof(float));*/
SharedMemory.cu:  cudaMalloc((void **)&d_dz_array, (WGD->nz - 1) * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_R, WGD->numcell_cent * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_value, WGD->numcell_cent * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_icellflag, WGD->numcell_cent * sizeof(int));
SharedMemory.cu:  cudaMalloc((void **)&d_u, WGD->numcell_face * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_v, WGD->numcell_face * sizeof(float));
SharedMemory.cu:  cudaMalloc((void **)&d_w, WGD->numcell_face * sizeof(float));
SharedMemory.cu:  /*cudaMemcpy(d_u0, WGD->u0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_v0, WGD->v0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_w0, WGD->w0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);*/
SharedMemory.cu:  cudaMemcpy(d_u, WGD->u0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_v, WGD->v0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_w, WGD->w0.data(), WGD->numcell_face * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_R, R.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_e, WGD->e.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_f, WGD->f.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_g, WGD->g.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_h, WGD->h.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_m, WGD->m.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_n, WGD->n.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_dz_array, WGD->dz_array.data(), (WGD->nz - 1) * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_lambda_old, lambda_old.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_value, value.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_lambda, lambda.data(), WGD->numcell_cent * sizeof(float), cudaMemcpyHostToDevice);
SharedMemory.cu:  cudaMemcpy(d_icellflag, WGD->icellflag.data(), WGD->numcell_cent * sizeof(int), cudaMemcpyHostToDevice);
SharedMemory.cu:  dim3 numberOfBlocks(ceil(((WGD->nx - 1) * (WGD->ny - 1) * (WGD->nz - 1)) / (float)(BLOCKSIZE)), 1, 1);
SharedMemory.cu:  divergenceShared<<<numberOfBlocks, numberOfThreadsPerBlock>>>(d_u, d_v, d_w, d_R, d_e, d_f, d_g, d_h, d_m, d_n, alpha1, WGD->nx, WGD->ny, WGD->nz, WGD->dx, WGD->dy, d_dz_array);
SharedMemory.cu:    /*for (int k = 0; k < WGD->nz-1; k++)
SharedMemory.cu:      for (int j = 0; j < WGD->ny-1; j++)
SharedMemory.cu:        for (int i = 0; i < WGD->nx-1; i++)
SharedMemory.cu:          int ii = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);   // Lineralize the vectors (make it 1D)
SharedMemory.cu:    saveLambdaShared<<<numberOfBlocks, numberOfThreadsPerBlock>>>(d_lambda, d_lambda_old, WGD->nx, WGD->ny, WGD->nz);
SharedMemory.cu:    // cudaMemcpy(d_lambda , lambda.data() , WGD->numcell_cent * sizeof(float) , cudaMemcpyHostToDevice);
SharedMemory.cu:    SOR_RB_Shared<<<numberOfBlocks, numberOfThreadsPerBlock>>>(d_lambda, WGD->nx, WGD->ny, WGD->nz, omega, A, B, d_e, d_f, d_g, d_h, d_m, d_n, d_R, offset);
SharedMemory.cu:    SOR_RB_Shared<<<numberOfBlocks, numberOfThreadsPerBlock>>>(d_lambda, WGD->nx, WGD->ny, WGD->nz, omega, A, B, d_e, d_f, d_g, d_h, d_m, d_n, d_R, offset);
SharedMemory.cu:    // cudaMemcpy (lambda.data() , d_lambda , WGD->numcell_cent * sizeof(float) , cudaMemcpyDeviceToHost);
SharedMemory.cu:    for (int j = 0; j < WGD->ny; j++)
SharedMemory.cu:      for (int i = 0; i < WGD->nx; i++)
SharedMemory.cu:        int ii = i + j*(WGD->nx-1);          // Lineralize the vectors (make it 1D)
SharedMemory.cu:        lambda[ii] = lambda[ii + (WGD->nx-1)*(WGD->ny-1)];
SharedMemory.cu:    dim3 numberOfBlocks2(ceil(((WGD->nx - 1) * (WGD->ny - 1)) / (float)(BLOCKSIZE)), 1, 1);
SharedMemory.cu:    applyNeumannBCShared<<<numberOfBlocks2, numberOfThreadsPerBlock>>>(d_lambda, WGD->nx, WGD->ny);
SharedMemory.cu:    for (int k = 0; k < WGD->nz-1; k++)
SharedMemory.cu:        for (int j = 0; j < WGD->ny-1; j++)
SharedMemory.cu:            for (int i = 0; i < WGD->nx-1; i++)
SharedMemory.cu:                int icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);   // Lineralized index for cell centered values
SharedMemory.cu:                error = fabs(lambda[icell_cent] - lambda_old[icell_cent]);
SharedMemory.cu:    calculateErrorShared<<<numberOfBlocks, numberOfThreadsPerBlock>>>(d_lambda, d_lambda_old, WGD->nx, WGD->ny, WGD->nz, d_value, d_bvalue, d_error);
SharedMemory.cu:  dim3 numberOfBlocks3(ceil((WGD->nx * WGD->ny * WGD->nz) / (float)(BLOCKSIZE)), 1, 1);
SharedMemory.cu:  finalVelocityShared<<<numberOfBlocks3, numberOfThreadsPerBlock>>>(d_lambda, d_u, d_v, d_w, d_icellflag, d_f, d_h, d_n, alpha1, alpha2, WGD->dx, WGD->dy, WGD->dz, d_dz_array, WGD->nx, WGD->ny, WGD->nz);
SharedMemory.cu:  cudaMemcpy(WGD->u.data(), d_u, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
SharedMemory.cu:  cudaMemcpy(WGD->v.data(), d_v, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
SharedMemory.cu:  cudaMemcpy(WGD->w.data(), d_w, WGD->numcell_face * sizeof(float), cudaMemcpyDeviceToHost);
SharedMemory.cu:  std::chrono::duration<float> elapsed = finish - start;
SharedMemory.h: * This file is part of QES-Winds
SharedMemory.h: * GPL-3.0 License
SharedMemory.h: * QES-Winds is free software: you can redistribute it and/or modify
SharedMemory.h: * QES-Winds is distributed in the hope that it will be useful,
SharedMemory.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Sidewall.cpp: * This file is part of QES-Winds
Sidewall.cpp: * GPL-3.0 License
Sidewall.cpp: * QES-Winds is free software: you can redistribute it and/or modify
Sidewall.cpp: * QES-Winds is distributed in the hope that it will be useful,
Sidewall.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Sidewall.cpp: * More information: "Comprehensive Evaluation of Fast-Response, Reynolds-Averaged Navier–Stokes, and Large-Eddy Simulation
Sidewall.cpp: * Methods Against High-Spatial-Resolution Wind-Tunnel Data in Step-Down Street Canyons, A. N. Hayati et al. (2017)"
Sidewall.cpp:  float tol = 10 * M_PI / 180.0;// Sidewall is applied if outward normal of the face is in +/-10 degree perpendicular
Sidewall.cpp:  float R_cx_side; /**< Downwind length of the half-ellipse that defines the vortex recirculation region */
Sidewall.cpp:  float x_start_left, x_end_left, x_start_right, x_end_right;// Start and end point of each left/right faces in x-direction
Sidewall.cpp:  float y_start_left, y_end_left, y_start_right, y_end_right;// Start and end point of each left/right faces in y-direction
Sidewall.cpp:  int index_building_face = i_building_cent + j_building_cent * WGD->nx + (k_end)*WGD->nx * WGD->ny;
Sidewall.cpp:  u0_h = WGD->u0[index_building_face];// u velocity at the height of building at the centroid
Sidewall.cpp:  v0_h = WGD->v0[index_building_face];// v velocity at the height of building at the centroid
Sidewall.cpp:    xi[id] = (polygonVertices[id].x_poly - building_cent_x) * cos(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * sin(upwind_dir);
Sidewall.cpp:    yi[id] = -(polygonVertices[id].x_poly - building_cent_x) * sin(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * cos(upwind_dir);
Sidewall.cpp:  for (auto id = 0; id < polygonVertices.size() - 1; id++) {
Sidewall.cpp:    face_rel_dir[id] = atan2(yi[id + 1] - yi[id], xi[id + 1] - xi[id]) + 0.5 * M_PI;
Sidewall.cpp:      face_rel_dir[id] -= 2 * M_PI;
Sidewall.cpp:    if (abs(face_rel_dir[id]) >= 0.5 * M_PI - tol && abs(face_rel_dir[id]) <= 0.5 * M_PI + tol) {
Sidewall.cpp:    // Smaller of the building height (H) and the effective cross-wind width (Weff)
Sidewall.cpp:    // Larger of the building height (H) and the effective cross-wind width (Weff)
Sidewall.cpp:    for (auto id = 0; id < polygonVertices.size() - 1; id++) {
Sidewall.cpp:      // +/-10 degree perpendicular to the local wind
Sidewall.cpp:      if (abs(face_rel_dir[id]) >= 0.5 * M_PI - tol && abs(face_rel_dir[id]) <= 0.5 * M_PI + tol) {
Sidewall.cpp:          index_previous = (id + polygonVertices.size() - 2) % (polygonVertices.size() - 1);
Sidewall.cpp:          if (abs(face_rel_dir[index_previous]) >= M_PI - tol) {
Sidewall.cpp:            face_length = sqrt(pow(x_start_left - x_end_left, 2.0) + pow(y_start_left - y_end_left, 2.0));
Sidewall.cpp:            face_dir = atan2(y_end_left - y_start_left, x_end_left - x_start_left);
Sidewall.cpp:          index_next = (id + 1) % (polygonVertices.size() - 1);
Sidewall.cpp:          if (abs(face_rel_dir[index_next]) >= M_PI - tol) {
Sidewall.cpp:            face_length = sqrt(pow(x_start_right - x_end_right, 2.0) + pow(y_start_right - y_end_right, 2.0));
Sidewall.cpp:            face_dir = atan2(y_end_right - y_start_right, x_end_right - x_start_right);
Sidewall.cpp:        for (auto k = k_end - 1; k >= k_start; k--) {
Sidewall.cpp:            i_start_right = ceil(x_start_right / WGD->dx) - 1;
Sidewall.cpp:            j_start_right = ceil(y_start_right / WGD->dy) - 1;
Sidewall.cpp:            for (auto j = MAX_S(0, j_start_right - 1); j <= MIN_S(WGD->ny - 2, j_start_right + 1); j++) {
Sidewall.cpp:              for (auto i = MAX_S(0, i_start_right - 1); i <= MIN_S(WGD->nx - 2, i_start_right + 1); i++) {
Sidewall.cpp:                icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Sidewall.cpp:                icell_face = i + j * (WGD->nx) + k * (WGD->nx) * (WGD->ny);
Sidewall.cpp:                if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 7) {
Sidewall.cpp:                  u0_right = WGD->u0[icell_face];
Sidewall.cpp:                  v0_right = WGD->v0[icell_face];
Sidewall.cpp:                else if (WGD->icellflag[icell_cent] == 1 || WGD->icellflag[icell_cent] == 3 || WGD->icellflag[icell_cent] == 11) {
Sidewall.cpp:              x_id_max = ceil(MAX_S(face_length, R_cx_side) / (0.5 * WGD->dxy));
Sidewall.cpp:                x_p = 0.5 * x_id * WGD->dxy;// x location of the point beng examined for parameterization in local coordinates
Sidewall.cpp:                y_id_max = (ceil(shell_width / (0.5 * WGD->dxy)) + 2);
Sidewall.cpp:                  y_p = -0.5 * y_id * WGD->dxy;// y location of the point beng examined for parameterization in local coordinates
Sidewall.cpp:                  x = x_start_right + x_p * cos(face_dir) - y_p * sin(face_dir);// x location in QUIC domain
Sidewall.cpp:                  int i = ceil(x / WGD->dx) - 1;
Sidewall.cpp:                  int j = ceil(y / WGD->dy) - 1;
Sidewall.cpp:                  icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Sidewall.cpp:                  icell_face = i + j * (WGD->nx) + k * (WGD->nx) * (WGD->ny);
Sidewall.cpp:                  if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2)// No solid cell
Sidewall.cpp:                    x_u = i * WGD->dx;// x location of u component
Sidewall.cpp:                    y_u = (j + 0.5) * WGD->dy;// y location of u component
Sidewall.cpp:                    xp_u = (x_u - x_start_right) * cos(face_dir) + (y_u - y_start_right) * sin(face_dir);
Sidewall.cpp:                    yp_u = -(x_u - x_start_right) * sin(face_dir) + (y_u - y_start_right) * cos(face_dir);
Sidewall.cpp:                    shell_width_calc = 1 - pow((0.5 * R_cx_side - xp_u) / (0.5 * R_cx_side), 2.0);
Sidewall.cpp:                      WGD->u0[icell_face] = -u0_right * abs((shell_width - abs(yp_u)) / vd);
Sidewall.cpp:                      WGD->u0[icell_face] = u0_right * log((abs(yp_u) + WGD->z0) / WGD->z0) / log((internal_BL_width + WGD->z0) / WGD->z0);
Sidewall.cpp:                    x_v = (i + 0.5) * WGD->dx;// x location of v component
Sidewall.cpp:                    y_v = j * WGD->dy;// y location of v component
Sidewall.cpp:                    xp_v = (x_v - x_start_right) * cos(face_dir) + (y_v - y_start_right) * sin(face_dir);
Sidewall.cpp:                    yp_v = -(x_v - x_start_right) * sin(face_dir) + (y_v - y_start_right) * cos(face_dir);
Sidewall.cpp:                    shell_width_calc = 1 - pow((0.5 * R_cx_side - xp_v) / (0.5 * R_cx_side), 2.0);
Sidewall.cpp:                      WGD->v0[icell_face] = -v0_right * abs((shell_width - abs(yp_v)) / vd);
Sidewall.cpp:                      WGD->v0[icell_face] = v0_right * log((abs(yp_v) + WGD->z0) / WGD->z0) / log((internal_BL_width + WGD->z0) / WGD->z0);
Sidewall.cpp:                    xp_c = (x_v - x_start_right) * cos(face_dir) + (y_u - y_start_right) * sin(face_dir);
Sidewall.cpp:                    yp_c = -(x_v - x_start_right) * sin(face_dir) + (y_u - y_start_right) * cos(face_dir);
Sidewall.cpp:                    shell_width_calc = 1 - pow((0.5 * R_cx_side - xp_c) / (0.5 * R_cx_side), 2.0);
Sidewall.cpp:                    if ((abs(yp_c) <= shell_width || abs(yp_c) <= internal_BL_width) && (WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
Sidewall.cpp:                      WGD->icellflag[icell_cent] = 9;// Cell marked as sidewall cell
Sidewall.cpp:            i_start_left = ceil(x_start_left / WGD->dx) - 1;
Sidewall.cpp:            j_start_left = ceil(y_start_left / WGD->dy) - 1;
Sidewall.cpp:            for (auto j = MAX_S(0, j_start_left - 1); j <= MIN_S(WGD->ny - 2, j_start_left + 1); j++) {
Sidewall.cpp:              for (auto i = MAX_S(0, i_start_left - 1); i <= MIN_S(WGD->nx - 2, i_start_left + 1); i++) {
Sidewall.cpp:                icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Sidewall.cpp:                icell_face = i + j * (WGD->nx) + k * (WGD->nx) * (WGD->ny);
Sidewall.cpp:                if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 7) {
Sidewall.cpp:                  u0_left = WGD->u0[icell_face];
Sidewall.cpp:                  v0_left = WGD->v0[icell_face];
Sidewall.cpp:                else if (WGD->icellflag[icell_cent] == 1 || WGD->icellflag[icell_cent] == 3 || WGD->icellflag[icell_cent] == 11) {
Sidewall.cpp:              x_id_max = ceil(MAX_S(face_length, R_cx_side) / (0.5 * WGD->dxy));
Sidewall.cpp:                x_p = 0.5 * x_id * WGD->dxy;// x location of the point beng examined for parameterization in local coordinates
Sidewall.cpp:                y_id_max = (ceil(shell_width / (0.5 * WGD->dxy)) + 2);
Sidewall.cpp:                  y_p = 0.5 * y_id * WGD->dxy;// y location of the point beng examined for parameterization in local coordinates
Sidewall.cpp:                  x = x_start_left + x_p * cos(face_dir) - y_p * sin(face_dir);// x location in QUIC domain
Sidewall.cpp:                  int i = ceil(x / WGD->dx) - 1;
Sidewall.cpp:                  int j = ceil(y / WGD->dy) - 1;
Sidewall.cpp:                  icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Sidewall.cpp:                  icell_face = i + j * (WGD->nx) + k * (WGD->nx) * (WGD->ny);
Sidewall.cpp:                  if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2)// No solid cell
Sidewall.cpp:                    x_u = i * WGD->dx;// x location of u component
Sidewall.cpp:                    y_u = (j + 0.5) * WGD->dy;// y location of u component
Sidewall.cpp:                    xp_u = (x_u - x_start_left) * cos(face_dir) + (y_u - y_start_left) * sin(face_dir);
Sidewall.cpp:                    yp_u = -(x_u - x_start_left) * sin(face_dir) + (y_u - y_start_left) * cos(face_dir);
Sidewall.cpp:                    shell_width_calc = 1 - pow((0.5 * R_cx_side - xp_u) / (0.5 * R_cx_side), 2.0);
Sidewall.cpp:                      WGD->u0[icell_face] = -u0_left * abs((shell_width - abs(yp_u)) / vd);
Sidewall.cpp:                      WGD->u0[icell_face] = u0_left * log((abs(yp_u) + WGD->z0) / WGD->z0) / log((internal_BL_width + WGD->z0) / WGD->z0);
Sidewall.cpp:                    x_v = (i + 0.5) * WGD->dx;// x location of v component
Sidewall.cpp:                    y_v = j * WGD->dy;// y location of v component
Sidewall.cpp:                    xp_v = (x_v - x_start_left) * cos(face_dir) + (y_v - y_start_left) * sin(face_dir);
Sidewall.cpp:                    yp_v = -(x_v - x_start_left) * sin(face_dir) + (y_v - y_start_left) * cos(face_dir);
Sidewall.cpp:                    shell_width_calc = 1 - pow((0.5 * R_cx_side - xp_v) / (0.5 * R_cx_side), 2.0);
Sidewall.cpp:                      WGD->v0[icell_face] = -v0_left * abs((shell_width - abs(yp_v)) / vd);
Sidewall.cpp:                      WGD->v0[icell_face] = v0_left * log((abs(yp_v) + WGD->z0) / WGD->z0) / log((internal_BL_width + WGD->z0) / WGD->z0);
Sidewall.cpp:                    xp_c = (x_v - x_start_left) * cos(face_dir) + (y_u - y_start_left) * sin(face_dir);
Sidewall.cpp:                    yp_c = -(x_v - x_start_left) * sin(face_dir) + (y_u - y_start_left) * cos(face_dir);
Sidewall.cpp:                    shell_width_calc = 1 - pow((0.5 * R_cx_side - xp_c) / (0.5 * R_cx_side), 2.0);
Sidewall.cpp:                    if ((abs(yp_c) <= shell_width || abs(yp_c) <= internal_BL_width) && (WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
Sidewall.cpp:                      WGD->icellflag[icell_cent] = 9;// Cell marked as sidewall cell
SimulationParameters.h: * This file is part of QES-Winds
SimulationParameters.h: * GPL-3.0 License
SimulationParameters.h: * QES-Winds is free software: you can redistribute it and/or modify
SimulationParameters.h: * QES-Winds is distributed in the hope that it will be useful,
SimulationParameters.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
SimulationParameters.h:  double tolerance = 1e-9; /**< :document this: */
SimulationParameters.h:  // DTE - digital elevation model details
SimulationParameters.h:  // Two use-cases are now supported:
SimulationParameters.h:  // - We are not yet checking if no fire mesh is specified.  If no
SimulationParameters.h:      DTE_heightField->closeScanner();
SimulationParameters.h:      // DEM - read in terrain
SimulationParameters.h:      // WRF - retrieve wind profiles only
SimulationParameters.h:      // WRF - pull terrain and retrieve wind profiles
SimulationParameters.h:      // Only DEM Specified - nothing set for WRF Input
SimulationParameters.h:      // Apply halo to wind profile locations -- halo units are
SimulationParameters.h:      wrfInputData->applyHalotoStationData(halo_x, halo_y);
SimulationParameters.h:      wrfInputData->dumpStationData();
SimulationParameters.h:      DTE_heightField = new DTEHeightField(wrfInputData->fmHeight,
SimulationParameters.h:                                           std::tuple<int, int, int>(wrfInputData->fm_nx, wrfInputData->fm_ny, wrfInputData->fm_nz),
SimulationParameters.h:                                           std::tuple<float, float, float>(wrfInputData->fm_dx, wrfInputData->fm_dy, wrfInputData->fm_dz),
SimulationParameters.h:      (*(grid))[0] = wrfInputData->fm_dx;
SimulationParameters.h:      (*(grid))[1] = wrfInputData->fm_dy;
SimulationParameters.h:      std::cout << "Dim: " << wrfInputData->fm_nx << " X " << wrfInputData->fm_ny << " X " << wrfInputData->fm_nz << std::endl;
SimulationParameters.h:      domain = new Vector3Int(wrfInputData->fm_nx, wrfInputData->fm_nx, wrfInputData->fm_nz);
SimulationParameters.h:      DTE_heightField->setDomain(domain, grid);
SimulationParameters.h:      int halo_x_WRFAddition = (int)floor(halo_x / wrfInputData->fm_dx);
SimulationParameters.h:      int halo_y_WRFAddition = (int)floor(halo_y / wrfInputData->fm_dy);
SimulationParameters.h:      wrfInputData->setHaloAdditions(halo_x_WRFAddition, halo_y_WRFAddition);
SimulationParameters.h:      DTE_mesh = new Mesh(DTE_heightField->getTris());
SimulationParameters.h:      DTE_heightField->setDomain(domain, grid);
SimulationParameters.h:      DTE_mesh = new Mesh(DTE_heightField->getTris());
SimulationParameters.h:      // the lower-left bounds from the DEM if UTMx and UTMy and
SimulationParameters.h:      if (((UTMx > -uEps) && (UTMx < uEps)) && ((UTMy > -uEps) && (UTMy < uEps)) && (UTMZone == 0)) {
SimulationParameters.h:        std::cout << "UTM (" << UTMx << ", " << UTMy << "), Zone: " << UTMZone << " will be used as lower-left location for DEM." << std::endl;
SimulationParameters.h:      DTE_heightField->setDomain(domain, grid);
SimulationParameters.h:      DTE_mesh = new Mesh(DTE_heightField->getTris());
Solver.cpp: * This file is part of QES-Winds
Solver.cpp: * GPL-3.0 License
Solver.cpp: * QES-Winds is free software: you can redistribute it and/or modify
Solver.cpp: * QES-Winds is distributed in the hope that it will be useful,
Solver.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Solver.cpp:  int rpad = PBWIDTH - lpad;
Solver.cpp: * @note this is only meant to work with QES-Winds!
Solver.cpp:    A(pow((WGD->dx / WGD->dy), 2.0)),
Solver.cpp:    B(eta * pow((WGD->dx / WGD->dz), 2.0)),
Solver.cpp:    itermax(WID->simParams->maxIterations)
Solver.cpp:  tol = WID->simParams->tolerance;
Solver.h: * This file is part of QES-Winds
Solver.h: * GPL-3.0 License
Solver.h: * QES-Winds is free software: you can redistribute it and/or modify
Solver.h: * QES-Winds is distributed in the hope that it will be useful,
Solver.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Solver.h:  const float omega = 1.78f; /**< Over-relaxation factor */
Solver.h:  // SOLVER-based parameters
SphereDirections.cpp: * This file is part of QES-Winds
SphereDirections.cpp: * GPL-3.0 License
SphereDirections.cpp: * QES-Winds is free software: you can redistribute it and/or modify
SphereDirections.cpp: * QES-Winds is distributed in the hope that it will be useful,
SphereDirections.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
SphereDirections.cpp:   nextList[1] = *(new Vector3(-1,0,0));  //back
SphereDirections.cpp:   nextList[3] = *(new Vector3(0,-1,0));  //right
SphereDirections.cpp:   nextList[5] = *(new Vector3(0,0,-1));  //bottom
SphereDirections.cpp:   nextList[1] = Vector3(-1,0,0);  //back
SphereDirections.cpp:   nextList[3] = Vector3(0,-1,0);  //right
SphereDirections.cpp:   nextList[5] = Vector3(0,0,-1);  //bottom
SphereDirections.cpp:   this->numDirVec = numDirVec;
SphereDirections.cpp:   this->numDirVec = numDirVec;
SphereDirections.cpp:   this->lowerThetaBound = lowerThetaBound;
SphereDirections.cpp:   this->upperThetaBound = upperThetaBound;
SphereDirections.cpp:   this->lowerPhiBound = lowerPhiBound;
SphereDirections.cpp:   this->upperPhiBound = upperPhiBound;
SphereDirections.cpp:   nextList[0] = *(new Vector3(0,0,-1));
SphereDirections.h: * This file is part of QES-Winds
SphereDirections.h: * GPL-3.0 License
SphereDirections.h: * QES-Winds is free software: you can redistribute it and/or modify
SphereDirections.h: * QES-Winds is distributed in the hope that it will be useful,
SphereDirections.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
SphereDirections.h:    nextList[1] = Vec3D(-1, 0, 0);// back
SphereDirections.h:    nextList[3] = Vec3D(0, -1, 0);// right
SphereDirections.h:    nextList[5] = Vec3D(0, 0, -1);// bottom
SphereDirections.h:    // added -- up is unlikely at this point
SphereDirections.h:    nextList[numDV + 1] = Vec3D(-1, 0, 0);// back
SphereDirections.h:    nextList[numDV + 3] = Vec3D(0, -1, 0);// right
SphereDirections.h:    nextList[numDV + 4] = Vec3D(0, 0, -1);// bottom
SphereDirections.h:      vecCount = numDirs - 1;
SphereDirections.h:   *@return the next non-repeated directional vector
StreetCanyon.cpp: * This file is part of QES-Winds
StreetCanyon.cpp: * GPL-3.0 License
StreetCanyon.cpp: * QES-Winds is free software: you can redistribute it and/or modify
StreetCanyon.cpp: * QES-Winds is distributed in the hope that it will be useful,
StreetCanyon.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
StreetCanyon.cpp: * More information: "Improvements to a fast-response WINDSan wind model, M. Nelson et al. (2008)"
StreetCanyon.cpp:  int index_building_face = i_building_cent + j_building_cent * WGD->nx + (k_end)*WGD->nx * WGD->ny;
StreetCanyon.cpp:  u0_h = WGD->u0[index_building_face];// u velocity at the height of building at the centroid
StreetCanyon.cpp:  v0_h = WGD->v0[index_building_face];// v velocity at the height of building at the centroid
StreetCanyon.cpp:    xi[id] = (polygonVertices[id].x_poly - building_cent_x) * cos(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * sin(upwind_dir);
StreetCanyon.cpp:    yi[id] = -(polygonVertices[id].x_poly - building_cent_x) * sin(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * cos(upwind_dir);
StreetCanyon.cpp:  for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
StreetCanyon.cpp:    // Calculate upwind reletive direction for each face (out-facing normal)
StreetCanyon.cpp:    upwind_rel_dir[id] = atan2(yi[id + 1] - yi[id], xi[id + 1] - xi[id]) + 0.5 * M_PI;
StreetCanyon.cpp:    // Force the angle to be between (-pi;pi]
StreetCanyon.cpp:      upwind_rel_dir[id] -= 2.0 * M_PI;
StreetCanyon.cpp:    // valid only if relative angle between back face of building and wind angle is (-0.5*pi;0.5*pi)
StreetCanyon.cpp:    if (abs(upwind_rel_dir[id]) < 0.5 * M_PI - 0.0001) {
StreetCanyon.cpp:      if (abs(upwind_rel_dir[id]) > M_PI - tol || abs(upwind_rel_dir[id]) < tol) {
StreetCanyon.cpp:      // Calculating perpendicula direction to each face (out-facing nomral)
StreetCanyon.cpp:      perpendicular_dir[id] = atan2(polygonVertices[id + 1].y_poly - polygonVertices[id].y_poly,
StreetCanyon.cpp:                                    polygonVertices[id + 1].x_poly - polygonVertices[id].x_poly)
StreetCanyon.cpp:      // Force the angle to be between (-pi;pi]
StreetCanyon.cpp:        perpendicular_dir[id] -= 2.0 * M_PI;
StreetCanyon.cpp:      for (auto y_id = 0; y_id <= 2 * ceil(abs(yi[id] - yi[id + 1]) / WGD->dxy); y_id++) {
StreetCanyon.cpp:        yc = MIN_S(yi[id], yi[id + 1]) + 0.5 * y_id * WGD->dxy;
StreetCanyon.cpp:        // reset flag for every y-location along the face (if inside the canyon)
StreetCanyon.cpp:          x_wall = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (yc - yi[id]) + xi[id];
StreetCanyon.cpp:        for (auto k = k_end - 1; k >= k_start; k--) {
StreetCanyon.cpp:          int i1 = ceil(((x_wall - WGD->dxy) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx) - 1;
StreetCanyon.cpp:          int j1 = ceil(((x_wall - WGD->dxy) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy) - 1;
StreetCanyon.cpp:          icell_cent = i1 + j1 * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyon.cpp:          if (WGD->icellflag[icell_cent] != 0)
StreetCanyon.cpp:          x_id_min = -1;
StreetCanyon.cpp:          for (auto x_id = 1; x_id <= 2 * ceil(Lr / WGD->dxy); x_id++) {
StreetCanyon.cpp:            xc = 0.5 * x_id * WGD->dxy;
StreetCanyon.cpp:            int i = ceil(((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx) - 1;
StreetCanyon.cpp:            int j = ceil(((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy) - 1;
StreetCanyon.cpp:            icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyon.cpp:            if (i >= WGD->nx - 2 && i <= 0 && j >= WGD->ny - 2 && j <= 0) {
StreetCanyon.cpp:            icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyon.cpp:            if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2 && x_id_min < 0) {
StreetCanyon.cpp:            if ((WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2) && x_id_min >= 0) {
StreetCanyon.cpp:              x_id_max = x_id - 1;
StreetCanyon.cpp:              s = 0.5 * (x_id_max - x_id_min) * WGD->dxy;
StreetCanyon.cpp:                int ic = ceil(((0.5 * x_id_max * WGD->dxy + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x - 0.001) / WGD->dx) - 1;
StreetCanyon.cpp:                int jc = ceil(((0.5 * x_id_max * WGD->dxy + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y - 0.001) / WGD->dy) - 1;
StreetCanyon.cpp:                icell_cent = ic + jc * (WGD->nx - 1) + k_ref * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyon.cpp:                int icell_face = ic + jc * WGD->nx + k_ref * WGD->nx * WGD->ny;
StreetCanyon.cpp:                if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
StreetCanyon.cpp:                  if (WGD->icellflag[icell_cent - 1] != 0 && WGD->icellflag[icell_cent - 1] != 2) {
StreetCanyon.cpp:                    u_component += WGD->u0[icell_face];
StreetCanyon.cpp:                  if (WGD->icellflag[icell_cent + 1] != 0 && WGD->icellflag[icell_cent + 1] != 2) {
StreetCanyon.cpp:                    u_component += WGD->u0[icell_face + 1];
StreetCanyon.cpp:                  if (WGD->icellflag[icell_cent - (WGD->nx - 1)] != 0 && WGD->icellflag[icell_cent - (WGD->nx - 1)] != 2) {
StreetCanyon.cpp:                    v_component += WGD->v0[icell_face];
StreetCanyon.cpp:                  if (WGD->icellflag[icell_cent + (WGD->nx - 1)] != 0 && WGD->icellflag[icell_cent + (WGD->nx - 1)] != 2) {
StreetCanyon.cpp:                    v_component += WGD->v0[icell_face + WGD->nx];
StreetCanyon.cpp:                    // mean velocity along +/-x
StreetCanyon.cpp:                    // mean velocity along +/- y
StreetCanyon.cpp:                      canyon_dir = -0.5 * M_PI;
StreetCanyon.cpp:                  // flag=1 -> top of canyon set, velocity and direction set
StreetCanyon.cpp:                  // this if-block will not be executed unless flag is reset
StreetCanyon.cpp:                  icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyon.cpp:                    if ((WGD->ibuilding_flag[icell_cent] >= 0)
StreetCanyon.cpp:                        && (WGD->allBuildingsV[WGD->ibuilding_flag[icell_cent]]->height_eff < height_eff)
StreetCanyon.cpp:                        && (WGD->z_face[k] / s < 0.65)) {
StreetCanyon.cpp:                if (velocity_mag > WGD->max_velmag) {
StreetCanyon.cpp:              icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyon.cpp:              if (WGD->ibuilding_flag[icell_cent] >= 0) {
StreetCanyon.cpp:                d_build = WGD->ibuilding_flag[icell_cent];
StreetCanyon.cpp:                int i = ceil(((xc - 0.5 * WGD->dxy + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x - 0.001) / WGD->dx) - 1;
StreetCanyon.cpp:                int j = ceil(((xc - 0.5 * WGD->dxy + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y - 0.001) / WGD->dy) - 1;
StreetCanyon.cpp:                if (WGD->ibuilding_flag[i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1)] >= 0) {
StreetCanyon.cpp:                for (size_t j_id = 0; j_id < WGD->allBuildingsV[d_build]->polygonVertices.size() - 1; j_id++) {
StreetCanyon.cpp:                  // normal direction (out-facing normal) of face of downstream building (ref as db-face for that loop)
StreetCanyon.cpp:                  facenormal_dir = atan2(WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].y_poly
StreetCanyon.cpp:                                           - WGD->allBuildingsV[d_build]->polygonVertices[j_id].y_poly,
StreetCanyon.cpp:                                         WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].x_poly
StreetCanyon.cpp:                                           - WGD->allBuildingsV[d_build]->polygonVertices[j_id].x_poly)
StreetCanyon.cpp:                  // forcing facenormal_dir to be in (-pi,pi]
StreetCanyon.cpp:                    facenormal_dir -= 2.0 * M_PI;
StreetCanyon.cpp:                  if (facenormal_dir <= -M_PI) {
StreetCanyon.cpp:                  // (x,y) mid point of db-face
StreetCanyon.cpp:                  x_ave = 0.5 * (WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].x_poly + WGD->allBuildingsV[d_build]->polygonVertices[j_id].x_poly);
StreetCanyon.cpp:                  y_ave = 0.5 * (WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].y_poly + WGD->allBuildingsV[d_build]->polygonVertices[j_id].y_poly);
StreetCanyon.cpp:                  // x-/y-componants of segment between current location (center of cell) and mid-point of bd-face
StreetCanyon.cpp:                  // -> relative to the normal of current face  (facenormal_dir)
StreetCanyon.cpp:                  x_down = ((i + 0.5) * WGD->dx - x_ave) * cos(facenormal_dir) + ((j + 0.5) * WGD->dy - y_ave) * sin(facenormal_dir);
StreetCanyon.cpp:                  y_down = -((i + 0.5) * WGD->dx - x_ave) * sin(facenormal_dir) + ((j + 0.5) * WGD->dy - y_ave) * cos(facenormal_dir);
StreetCanyon.cpp:                     - reverse flow = flow go down along front face - up along back face
StreetCanyon.cpp:                     - otherwise    = flow go up along front face - down along back face
StreetCanyon.cpp:                     1) check if location of current cell against db-face
StreetCanyon.cpp:                     |  x-dir (relative to center of face): location within one cell
StreetCanyon.cpp:                     |  y-dir (relative to center of face): less that 1/2 the length of the face
StreetCanyon.cpp:                     2) check relative angle between wind and bd-face :
StreetCanyon.cpp:                     |  if smaller that +/- 0.5pi -> flow reverse
StreetCanyon.cpp:                     |  else -> no flow reverse
StreetCanyon.cpp:                     |  cross_dir = angle of the projection of the canyon_dir wind on the perpendicular dir to the db-face (facenormal_dir)
StreetCanyon.cpp:		     |  along_dir = angle of the projection of the canyon_dir wind on the parallel dir to the db-face (facenormal_dir)
StreetCanyon.cpp:                     -> exit loop on db faces at first valid face (condition 1)
StreetCanyon.cpp:                  // checking distance to face of down-wind building
StreetCanyon.cpp:                  if (std::abs(x_down) < 1.0 * WGD->dxy) {
StreetCanyon.cpp:                    segment_length = sqrt(pow(WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].x_poly
StreetCanyon.cpp:                                                - WGD->allBuildingsV[d_build]->polygonVertices[j_id].x_poly,
StreetCanyon.cpp:                                          + pow(WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].y_poly
StreetCanyon.cpp:                                                  - WGD->allBuildingsV[d_build]->polygonVertices[j_id].y_poly,
StreetCanyon.cpp:                      downwind_rel_dir = canyon_dir - facenormal_dir;
StreetCanyon.cpp:                      // forcing downwind_rel_dir to be in [-pi,pi] and check for round-off error
StreetCanyon.cpp:                        downwind_rel_dir -= 2.0 * M_PI;
StreetCanyon.cpp:                      // forcing downwind_rel_dir to be in [-pi,pi] and check for round-off error
StreetCanyon.cpp:                      if (downwind_rel_dir <= -M_PI) {
StreetCanyon.cpp:                        // out-facing normal and wind at reference cell 'same' direction
StreetCanyon.cpp:                        // out-facing normal and wind at reference cell 'opposite' direction
StreetCanyon.cpp:                        along_dir = facenormal_dir - 0.5 * M_PI;
StreetCanyon.cpp:                      if (cos(facenormal_dir - perpendicular_dir[id]) > cos(angle_tol)) {
StreetCanyon.cpp:                // angle need to be (-pi;-0.75*pi) or (0.75*pi;pi)
StreetCanyon.cpp:                if (cos(facenormal_dir - perpendicular_dir[id]) > cos(angle_tol)) {
StreetCanyon.cpp:                  // angle need to be (-0.25*pi;0.25*pi)
StreetCanyon.cpp:                  //if (cos(cross_dir - perpendicular_dir[id]) < -cos(angle_tol)) {
StreetCanyon.cpp:                  if (cos(cross_dir - perpendicular_dir[id]) > cos(angle_tol)) {
StreetCanyon.cpp:                  // angle need to be (-pi;-0.75*pi) or (0.75*pi;pi)
StreetCanyon.cpp:                  if (cos(cross_dir - perpendicular_dir[id]) > cos(angle_tol)) {
StreetCanyon.cpp:          // forcing along_dir to be in [-pi,pi]
StreetCanyon.cpp:            cross_dir -= 2.0 * M_PI;
StreetCanyon.cpp:          if (cross_dir <= -M_PI) {
StreetCanyon.cpp:          // forcing along_dir to be in [-pi,pi]
StreetCanyon.cpp:            along_dir -= 2.0 * M_PI;
StreetCanyon.cpp:          if (along_dir <= -M_PI) {
StreetCanyon.cpp:          if (canyon_flag == 1 && s > 0.9 * WGD->dxy) {
StreetCanyon.cpp:            along_vel_mag = abs(velocity_mag * cos(canyon_dir - along_dir)) * log(WGD->z[k] / WGD->z0) / log(WGD->z[k_ref] / WGD->z0);
StreetCanyon.cpp:            cross_vel_mag = abs(velocity_mag * cos(canyon_dir - cross_dir));
StreetCanyon.cpp:              xc = 0.5 * x_id * WGD->dxy;
StreetCanyon.cpp:              int i = ceil(((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x - 0.001) / WGD->dx) - 1;
StreetCanyon.cpp:              int j = ceil(((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y - 0.001) / WGD->dy) - 1;
StreetCanyon.cpp:              //icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyon.cpp:              //if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
StreetCanyon.cpp:              /* u-velocity parameterization (face)
StreetCanyon.cpp:		i_u x-index of u-face (j does not need correction cell)
StreetCanyon.cpp:		x_p,y_p non-rotated relative to building center (u-face)
StreetCanyon.cpp:		x_u,y_u rotated relative to building center (u-face)
StreetCanyon.cpp:              i_u = std::round(((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx);
StreetCanyon.cpp:              x_p = i_u * WGD->dx - building_cent_x;
StreetCanyon.cpp:              y_p = (j + 0.5) * WGD->dy - building_cent_y;
StreetCanyon.cpp:              y_u = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
StreetCanyon.cpp:                x_wall_u = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (y_u - yi[id]) + xi[id];
StreetCanyon.cpp:              x_pos = x_u - x_wall_u;
StreetCanyon.cpp:              //if (x_pos <= s + 0.001 && x_pos > -0.5 * WGD->dxy) {
StreetCanyon.cpp:              if (x_pos > -0.5 * WGD->dxy && x_pos <= s + 0.5 * WGD->dxy) {
StreetCanyon.cpp:                icell_face = i_u + j * WGD->nx + k * WGD->nx * WGD->ny;
StreetCanyon.cpp:                WGD->u0[icell_face] = along_vel_mag * cos(along_dir) + cross_vel_mag * (2 * x_pos / s) * 2 * (1 - x_pos / s) * cos(cross_dir);
StreetCanyon.cpp:              // end of u-velocity parameterization
StreetCanyon.cpp:              /* v-velocity parameterization (face)
StreetCanyon.cpp:		j_v y-index of v-face (i does not need correction cell)
StreetCanyon.cpp:		x_p,y_p non-rotated relative to building center (v-face)
StreetCanyon.cpp:		x_u,y_u rotated relative to building center (u-face)
StreetCanyon.cpp:              j_v = std::round(((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy);
StreetCanyon.cpp:              x_p = (i + 0.5) * WGD->dx - building_cent_x;
StreetCanyon.cpp:              y_p = j_v * WGD->dy - building_cent_y;
StreetCanyon.cpp:              y_v = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
StreetCanyon.cpp:                x_wall_v = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (y_v - yi[id]) + xi[id];
StreetCanyon.cpp:              x_pos = x_v - x_wall_v;
StreetCanyon.cpp:              //if (x_pos <= s + 0.001 && x_pos > -0.5 * WGD->dxy) {
StreetCanyon.cpp:              if (x_pos > -0.5 * WGD->dxy && x_pos <= s + 0.5 * WGD->dxy) {
StreetCanyon.cpp:                icell_face = i + j_v * WGD->nx + k * WGD->nx * WGD->ny;
StreetCanyon.cpp:                WGD->v0[icell_face] = along_vel_mag * sin(along_dir) + cross_vel_mag * (2 * x_pos / s) * 2 * (1 - x_pos / s) * sin(cross_dir);
StreetCanyon.cpp:              // end of v-velocity parameterization
StreetCanyon.cpp:              /* w-velocity parameterization (face) and cellflag (cell)
StreetCanyon.cpp:		x_p,y_p non-rotated relative to building center (w-face/cell)
StreetCanyon.cpp:		x_w,y_w rotated relative to building center (w-face/cell)
StreetCanyon.cpp:              x_p = (i + 0.5) * WGD->dx - building_cent_x;
StreetCanyon.cpp:              y_p = (j + 0.5) * WGD->dy - building_cent_y;
StreetCanyon.cpp:              y_w = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
StreetCanyon.cpp:                x_wall_w = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (y_w - yi[id]) + xi[id];
StreetCanyon.cpp:              x_pos = x_w - x_wall_w;
StreetCanyon.cpp:              //if (x_pos <= s + 0.001 && x_pos > -0.5 * WGD->dxy) {
StreetCanyon.cpp:              if (x_pos > -0.5 * WGD->dxy && x_pos <= s + 0.5 * WGD->dxy) {
StreetCanyon.cpp:                icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyon.cpp:                if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2
StreetCanyon.cpp:                    && WGD->icellflag[icell_cent - (WGD->nx - 1) * (WGD->ny - 1)] != 0
StreetCanyon.cpp:                    && WGD->icellflag[icell_cent - (WGD->nx - 1) * (WGD->ny - 1)] != 2) {
StreetCanyon.cpp:                  icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
StreetCanyon.cpp:                    // flow go up along front face - down along back face
StreetCanyon.cpp:                    WGD->w0[icell_face] = -abs(0.5 * cross_vel_mag * (1 - 2 * x_pos / s)) * (1 - 2 * (s - x_pos) / s);
StreetCanyon.cpp:                    // flow go down along front face - up along back face
StreetCanyon.cpp:                    WGD->w0[icell_face] = abs(0.5 * cross_vel_mag * (1 - 2 * x_pos / s)) * (1 - 2 * (s - x_pos) / s);
StreetCanyon.cpp:                if ((WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
StreetCanyon.cpp:                  WGD->icellflag[icell_cent] = 6;
StreetCanyon.cpp:              // end of w-velocity parameterization
StreetCanyonModified.cpp: * This file is part of QES-Winds
StreetCanyonModified.cpp: * GPL-3.0 License
StreetCanyonModified.cpp: * QES-Winds is free software: you can redistribute it and/or modify
StreetCanyonModified.cpp: * QES-Winds is distributed in the hope that it will be useful,
StreetCanyonModified.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
StreetCanyonModified.cpp: * More information: "Improvements to a fast-response WINDSan wind model, M. Nelson et al. (2008)"
StreetCanyonModified.cpp:  // FM -> needed for generalization (TODO)
StreetCanyonModified.cpp:  upwind_rel_dir.resize(polygonVertices.size() - 1, 0.0);// Upwind reletive direction for each face
StreetCanyonModified.cpp:  valid_face_flag.resize(polygonVertices.size() - 1, false);
StreetCanyonModified.cpp:  perpendicular_flag.resize(polygonVertices.size() - 1, 0);
StreetCanyonModified.cpp:  perpendicular_dir.resize(polygonVertices.size() - 1, 0.0);
StreetCanyonModified.cpp:  int index_building_face = i_building_cent + j_building_cent * WGD->nx + (k_end)*WGD->nx * WGD->ny;
StreetCanyonModified.cpp:  u0_h = WGD->u0[index_building_face];// u velocity at the height of building at the centroid
StreetCanyonModified.cpp:  v0_h = WGD->v0[index_building_face];// v velocity at the height of building at the centroid
StreetCanyonModified.cpp:    xi[id] = (polygonVertices[id].x_poly - building_cent_x) * cos(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * sin(upwind_dir);
StreetCanyonModified.cpp:    yi[id] = -(polygonVertices[id].x_poly - building_cent_x) * sin(upwind_dir) + (polygonVertices[id].y_poly - building_cent_y) * cos(upwind_dir);
StreetCanyonModified.cpp:  for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
StreetCanyonModified.cpp:    // Calculate upwind reletive direction for each face (out-facing normal)
StreetCanyonModified.cpp:    upwind_rel_dir[id] = atan2(yi[id + 1] - yi[id], xi[id + 1] - xi[id]) + 0.5 * M_PI;
StreetCanyonModified.cpp:    // Force the angle to be between (-pi;pi]
StreetCanyonModified.cpp:      upwind_rel_dir[id] -= 2.0 * M_PI;
StreetCanyonModified.cpp:    // valid only if relative angle between back face of building and wind angle is (-0.5*pi;0.5*pi)
StreetCanyonModified.cpp:    if (std::abs(upwind_rel_dir[id]) < 0.5 * M_PI - 0.0001) {
StreetCanyonModified.cpp:  for (size_t id = 0; id < polygonVertices.size() - 1; id++) {
StreetCanyonModified.cpp:      if (std::abs(upwind_rel_dir[id]) > M_PI - tol || std::abs(upwind_rel_dir[id]) < tol) {
StreetCanyonModified.cpp:      // Calculating perpendicula direction to each face (out-facing nomral)
StreetCanyonModified.cpp:      perpendicular_dir[id] = atan2(polygonVertices[id + 1].y_poly - polygonVertices[id].y_poly,
StreetCanyonModified.cpp:                                    polygonVertices[id + 1].x_poly - polygonVertices[id].x_poly)
StreetCanyonModified.cpp:      // Force the angle to be between (-pi;pi]
StreetCanyonModified.cpp:        perpendicular_dir[id] -= 2.0 * M_PI;
StreetCanyonModified.cpp:      // FM -> needed for generalization (TODO)
StreetCanyonModified.cpp:      //canyon_L_flag = -1;
StreetCanyonModified.cpp:      //canyon_R_flag = -1;
StreetCanyonModified.cpp:      canyon_width = std::abs(yi[id] - yi[id + 1]);
StreetCanyonModified.cpp:      for (auto y_id = 0; y_id <= 2 * ceil(std::abs(yi[id] - yi[id + 1]) / WGD->dxy); y_id++) {
StreetCanyonModified.cpp:        yc = MIN_S(yi[id], yi[id + 1]) + 0.5 * y_id * WGD->dxy;
StreetCanyonModified.cpp:        /* FM -> needed for general case (TODO)
StreetCanyonModified.cpp:        // reset flag for every y-location along the face (if inside the canyon)
StreetCanyonModified.cpp:          x_wall = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (yc - yi[id]) + xi[id];
StreetCanyonModified.cpp:        for (auto k = k_end - 1; k >= k_start; k--) {
StreetCanyonModified.cpp:          int i1 = ceil(((x_wall - WGD->dxy) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx) - 1;
StreetCanyonModified.cpp:          int j1 = ceil(((x_wall - WGD->dxy) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy) - 1;
StreetCanyonModified.cpp:          icell_cent = i1 + j1 * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyonModified.cpp:          if (WGD->icellflag[icell_cent] != 0)
StreetCanyonModified.cpp:          x_id_min = -1;
StreetCanyonModified.cpp:          for (auto x_id = 1; x_id <= 2 * ceil(Lr / WGD->dxy); x_id++) {
StreetCanyonModified.cpp:            xc = 0.5 * x_id * WGD->dxy;
StreetCanyonModified.cpp:            int i = ceil(((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx) - 1;
StreetCanyonModified.cpp:            int j = ceil(((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy) - 1;
StreetCanyonModified.cpp:            icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyonModified.cpp:            if (i >= WGD->nx - 2 && i <= 0 && j >= WGD->ny - 2 && j <= 0) {
StreetCanyonModified.cpp:            icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyonModified.cpp:            if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2 && x_id_min < 0) {
StreetCanyonModified.cpp:            if ((WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2) && x_id_min >= 0) {
StreetCanyonModified.cpp:              x_id_max = x_id - 1;
StreetCanyonModified.cpp:              s = 0.5 * (x_id_max - x_id_min) * WGD->dxy;
StreetCanyonModified.cpp:                int ic = ceil(((0.5 * x_id_max * WGD->dxy + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x - 0.001) / WGD->dx) - 1;
StreetCanyonModified.cpp:                int jc = ceil(((0.5 * x_id_max * WGD->dxy + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y - 0.001) / WGD->dy) - 1;
StreetCanyonModified.cpp:                icell_cent = ic + jc * (WGD->nx - 1) + k_ref * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyonModified.cpp:                int icell_face = ic + jc * WGD->nx + k_ref * WGD->nx * WGD->ny;
StreetCanyonModified.cpp:                if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
StreetCanyonModified.cpp:                  if (WGD->icellflag[icell_cent - 1] != 0 && WGD->icellflag[icell_cent - 1] != 2) {
StreetCanyonModified.cpp:                    u_component += WGD->u0[icell_face];
StreetCanyonModified.cpp:                  if (WGD->icellflag[icell_cent + 1] != 0 && WGD->icellflag[icell_cent + 1] != 2) {
StreetCanyonModified.cpp:                    u_component += WGD->u0[icell_face + 1];
StreetCanyonModified.cpp:                  if (WGD->icellflag[icell_cent - (WGD->nx - 1)] != 0 && WGD->icellflag[icell_cent - (WGD->nx - 1)] != 2) {
StreetCanyonModified.cpp:                    v_component += WGD->v0[icell_face];
StreetCanyonModified.cpp:                  if (WGD->icellflag[icell_cent + (WGD->nx - 1)] != 0 && WGD->icellflag[icell_cent + (WGD->nx - 1)] != 2) {
StreetCanyonModified.cpp:                    v_component += WGD->v0[icell_face + WGD->nx];
StreetCanyonModified.cpp:                    // mean velocity along +/-x
StreetCanyonModified.cpp:                    // mean velocity along +/- y
StreetCanyonModified.cpp:                      canyon_dir = -0.5 * M_PI;
StreetCanyonModified.cpp:                  // flag=1 -> top of canyon set, velocity and direction set
StreetCanyonModified.cpp:                  // this if-block will not be executed unless flag is reset
StreetCanyonModified.cpp:                  icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyonModified.cpp:                    if ((WGD->ibuilding_flag[icell_cent] >= 0)
StreetCanyonModified.cpp:                        && (WGD->allBuildingsV[WGD->ibuilding_flag[icell_cent]]->height_eff < height_eff)
StreetCanyonModified.cpp:                        && (WGD->z_face[k] / s < 0.65)) {
StreetCanyonModified.cpp:                if (velocity_mag > WGD->max_velmag) {
StreetCanyonModified.cpp:              icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyonModified.cpp:              if (WGD->ibuilding_flag[icell_cent] >= 0) {
StreetCanyonModified.cpp:                d_build = WGD->ibuilding_flag[icell_cent];
StreetCanyonModified.cpp:                int i = ceil(((xc - 0.5 * WGD->dxy + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x - 0.001) / WGD->dx) - 1;
StreetCanyonModified.cpp:                int j = ceil(((xc - 0.5 * WGD->dxy + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y - 0.001) / WGD->dy) - 1;
StreetCanyonModified.cpp:                for (size_t j_id = 0; j_id < WGD->allBuildingsV[d_build]->polygonVertices.size() - 1; j_id++) {
StreetCanyonModified.cpp:                  // normal direction (out-facing normal) of face of downstream building (ref as db-face for that loop)
StreetCanyonModified.cpp:                  facenormal_dir = atan2(WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].y_poly
StreetCanyonModified.cpp:                                           - WGD->allBuildingsV[d_build]->polygonVertices[j_id].y_poly,
StreetCanyonModified.cpp:                                         WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].x_poly
StreetCanyonModified.cpp:                                           - WGD->allBuildingsV[d_build]->polygonVertices[j_id].x_poly)
StreetCanyonModified.cpp:                  // forcing facenormal_dir to be in (-pi,pi]
StreetCanyonModified.cpp:                    facenormal_dir -= 2.0 * M_PI;
StreetCanyonModified.cpp:                  if (facenormal_dir <= -M_PI) {
StreetCanyonModified.cpp:                  // (x,y) mid point of db-face
StreetCanyonModified.cpp:                  x_ave = 0.5 * (WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].x_poly + WGD->allBuildingsV[d_build]->polygonVertices[j_id].x_poly);
StreetCanyonModified.cpp:                  y_ave = 0.5 * (WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].y_poly + WGD->allBuildingsV[d_build]->polygonVertices[j_id].y_poly);
StreetCanyonModified.cpp:                  // x-/y-componants of segment between current location (center of cell) and mid-point of bd-face
StreetCanyonModified.cpp:                  // -> relative to the normal of current face  (facenormal_dir)
StreetCanyonModified.cpp:                  x_down = ((i + 0.5) * WGD->dx - x_ave) * cos(facenormal_dir) + ((j + 0.5) * WGD->dy - y_ave) * sin(facenormal_dir);
StreetCanyonModified.cpp:                  y_down = -((i + 0.5) * WGD->dx - x_ave) * sin(facenormal_dir) + ((j + 0.5) * WGD->dy - y_ave) * cos(facenormal_dir);
StreetCanyonModified.cpp:                     - reverse flow = flow go down along front face - up along back face
StreetCanyonModified.cpp:                     - otherwise    = flow go up along front face - down along back face
StreetCanyonModified.cpp:                     1) check if location of current cell against db-face
StreetCanyonModified.cpp:                     |  x-dir (relative to center of face): location within one cell
StreetCanyonModified.cpp:                     |  y-dir (relative to center of face): less that 1/2 the length of the face
StreetCanyonModified.cpp:                     2) check relative angle between wind and bd-face :
StreetCanyonModified.cpp:                     |  if smaller that +/- 0.5pi -> flow reverse
StreetCanyonModified.cpp:                     |  else -> no flow reverse
StreetCanyonModified.cpp:                     |  cross_dir = angle of the projection of the canyon_dir wind on the perpendicular dir to the db-face (facenormal_dir)
StreetCanyonModified.cpp:		     |  along_dir = angle of the projection of the canyon_dir wind on the parallel dir to the db-face (facenormal_dir)
StreetCanyonModified.cpp:                     -> exit loop on db faces at first valid face (condition 1)
StreetCanyonModified.cpp:                  // checking distance to face of down-wind building
StreetCanyonModified.cpp:                  if (std::abs(x_down) < 1.0 * WGD->dxy) {
StreetCanyonModified.cpp:                    segment_length = sqrt(pow(WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].x_poly
StreetCanyonModified.cpp:                                                - WGD->allBuildingsV[d_build]->polygonVertices[j_id].x_poly,
StreetCanyonModified.cpp:                                          + pow(WGD->allBuildingsV[d_build]->polygonVertices[j_id + 1].y_poly
StreetCanyonModified.cpp:                                                  - WGD->allBuildingsV[d_build]->polygonVertices[j_id].y_poly,
StreetCanyonModified.cpp:                    // checking distance along face of down-wind building
StreetCanyonModified.cpp:                      downwind_rel_dir = canyon_dir - facenormal_dir;
StreetCanyonModified.cpp:                      // forcing downwind_rel_dir to be in [-pi,pi] and check for round-off error
StreetCanyonModified.cpp:                        downwind_rel_dir -= 2.0 * M_PI;
StreetCanyonModified.cpp:                      // forcing downwind_rel_dir to be in [-pi,pi] and check for round-off error
StreetCanyonModified.cpp:                      if (downwind_rel_dir <= -M_PI) {
StreetCanyonModified.cpp:                        // out-facing normal and wind at reference cell 'same' direction
StreetCanyonModified.cpp:                        // out-facing normal and wind at reference cell 'opposite' direction
StreetCanyonModified.cpp:                        along_dir = facenormal_dir - 0.5 * M_PI;
StreetCanyonModified.cpp:                      if (cos(facenormal_dir - perpendicular_dir[id]) > cos(angle_tol)) {
StreetCanyonModified.cpp:                if (cross_dir <= -M_PI) {
StreetCanyonModified.cpp:                // angle need to be (-pi;-0.75*pi) or (0.75*pi;pi)
StreetCanyonModified.cpp:                if (cos(facenormal_dir - perpendicular_dir[id]) > cos(angle_tol)) {
StreetCanyonModified.cpp:          // forcing along_dir to be in [-pi,pi]
StreetCanyonModified.cpp:            cross_dir -= 2.0 * M_PI;
StreetCanyonModified.cpp:          if (cross_dir <= -M_PI) {
StreetCanyonModified.cpp:          // forcing along_dir to be in [-pi,pi]
StreetCanyonModified.cpp:            along_dir -= 2.0 * M_PI;
StreetCanyonModified.cpp:          if (along_dir <= -M_PI) {
StreetCanyonModified.cpp:	   * -> need to reorganize the for loop to be allow aggregation of street canyon zone
StreetCanyonModified.cpp:	     if (canyon_flag == 1 && s > 0.9 * WGD->dxy) {
StreetCanyonModified.cpp:	     int i = ceil(((x_wall)*cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x - 0.001) / WGD->dx) - 1;
StreetCanyonModified.cpp:	     int j = ceil(((x_wall)*sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y - 0.001) / WGD->dy) - 1;
StreetCanyonModified.cpp:	     x_p = (i + 0.5) * WGD->dx - building_cent_x;
StreetCanyonModified.cpp:	     y_p = (j + 0.5) * WGD->dy - building_cent_y;
StreetCanyonModified.cpp:	     y_w = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
StreetCanyonModified.cpp:	     canyon_R = y_w - 0.5 * WGD->dxy;
StreetCanyonModified.cpp:	     if (std::abs(canyon_R - MIN_S(yi[id], yi[id + 1])) < 0.5 * WGD->dxy)
StreetCanyonModified.cpp:	     canyon_L = y_w + 0.5 * WGD->dxy;
StreetCanyonModified.cpp:	     // x-coord inside canyon
StreetCanyonModified.cpp:	     x_pos = x_w - x_wall_w;
StreetCanyonModified.cpp:	     // y-coord inside canyon (need generalization)
StreetCanyonModified.cpp:          if (canyon_flag == 1 && s > 0.9 * WGD->dxy) {
StreetCanyonModified.cpp:            along_vel_mag = std::abs(velocity_mag * cos(canyon_dir - along_dir)) * log(WGD->z[k] / WGD->z0) / log(WGD->z[k_ref] / WGD->z0);
StreetCanyonModified.cpp:            cross_vel_mag = gamma * std::abs(velocity_mag * cos(canyon_dir - cross_dir));
StreetCanyonModified.cpp:            // z-coord inside canyon (from the top)
StreetCanyonModified.cpp:            z_pos = WGD->z_face[k_ref - 1] - WGD->z[k];
StreetCanyonModified.cpp:              xc = 0.5 * x_id * WGD->dxy;
StreetCanyonModified.cpp:              int i = ceil(((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x - 0.001) / WGD->dx) - 1;
StreetCanyonModified.cpp:              int j = ceil(((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y - 0.001) / WGD->dy) - 1;
StreetCanyonModified.cpp:              icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyonModified.cpp:              if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
StreetCanyonModified.cpp:                /* u-velocity parameterization (face)
StreetCanyonModified.cpp:                  i_u x-index of u-face (j does not need correction cell)
StreetCanyonModified.cpp:                  x_p,y_p non-rotated relative to building center (u-face)
StreetCanyonModified.cpp:                  x_u,y_u rotated relative to building center (u-face)
StreetCanyonModified.cpp:                i_u = std::round(((xc + x_wall) * cos(upwind_dir) - yc * sin(upwind_dir) + building_cent_x) / WGD->dx);
StreetCanyonModified.cpp:                x_p = i_u * WGD->dx - building_cent_x;
StreetCanyonModified.cpp:                y_p = (j + 0.5) * WGD->dy - building_cent_y;
StreetCanyonModified.cpp:                y_u = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
StreetCanyonModified.cpp:                  x_wall_u = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (y_u - yi[id]) + xi[id];
StreetCanyonModified.cpp:                // x-coord inside canyon
StreetCanyonModified.cpp:                x_pos = x_u - x_wall_u;
StreetCanyonModified.cpp:                // y-coord inside canyon (need generalization)
StreetCanyonModified.cpp:                if (x_pos <= s + 0.001 && x_pos > -0.5 * WGD->dxy) {
StreetCanyonModified.cpp:                  icell_face = i_u + j * WGD->nx + k * WGD->nx * WGD->ny;
StreetCanyonModified.cpp:                  fSC = pow(1.0 - (std::abs(y_pos) / (0.5 * canyon_width - 0.2 * x_pos)), 0.25);
StreetCanyonModified.cpp:                  WGD->u0[icell_face] = along_vel_mag * cos(along_dir)
StreetCanyonModified.cpp:                                        + cross_vel_mag * fSC * (2 * x_pos / s) * 2 * (1 - x_pos / s) * cos(cross_dir);
StreetCanyonModified.cpp:                  if (0.5 * canyon_width - 0.2 * x_pos <= std::abs(y_pos) + WGD->dxy) {
StreetCanyonModified.cpp:                    WGD->u0[icell_face] = along_vel_mag * cos(along_dir)
StreetCanyonModified.cpp:                                          - cross_vel_mag * cos(cross_dir)
StreetCanyonModified.cpp:                                              * log(WGD->z[k] / WGD->z0) / log(WGD->z[k_ref] / WGD->z0)
StreetCanyonModified.cpp:                                              * tanh((std::abs(y_pos) - 0.5 * canyon_width + 0.2 * x_pos) / (0.2 * x_pos)) / tanh(1.0);
StreetCanyonModified.cpp:                  if (z_pos <= 0.2 * x_pos + WGD->dz) {
StreetCanyonModified.cpp:                    WGD->u0[icell_face] = along_vel_mag * cos(along_dir)
StreetCanyonModified.cpp:                                          - cross_vel_mag * cos(cross_dir) * tanh((0.2 * x_pos - z_pos) / (0.2 * x_pos)) / tanh(1.0);
StreetCanyonModified.cpp:                // end of u-velocity parameterization
StreetCanyonModified.cpp:                /* v-velocity parameterization (face)
StreetCanyonModified.cpp:                  j_v y-index of v-face (i does not need correction cell)
StreetCanyonModified.cpp:                  x_p,y_p non-rotated relative to building center (v-face)
StreetCanyonModified.cpp:                  x_u,y_u rotated relative to building center (u-face)
StreetCanyonModified.cpp:                j_v = std::round(((xc + x_wall) * sin(upwind_dir) + yc * cos(upwind_dir) + building_cent_y) / WGD->dy);
StreetCanyonModified.cpp:                x_p = (i + 0.5) * WGD->dx - building_cent_x;
StreetCanyonModified.cpp:                y_p = j_v * WGD->dy - building_cent_y;
StreetCanyonModified.cpp:                y_v = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
StreetCanyonModified.cpp:                  x_wall_v = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (y_v - yi[id]) + xi[id];
StreetCanyonModified.cpp:                // x-coord inside canyon
StreetCanyonModified.cpp:                x_pos = x_v - x_wall_v;
StreetCanyonModified.cpp:                // y-coord inside canyon (need generalization)
StreetCanyonModified.cpp:                if (x_pos <= s + 0.001 && x_pos > -0.5 * WGD->dxy) {
StreetCanyonModified.cpp:                  icell_face = i + j_v * WGD->nx + k * WGD->nx * WGD->ny;
StreetCanyonModified.cpp:                  fSC = pow(1.0 - (std::abs(y_pos) / (0.5 * canyon_width - 0.2 * x_pos)), 0.25);
StreetCanyonModified.cpp:                  WGD->v0[icell_face] = along_vel_mag * sin(along_dir)
StreetCanyonModified.cpp:                                        + cross_vel_mag * fSC * (2 * x_pos / s) * 2 * (1 - x_pos / s) * sin(cross_dir);
StreetCanyonModified.cpp:                  if (0.5 * canyon_width - 0.2 * x_pos <= std::abs(y_pos) + WGD->dxy) {
StreetCanyonModified.cpp:                    WGD->v0[icell_face] = along_vel_mag * sin(along_dir)
StreetCanyonModified.cpp:                                          - cross_vel_mag * sin(cross_dir) * log(WGD->z[k] / WGD->z0) / log(WGD->z[k_ref] / WGD->z0)
StreetCanyonModified.cpp:                                              * tanh((std::abs(y_pos) - 0.5 * canyon_width + 0.2 * x_pos) / (0.2 * x_pos)) / tanh(1.0);
StreetCanyonModified.cpp:                  if (z_pos <= 0.2 * x_pos + WGD->dz) {
StreetCanyonModified.cpp:                    WGD->v0[icell_face] = along_vel_mag * sin(along_dir)
StreetCanyonModified.cpp:                                          - cross_vel_mag * sin(cross_dir) * tanh((0.2 * x_pos - z_pos) / (0.2 * x_pos)) / tanh(1.0);
StreetCanyonModified.cpp:                // end of v-velocity parameterization
StreetCanyonModified.cpp:                /* w-velocity parameterization (face) and cellflag (cell)
StreetCanyonModified.cpp:                  x_p,y_p non-rotated relative to building center (w-face/cell)
StreetCanyonModified.cpp:                  x_w,y_w rotated relative to building center (w-face/cell)
StreetCanyonModified.cpp:                x_p = (i + 0.5) * WGD->dx - building_cent_x;
StreetCanyonModified.cpp:                y_p = (j + 0.5) * WGD->dy - building_cent_y;
StreetCanyonModified.cpp:                y_w = -x_p * sin(upwind_dir) + y_p * cos(upwind_dir);
StreetCanyonModified.cpp:                  x_wall_w = ((xi[id + 1] - xi[id]) / (yi[id + 1] - yi[id])) * (y_w - yi[id]) + xi[id];
StreetCanyonModified.cpp:                // x-coord inside canyon
StreetCanyonModified.cpp:                x_pos = x_w - x_wall_w;
StreetCanyonModified.cpp:                // y-coord inside canyon (need generalization)
StreetCanyonModified.cpp:                if (x_pos <= s + 0.001 && x_pos > -0.5 * WGD->dxy) {
StreetCanyonModified.cpp:                  icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
StreetCanyonModified.cpp:                  if (WGD->icellflag[icell_cent - (WGD->nx - 1) * (WGD->ny - 1)] != 0
StreetCanyonModified.cpp:                      && WGD->icellflag[icell_cent - (WGD->nx - 1) * (WGD->ny - 1)] != 2) {
StreetCanyonModified.cpp:                    icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
StreetCanyonModified.cpp:                      // flow go up along front face - down along back face
StreetCanyonModified.cpp:                      WGD->w0[icell_face] = -std::abs(0.5 * cross_vel_mag * (1 - 2 * x_pos / s)) * (1 - 2 * (s - x_pos) / s);
StreetCanyonModified.cpp:                      // flow go down along front face - up along back face
StreetCanyonModified.cpp:                      WGD->w0[icell_face] = std::abs(0.5 * cross_vel_mag * (1 - 2 * x_pos / s)) * (1 - 2 * (s - x_pos) / s);
StreetCanyonModified.cpp:                    WGD->icellflag[icell_cent] = 6;
StreetCanyonModified.cpp:                    /* FM - need to add cell_flag for lateral and top mixing layer ??
StreetCanyonModified.cpp:                    if (0.5 * canyon_width - 0.2 * x_pos <= std::abs(y_pos) + WGD->dxy) {
StreetCanyonModified.cpp:                      WGD->w0[icell_face] = 0.0;
StreetCanyonModified.cpp:                      WGD->icellflag[icell_cent] = 12;
StreetCanyonModified.cpp:                    if (z_pos <= 0.2 * x_pos + WGD->dz) {
StreetCanyonModified.cpp:                      WGD->w0[icell_face] = 0.0;
StreetCanyonModified.cpp:                      WGD->icellflag[icell_cent] = 13;
StreetCanyonModified.cpp:		    if ((WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
StreetCanyonModified.cpp:                    WGD->icellflag[icell_cent] = 6;
StreetCanyonModified.cpp:                // end of w-velocity parameterization
StreetCanyonModified.cpp:        /* FM -> needed for general case
StreetCanyonModified.cpp:	if (canyon_flag == 1 && s > 0.9 * WGD->dxy) {
StreetCanyonModified.cpp:      //canyon_width = std::abs(canyon_L - canyon_R);
StreetIntersection.cpp: * This file is part of QES-Winds
StreetIntersection.cpp: * GPL-3.0 License
StreetIntersection.cpp: * QES-Winds is free software: you can redistribute it and/or modify
StreetIntersection.cpp: * QES-Winds is distributed in the hope that it will be useful,
StreetIntersection.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
StreetIntersection.cpp:  intersect.resize (WGD->numcell_cent, 0);
StreetIntersection.cpp:  intersect_1.resize (WGD->numcell_cent, 0);
StreetIntersection.cpp:  intersect_2.resize (WGD->numcell_cent, 0);
StreetIntersection.cpp:  intersect_1opp.resize (WGD->numcell_cent, 0);
StreetIntersection.cpp:  intersect_2opp.resize (WGD->numcell_cent, 0);
StreetIntersection.cpp:  E_W_flag.resize (WGD->numcell_cent, 0);
StreetIntersection.cpp:  W_E_flag.resize (WGD->numcell_cent, 0);
StreetIntersection.cpp:  N_S_flag.resize (WGD->numcell_cent, 0);
StreetIntersection.cpp:  S_N_flag.resize (WGD->numcell_cent, 0);
StreetIntersection.cpp:  WGD->wall->setVelocityZero (WGD);
StreetIntersection.cpp:  for (auto k = 0; k < WGD->nz-1; k++)
StreetIntersection.cpp:    for (auto j = 0; j < WGD->ny-1; j++)
StreetIntersection.cpp:      for (auto i = 1; i < WGD->nx-1; i++)
StreetIntersection.cpp:        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:        if (WGD->icellflag[icell_cent-1] == 6 && WGD->icellflag[icell_cent] != 6 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2)
StreetIntersection.cpp:        if ((change_flag == 1 && WGD->icellflag[icell_cent] == 6) || (change_flag == 1 && (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2))
StreetIntersection.cpp:            || (change_flag == 1 && WGD->icellflag[icell_cent] == 1))
StreetIntersection.cpp:        for (auto i = i_start_flag; i < WGD->nx-1; i++)
StreetIntersection.cpp:          icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:      for (auto i = WGD->nx-3; i >= 0; i--)
StreetIntersection.cpp:        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:        if (WGD->icellflag[icell_cent+1] == 6 && WGD->icellflag[icell_cent] != 6 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2)
StreetIntersection.cpp:        if ((change_flag == 1 && WGD->icellflag[icell_cent] == 6) || (change_flag == 1 && (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2))
StreetIntersection.cpp:            || (change_flag == 1 && WGD->icellflag[icell_cent] == 1))
StreetIntersection.cpp:        for (auto i = WGD->nx-2; i >= i_start_flag; i--)
StreetIntersection.cpp:          icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:  //std::cout << "WGD->icellflag:  " << WGD->icellflag[90+75*(WGD->nx-1)+1*(WGD->nx-1)*(WGD->ny-1)] << std::endl;
StreetIntersection.cpp:  //std::cout << "WGD->icellflag-1:  " << WGD->icellflag[90+74*(WGD->nx-1)+1*(WGD->nx-1)*(WGD->ny-1)] << std::endl;
StreetIntersection.cpp:  for (auto k = 0; k < WGD->nz-1; k++)
StreetIntersection.cpp:    for (auto i = 0; i < WGD->nx-1; i++)
StreetIntersection.cpp:      for (auto j = 1; j < WGD->ny-1; j++)
StreetIntersection.cpp:        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:        if (WGD->icellflag[icell_cent-(WGD->nx-1)] == 6 && WGD->icellflag[icell_cent] != 6 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2)
StreetIntersection.cpp:        if ((change_flag == 1 && WGD->icellflag[icell_cent] == 6) || (change_flag == 1 && (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2))
StreetIntersection.cpp:            || (change_flag == 1 && WGD->icellflag[icell_cent] == 1))
StreetIntersection.cpp:        for (auto j = j_start_flag; j < WGD->ny-1; j++)
StreetIntersection.cpp:          icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:      for (auto j = WGD->ny-3; j >= 0; j--)
StreetIntersection.cpp:        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:        if (WGD->icellflag[icell_cent+(WGD->nx-1)] == 6 && WGD->icellflag[icell_cent] != 6 && WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2)
StreetIntersection.cpp:        if ((change_flag == 1 && WGD->icellflag[icell_cent] == 6) || (change_flag == 1 && (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2))
StreetIntersection.cpp:            || (change_flag == 1 && WGD->icellflag[icell_cent] == 1))
StreetIntersection.cpp:        for (auto j = WGD->ny-2; j >= j_start_flag; j--)
StreetIntersection.cpp:          icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:  //std::cout << "intersect_2:  " << intersect_2[90+75*(WGD->nx-1)+1*(WGD->nx-1)*(WGD->ny-1)] << std::endl;
StreetIntersection.cpp:  for (auto k = 0; k < WGD->nz-1; k++)
StreetIntersection.cpp:    for (auto j = 0; j < WGD->ny-1; j++)
StreetIntersection.cpp:      for (auto i = 0; i < WGD->nx-1; i++)
StreetIntersection.cpp:        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:  for (auto k = 0; k < WGD->nz-1; k++)
StreetIntersection.cpp:    for (auto j = 1; j < WGD->ny-1; j++)
StreetIntersection.cpp:      for (auto i = 1; i < WGD->nx-1; i++)
StreetIntersection.cpp:        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:        if (intersect[icell_cent] == 1 && WGD->icellflag[icell_cent-1] == 6)
StreetIntersection.cpp:      for (auto i = WGD->nx-3; i >= 0; i--)
StreetIntersection.cpp:        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:        if (intersect[icell_cent] == 1 && WGD->icellflag[icell_cent+1] == 6)
StreetIntersection.cpp:  for (auto k = 0; k < WGD->nz-1; k++)
StreetIntersection.cpp:    for (auto i = 1; i < WGD->nx-1; i++)
StreetIntersection.cpp:      for (auto j = 1; j < WGD->ny-1; j++)
StreetIntersection.cpp:        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:        if (intersect[icell_cent] == 1 && WGD->icellflag[icell_cent-(WGD->nx-1)] == 6)
StreetIntersection.cpp:      for (auto j = WGD->ny-3; j >= 0; j--)
StreetIntersection.cpp:        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:        if (intersect[icell_cent] == 1 && WGD->icellflag[icell_cent+(WGD->nx-1)] == 6)
StreetIntersection.cpp:  for (auto k = 0; k < WGD->nz-1; k++)
StreetIntersection.cpp:    for (auto j = 0; j < WGD->ny-1; j++)
StreetIntersection.cpp:      for (auto i = 0; i < WGD->nx-1; i++)
StreetIntersection.cpp:        icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:          WGD->icellflag[icell_cent] = 12;
StreetIntersection.cpp:    for (auto k = 1; k < WGD->nz-1; k++)
StreetIntersection.cpp:      for (auto j = 1; j < WGD->ny-1; j++)
StreetIntersection.cpp:        for (auto i = 1; i < WGD->nx-1; i++)
StreetIntersection.cpp:          icell_cent = i + j*(WGD->nx-1) + k*(WGD->nx-1)*(WGD->ny-1);
StreetIntersection.cpp:          icell_face = i + j*WGD->nx + k*WGD->nx*WGD->ny;
StreetIntersection.cpp:          if (WGD->icellflag[icell_cent] == 12 && WGD->icellflag[icell_cent-1] == 12)
StreetIntersection.cpp:            WGD->u0[icell_face] = (1 / ( WGD->e[icell_cent] + WGD->f[icell_cent] + WGD->g[icell_cent] +
StreetIntersection.cpp:                                            WGD->h[icell_cent] + WGD->m[icell_cent] + WGD->n[icell_cent])) *
StreetIntersection.cpp:                ( WGD->e[icell_cent] * WGD->u0[icell_face+1]        + WGD->f[icell_cent] * WGD->u0[icell_face-1] +
StreetIntersection.cpp:                  WGD->g[icell_cent] * WGD->u0[icell_face + WGD->nx] + WGD->h[icell_cent] * WGD->u0[icell_face-WGD->nx] +
StreetIntersection.cpp:                  WGD->m[icell_cent] * WGD->u0[icell_face + WGD->nx*WGD->ny] +
StreetIntersection.cpp:                  WGD->n[icell_cent] * WGD->u0[icell_face - WGD->nx*WGD->ny] );
StreetIntersection.cpp:                  //std::cout << "u0:  " << WGD->u0[icell_face] << std::endl;
StreetIntersection.cpp:          if (WGD->icellflag[icell_cent] == 12 && WGD->icellflag[icell_cent-(WGD->nx-1)] == 12)
StreetIntersection.cpp:            WGD->v0[icell_face] = (1 / ( WGD->e[icell_cent] + WGD->f[icell_cent] + WGD->g[icell_cent] +
StreetIntersection.cpp:                                            WGD->h[icell_cent] + WGD->m[icell_cent] + WGD->n[icell_cent])) *
StreetIntersection.cpp:                ( WGD->e[icell_cent] * WGD->v0[icell_face+1]        + WGD->f[icell_cent] * WGD->v0[icell_face-1] +
StreetIntersection.cpp:                  WGD->g[icell_cent] * WGD->v0[icell_face + WGD->nx] + WGD->h[icell_cent] * WGD->v0[icell_face-WGD->nx] +
StreetIntersection.cpp:                  WGD->m[icell_cent] * WGD->v0[icell_face + WGD->nx*WGD->ny] +
StreetIntersection.cpp:                  WGD->n[icell_cent] * WGD->v0[icell_face - WGD->nx*WGD->ny] );
StreetIntersection.cpp:                  //std::cout << "v0:  " << WGD->v0[icell_face] << std::endl;
StreetIntersection.cpp:          if (WGD->icellflag[icell_cent] == 12 && WGD->icellflag[icell_cent-(WGD->nx-1)*(WGD->ny-1)] == 12)
StreetIntersection.cpp:            WGD->w0[icell_face] = (1 / ( WGD->e[icell_cent] + WGD->f[icell_cent] + WGD->g[icell_cent] +
StreetIntersection.cpp:                                            WGD->h[icell_cent] + WGD->m[icell_cent] + WGD->n[icell_cent])) *
StreetIntersection.cpp:                ( WGD->e[icell_cent] * WGD->w0[icell_face+1]        + WGD->f[icell_cent] * WGD->w0[icell_face-1] +
StreetIntersection.cpp:                  WGD->g[icell_cent] * WGD->w0[icell_face + WGD->nx] + WGD->h[icell_cent] * WGD->w0[icell_face-WGD->nx] +
StreetIntersection.cpp:                  WGD->m[icell_cent] * WGD->w0[icell_face + WGD->nx*WGD->ny] +
StreetIntersection.cpp:                  WGD->n[icell_cent] * WGD->w0[icell_face - WGD->nx*WGD->ny] );
TextTable.h:  TextTable() : _horizontal('-'),
TextTable.h:    return static_cast<int>(string_to_correct.size()) - static_cast<int>(glyphLength(string_to_correct));
TextTable.h:    for (; times > 0; --times)
TextTable.h:      u += std::mblen(&c_str[u], _byteLength - u);
TextTable.h:      // For a utf8 encoded string the glyph length g might be smaller than l. We need n spaces so that g+n=width which is equivalent to g+n+l-l=width ==> l+n = width+l-g
TextTable.h:      // l-g (that means glyph length minus byte length) has to be added to the width argument.
TextTable.h:      // l-g is computed by correctDistance.
TimeSeries.h: * This file is part of QES-Winds
TimeSeries.h: * GPL-3.0 License
TimeSeries.h: * QES-Winds is free software: you can redistribute it and/or modify
TimeSeries.h: * QES-Winds is distributed in the hope that it will be useful,
TimeSeries.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
TimeSeries.h:  time_t timeEpoch = -1; /**< :document this: */
TimeSeries.h:    if (timeStamp == "" && timeEpoch == -1) {
TimeSeries.h:      timeStamp = "2020-01-01T00:00";
TimeSeries.h:    } else if (timeStamp != "" && timeEpoch == -1) {
TimeSeries.h:    } else if (timeEpoch != -1 && timeStamp == "") {
Triangle.cpp: * This file is part of QES-Winds
Triangle.cpp: * GPL-3.0 License
Triangle.cpp: * QES-Winds is free software: you can redistribute it and/or modify
Triangle.cpp: * QES-Winds is distributed in the hope that it will be useful,
Triangle.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Triangle.cpp:  A = (*a)[0] - (*b)[0];
Triangle.cpp:  D = (*a)[0] - (*c)[0];
Triangle.cpp:  J = (*a)[0] - x;
Triangle.cpp:  B = (*a)[1] - (*b)[1];
Triangle.cpp:  E = (*a)[1] - (*c)[1];
Triangle.cpp:  K = (*a)[1] - y;
Triangle.cpp:  C = (*a)[2] - (*b)[2];
Triangle.cpp:  F = (*a)[2] - (*c)[2];
Triangle.cpp:  float EIHF = (E * I - H * F);
Triangle.cpp:  float GFDI = (G * F - D * I);
Triangle.cpp:  float DHEG = (D * H - E * G);
Triangle.cpp:  float AKJB = (A * K - J * B);
Triangle.cpp:  float JCAL = (J * C - A * L);
Triangle.cpp:  float BLKC = (B * L - K * C);
Triangle.cpp:  t = -1 * (F * AKJB + E * JCAL + D * BLKC) / M;
Triangle.cpp:    return -1.0f;
Triangle.cpp:    return -1.0f;
Triangle.cpp:  if (beta < 0 || beta > 1 - gamma)
Triangle.cpp:    return -1.0;
Triangle.cpp:  A = (*a)[0] - (*b)[0];
Triangle.cpp:  D = (*a)[0] - (*c)[0];
Triangle.cpp:  B = (*a)[1] - (*b)[1];
Triangle.cpp:  E = (*a)[1] - (*c)[1];
Triangle.cpp:  C = (*a)[2] - (*b)[2];
Triangle.cpp:  F = (*a)[2] - (*c)[2];
Triangle.cpp:  J = (*a)[0] - ray.getOriginX();
Triangle.cpp:  K = (*a)[1] - ray.getOriginY();
Triangle.cpp:  L = (*a)[2] - ray.getOriginZ();
Triangle.cpp:  float EIHF = (E * I2) - (H2 * F);
Triangle.cpp:  float GFDI = (G2 * F) - (D * I2);
Triangle.cpp:  float DHEG = (D * H2) - (E * G2);
Triangle.cpp:  float AKJB = (A * K) - (J * B);
Triangle.cpp:  float JCAL = (J * C) - (A * L);
Triangle.cpp:  float BLKC = (B * L) - (K * C);
Triangle.cpp:  t = -(((F * AKJB) + (E * JCAL) + (D * BLKC)) / M);
Triangle.cpp:  if (gamma < 0 || gamma > 1 || beta < 0 || beta > (1 - gamma) || t < 0.0) {
Triangle.cpp:    rec.hitDist = std::sqrt(std::pow(rec.endpt[0] - ray.getOriginX(), 2)
Triangle.cpp:                            + std::pow(rec.endpt[1] - ray.getOriginY(), 2)
Triangle.cpp:                            + std::pow(rec.endpt[2] - ray.getOriginZ(), 2));
Triangle.h: * This file is part of QES-Winds
Triangle.h: * GPL-3.0 License
Triangle.h: * QES-Winds is free software: you can redistribute it and/or modify
Triangle.h: * QES-Winds is distributed in the hope that it will be useful,
Triangle.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Triangle.h:   * @param x x-location
Triangle.h:   * @param y y-location
Triangle.h:   * @return the length of the ray before intersection, if no intersection, -1 is returned
TURBGeneralData.cpp: * This file is part of QES-Winds
TURBGeneralData.cpp: * GPL-3.0 License
TURBGeneralData.cpp: * QES-Winds is free software: you can redistribute it and/or modify
TURBGeneralData.cpp: * QES-Winds is distributed in the hope that it will be useful,
TURBGeneralData.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
TURBGeneralData.cpp:  std::cout << "[QES-TURB]\t Initialization of turbulence model...\n";
TURBGeneralData.cpp:  turbUpperBound = WID->turbParams->turbUpperBound;
TURBGeneralData.cpp:  if (WID->turbParams->sigConst) {
TURBGeneralData.cpp:    sigConst = *(WID->turbParams->sigConst);
TURBGeneralData.cpp:  flagNonLocalMixing = WID->turbParams->flagNonLocalMixing;
TURBGeneralData.cpp:    std::cout << "\t\t Non-Local mixing for buidlings: ON \n";
TURBGeneralData.cpp:  if (WID->simParams->verticalStretching > 0) {
TURBGeneralData.cpp:  backgroundMixing = WID->turbParams->backgroundMixing;
TURBGeneralData.cpp:  // nx,ny,nz consitant with WINDS (face-center)
TURBGeneralData.cpp:  // WINDS->grid correspond to face-center grid
TURBGeneralData.cpp:  nz = m_WGD->nz;
TURBGeneralData.cpp:  ny = m_WGD->ny;
TURBGeneralData.cpp:  nx = m_WGD->nx;
TURBGeneralData.cpp:  dz = m_WGD->dz;
TURBGeneralData.cpp:  dy = m_WGD->dy;
TURBGeneralData.cpp:  dx = m_WGD->dx;
TURBGeneralData.cpp:  // x-grid (face-center & cell-center)
TURBGeneralData.cpp:  x_cc.resize(nx - 1, 0);
TURBGeneralData.cpp:  // y-grid (face-center & cell-center)
TURBGeneralData.cpp:  y_cc.resize(ny - 1, 0);
TURBGeneralData.cpp:  // z-grid (face-center & cell-center)
TURBGeneralData.cpp:  z_cc.resize(nz - 1, 0);
TURBGeneralData.cpp:  // x cell-center
TURBGeneralData.cpp:  x_cc = m_WGD->x;
TURBGeneralData.cpp:  // x face-center (this assume constant dx for the moment, same as QES-winds)
TURBGeneralData.cpp:  for (int i = 1; i < nx - 1; i++) {
TURBGeneralData.cpp:    x_fc[i] = 0.5 * (m_WGD->x[i - 1] + m_WGD->x[i]);
TURBGeneralData.cpp:  x_fc[0] = x_fc[1] - dx;
TURBGeneralData.cpp:  x_fc[nx - 1] = x_fc[nx - 2] + dx;
TURBGeneralData.cpp:  // y cell-center
TURBGeneralData.cpp:  y_cc = m_WGD->y;
TURBGeneralData.cpp:  // y face-center (this assume constant dy for the moment, same as QES-winds)
TURBGeneralData.cpp:  for (int i = 1; i < ny - 1; i++) {
TURBGeneralData.cpp:    y_fc[i] = 0.5 * (m_WGD->y[i - 1] + m_WGD->y[i]);
TURBGeneralData.cpp:  y_fc[0] = y_fc[1] - dy;
TURBGeneralData.cpp:  y_fc[ny - 1] = y_fc[ny - 2] + dy;
TURBGeneralData.cpp:  // z cell-center
TURBGeneralData.cpp:  z_cc = m_WGD->z;
TURBGeneralData.cpp:  // z face-center (with ghost cell under the ground)
TURBGeneralData.cpp:    z_fc[i] = m_WGD->z_face[i - 1];
TURBGeneralData.cpp:  z_fc[0] = z_fc[1] - dz;
TURBGeneralData.cpp:  int np_cc = (nz - 1) * (ny - 1) * (nx - 1);
TURBGeneralData.cpp:     => i=1...nx-2 j=1...ny-2
TURBGeneralData.cpp:     => k=0...nz-2
TURBGeneralData.cpp:  for (int k = 0; k < nz - 2; k++) {
TURBGeneralData.cpp:    for (int j = 1; j < ny - 2; j++) {
TURBGeneralData.cpp:      for (int i = 1; i < nx - 2; i++) {
TURBGeneralData.cpp:        int id = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
TURBGeneralData.cpp:        if (m_WGD->icellflag[id] != 0 && m_WGD->icellflag[id] != 2) {
TURBGeneralData.cpp:  if (WID->turbParams->methodLocalMixing == 0) {
TURBGeneralData.cpp:  } else if (WID->turbParams->methodLocalMixing == 1) {
TURBGeneralData.cpp:  } else if (WID->turbParams->methodLocalMixing == 2) {
TURBGeneralData.cpp:    // WID->simParams->DTE_mesh->calculateMixingLength(nx, ny, nz, dx, dy, dz, WGD->icellflag, WGD->mixingLengths);
TURBGeneralData.cpp:  } else if (WID->turbParams->methodLocalMixing == 3) {
TURBGeneralData.cpp:  } else if (WID->turbParams->methodLocalMixing == 4) {
TURBGeneralData.cpp:  localMixing->defineMixingLength(WID, m_WGD);
TURBGeneralData.cpp:    Lm[idcc] = vonKar * m_WGD->mixingLengths[idcc];
TURBGeneralData.cpp:  std::chrono::duration<double> mlElapsed = mlEndTime - mlStartTime;
TURBGeneralData.cpp:  if (WID->simParams->DTE_heightField) {
TURBGeneralData.cpp:    terrainH_max = *max_element(m_WGD->terrain.begin(), m_WGD->terrain.end());
TURBGeneralData.cpp:  if (m_WGD->allBuildingsV.size() > 0) {
TURBGeneralData.cpp:    for (size_t i = 0; i < m_WGD->allBuildingsV.size(); i++) {
TURBGeneralData.cpp:      bldgH_mean += m_WGD->allBuildingsV[m_WGD->building_id[i]]->H;
TURBGeneralData.cpp:      heffmax = m_WGD->allBuildingsV[m_WGD->building_id[i]]->H;// height_eff;
TURBGeneralData.cpp:    bldgH_mean = bldgH_mean / float(m_WGD->allBuildingsV.size());
TURBGeneralData.cpp:    // Morphometric parametrization based on Grimmond and Oke (1999) and Kaster-Klein and Rotach (2003)
TURBGeneralData.cpp:    z0d = WID->metParams->sensors[0]->TS[0]->site_z0;
TURBGeneralData.cpp:  std::chrono::duration<double> Elapsed = EndTime - StartTime;
TURBGeneralData.cpp:  std::cout << "[QES-TURB]\t Initialization of turbulence model completed.\n";
TURBGeneralData.cpp:  std::cout << "[TURB Data] \t Loading QES-turb fields " << std::endl;
TURBGeneralData.cpp:  // nx,ny - face centered value (consistant with QES-Winds)
TURBGeneralData.cpp:  input->getDimensionSize("x", nx);
TURBGeneralData.cpp:  input->getDimensionSize("y", ny);
TURBGeneralData.cpp:  // nz - face centered value + bottom ghost (consistant with QES-Winds)
TURBGeneralData.cpp:  input->getDimensionSize("z", nz);
TURBGeneralData.cpp:  // nt - number of time instance in data
TURBGeneralData.cpp:  input->getDimensionSize("t", nt);
TURBGeneralData.cpp:  input->getVariableData("t", t);
TURBGeneralData.cpp:  // nx,ny,nz consitant with QES-Winds (face-center)
TURBGeneralData.cpp:  nx = m_WGD->nx;
TURBGeneralData.cpp:  ny = m_WGD->ny;
TURBGeneralData.cpp:  nz = m_WGD->nz;
TURBGeneralData.cpp:  float dx = m_WGD->dx;
TURBGeneralData.cpp:  float dy = m_WGD->dy;
TURBGeneralData.cpp:  float dz = m_WGD->dz;
TURBGeneralData.cpp:  // x-grid (face-center & cell-center)
TURBGeneralData.cpp:  x_cc.resize(nx - 1, 0);
TURBGeneralData.cpp:  // y-grid (face-center & cell-center)
TURBGeneralData.cpp:  y_cc.resize(ny - 1, 0);
TURBGeneralData.cpp:  // z-grid (face-center & cell-center)
TURBGeneralData.cpp:  z_cc.resize(nz - 1, 0);
TURBGeneralData.cpp:  // x cell-center
TURBGeneralData.cpp:  x_cc = m_WGD->x;
TURBGeneralData.cpp:  // x face-center (this assume constant dx for the moment, same as QES-Winds)
TURBGeneralData.cpp:  for (int i = 1; i < nx - 1; i++) {
TURBGeneralData.cpp:    x_fc[i] = 0.5 * (m_WGD->x[i - 1] + m_WGD->x[i]);
TURBGeneralData.cpp:  x_fc[0] = x_fc[1] - dx;
TURBGeneralData.cpp:  x_fc[nx - 1] = x_fc[nx - 2] + dx;
TURBGeneralData.cpp:  // y cell-center
TURBGeneralData.cpp:  y_cc = m_WGD->y;
TURBGeneralData.cpp:  // y face-center (this assume constant dy for the moment, same as QES-winds)
TURBGeneralData.cpp:  for (int i = 1; i < ny - 1; i++) {
TURBGeneralData.cpp:    y_fc[i] = 0.5 * (m_WGD->y[i - 1] + m_WGD->y[i]);
TURBGeneralData.cpp:  y_fc[0] = y_fc[1] - dy;
TURBGeneralData.cpp:  y_fc[ny - 1] = y_fc[ny - 2] + dy;
TURBGeneralData.cpp:  // z cell-center
TURBGeneralData.cpp:  z_cc = m_WGD->z;
TURBGeneralData.cpp:  // z face-center (with ghost cell under the ground)
TURBGeneralData.cpp:    z_fc[i] = m_WGD->z_face[i - 1];
TURBGeneralData.cpp:  z_fc[0] = z_fc[1] - dz;
TURBGeneralData.cpp:  int np_cc = (nz - 1) * (ny - 1) * (nx - 1);
TURBGeneralData.cpp:               static_cast<unsigned long>(nz - 1),
TURBGeneralData.cpp:               static_cast<unsigned long>(ny - 1),
TURBGeneralData.cpp:               static_cast<unsigned long>(nx - 1) };
TURBGeneralData.cpp:  input->getVariableData("txx", start, count_cc, txx);
TURBGeneralData.cpp:  input->getVariableData("txy", start, count_cc, txy);
TURBGeneralData.cpp:  input->getVariableData("txz", start, count_cc, txz);
TURBGeneralData.cpp:  input->getVariableData("tyy", start, count_cc, tyy);
TURBGeneralData.cpp:  input->getVariableData("tyz", start, count_cc, tyz);
TURBGeneralData.cpp:  input->getVariableData("tzz", start, count_cc, tzz);
TURBGeneralData.cpp:  // face-center variables
TURBGeneralData.cpp:  input->getVariableData("tke", start, count_cc, tke);
TURBGeneralData.cpp:  input->getVariableData("CoEps", start, count_cc, CoEps);
TURBGeneralData.cpp:  std::cout << "[QES-TURB] \t Running turbulence model..." << std::endl;
TURBGeneralData.cpp:    std::cout << "\t\t Applying non-local mixing..." << std::endl;
TURBGeneralData.cpp:    for (size_t i = 0; i < m_WGD->allBuildingsV.size(); i++) {
TURBGeneralData.cpp:      m_WGD->allBuildingsV[m_WGD->building_id[i]]->NonLocalMixing(m_WGD, this, m_WGD->building_id[i]);
TURBGeneralData.cpp:    // std::cout<<"\t\t Non-local mixing completed."<<std::endl;
TURBGeneralData.cpp:  std::chrono::duration<double> Elapsed = EndTime - StartTime;
TURBGeneralData.cpp:  std::cout << "[QES-TURB] \t Turbulence model completed.\n";
TURBGeneralData.cpp:  for (int j = 0; j < ny - 1; j++) {
TURBGeneralData.cpp:    for (int i = 0; i < nx - 1; i++) {
TURBGeneralData.cpp:        k = itr - z_fc.begin();
TURBGeneralData.cpp:      int cellID = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
TURBGeneralData.cpp:      if (m_WGD->icellflag[cellID] != 0 && m_WGD->icellflag[cellID] != 2) {
TURBGeneralData.cpp:        uSum += sqrt(pow(0.5 * (m_WGD->u[faceID] + m_WGD->u[faceID + 1]), 2)
TURBGeneralData.cpp:                     + pow(0.5 * (m_WGD->v[faceID] + m_WGD->v[faceID + nx]), 2)
TURBGeneralData.cpp:                     + pow(0.5 * (m_WGD->w[faceID] + m_WGD->w[faceID + nx * ny]), 2));
TURBGeneralData.cpp:  uStar = 0.4 * uRef / log((zRef - d0d) / z0d);
TURBGeneralData.cpp:    // linearized index: cellID = i + j*(nx-1) + k*(nx-1)*(ny-1);
TURBGeneralData.cpp:    //  i,j,k -> inverted linearized index
TURBGeneralData.cpp:    int k = (int)(cellID / ((nx - 1) * (ny - 1)));
TURBGeneralData.cpp:    int j = (int)((cellID - k * (nx - 1) * (ny - 1)) / (nx - 1));
TURBGeneralData.cpp:    int i = cellID - j * (nx - 1) - k * (nx - 1) * (ny - 1);
TURBGeneralData.cpp:      Diagonal componants of the strain-rate tensor naturally fall at
TURBGeneralData.cpp:      the cell-center
TURBGeneralData.cpp:    Sxx[cellID] = (m_WGD->u[idxp] - m_WGD->u[faceID]) / (x_fc[i + 1] - x_fc[i]);
TURBGeneralData.cpp:    Syy[cellID] = (m_WGD->v[idyp] - m_WGD->v[faceID]) / (y_fc[j + 1] - y_fc[j]);
TURBGeneralData.cpp:    Szz[cellID] = (m_WGD->w[idzp] - m_WGD->w[faceID]) / (z_fc[k + 1] - z_fc[k]);
TURBGeneralData.cpp:      Off-diagonal componants of the strain-rate tensor require extra interpolation
TURBGeneralData.cpp:      of the velocity field to get the derivative at the cell-center
TURBGeneralData.cpp:    //--------------------------------------
TURBGeneralData.cpp:    up = ((x_cc[i] - x_fc[i]) * m_WGD->u[idp] + (x_fc[i + 1] - x_cc[i]) * m_WGD->u[idm]) / (x_fc[i + 1] - x_fc[i]);
TURBGeneralData.cpp:    // u_hat-
TURBGeneralData.cpp:    idp = faceID + 1 - nx;// i+1,j-1
TURBGeneralData.cpp:    idm = faceID - nx;// i,j-1
TURBGeneralData.cpp:    um = ((x_cc[i] - x_fc[i]) * m_WGD->u[idp] + (x_fc[i + 1] - x_cc[i]) * m_WGD->u[idm]) / (x_fc[i + 1] - x_fc[i]);
TURBGeneralData.cpp:    vp = ((y_cc[j] - y_fc[j]) * m_WGD->v[idp] + (y_fc[j + 1] - y_cc[j]) * m_WGD->v[idm]) / (y_fc[j + 1] - y_fc[j]);
TURBGeneralData.cpp:    // v_hat-
TURBGeneralData.cpp:    idp = faceID - 1 + nx;// i-1,j+1
TURBGeneralData.cpp:    idm = faceID - 1;// i-1,j
TURBGeneralData.cpp:    vm = ((y_cc[j] - y_fc[j]) * m_WGD->v[idp] + (y_fc[j + 1] - y_cc[j]) * m_WGD->v[idm]) / (y_fc[j + 1] - y_fc[j]);
TURBGeneralData.cpp:    Sxy[cellID] = 0.5 * ((up - um) / (y_cc[j + 1] - y_cc[j - 1]) + (vp - vm) / (x_cc[i + 1] - x_cc[i - 1]));
TURBGeneralData.cpp:    //--------------------------------------
TURBGeneralData.cpp:    up = ((x_cc[i] - x_fc[i]) * m_WGD->u[idp] + (x_fc[i + 1] - x_cc[i]) * m_WGD->u[idm]) / (x_fc[i + 1] - x_fc[i]);
TURBGeneralData.cpp:    // u_hat-
TURBGeneralData.cpp:    idp = faceID + 1 - nx * ny;// i+1,k-1
TURBGeneralData.cpp:    idm = faceID - nx * ny;// i,k-1
TURBGeneralData.cpp:    um = ((x_cc[i] - x_fc[i]) * m_WGD->u[idp] + (x_fc[i + 1] - x_cc[i]) * m_WGD->u[idm]) / (x_fc[i + 1] - x_fc[i]);
TURBGeneralData.cpp:    wp = ((z_cc[k] - z_fc[k]) * m_WGD->w[idp] + (z_fc[k + 1] - z_cc[k]) * m_WGD->w[idm]) / (z_fc[k + 1] - z_fc[k]);
TURBGeneralData.cpp:    // w_hat-
TURBGeneralData.cpp:    idp = faceID - 1 + nx * ny;// i-1,k+1
TURBGeneralData.cpp:    idm = faceID - 1;// i-1,k
TURBGeneralData.cpp:    wm = ((z_cc[k] - z_fc[k]) * m_WGD->w[idp] + (z_fc[k + 1] - z_cc[k]) * m_WGD->w[idm]) / (z_fc[k + 1] - z_fc[k]);
TURBGeneralData.cpp:    Sxz[cellID] = 0.5 * ((up - um) / (z_cc[k + 1] - z_cc[k - 1]) + (wp - wm) / (x_cc[i + 1] - x_cc[i - 1]));
TURBGeneralData.cpp:    //--------------------------------------
TURBGeneralData.cpp:    vp = ((y_cc[j] - y_fc[j]) * m_WGD->v[idp] + (y_fc[j + 1] - y_cc[j]) * m_WGD->v[idm]) / (y_fc[j + 1] - y_fc[j]);
TURBGeneralData.cpp:    // v_hat-
TURBGeneralData.cpp:    idp = faceID + nx - nx * ny;// j+1,k-1
TURBGeneralData.cpp:    idm = faceID - nx * ny;// j,k-1
TURBGeneralData.cpp:    vm = ((y_cc[j] - y_fc[j]) * m_WGD->v[idp] + (y_fc[j + 1] - y_cc[j]) * m_WGD->v[idm]) / (y_fc[j + 1] - y_fc[j]);
TURBGeneralData.cpp:    wp = ((z_cc[k - 1] - z_fc[k]) * m_WGD->w[idp] + (z_fc[k + 1] - z_cc[k]) * m_WGD->w[idm]) / (z_fc[k + 1] - z_fc[k]);
TURBGeneralData.cpp:    // w_hat-
TURBGeneralData.cpp:    idp = faceID - nx + nx * ny;// j-1,k+1
TURBGeneralData.cpp:    idm = faceID - nx;// j-1,k
TURBGeneralData.cpp:    wp = ((z_cc[k] - z_fc[k]) * m_WGD->w[idp] + (z_fc[k + 1] - z_cc[k]) * m_WGD->w[idm]) / (z_fc[k + 1] - z_fc[k]);
TURBGeneralData.cpp:    Syz[cellID] = 0.5 * ((vp - vm) / (z_cc[k + 1] - z_cc[k - 1]) + (wp - wm) / (y_cc[j + 1] - y_cc[j - 1]));
TURBGeneralData.cpp:    txx[cellID] = (2.0 / 3.0) * TKE - 2.0 * (NU_T * Sxx[cellID]);
TURBGeneralData.cpp:    tyy[cellID] = (2.0 / 3.0) * TKE - 2.0 * (NU_T * Syy[cellID]);
TURBGeneralData.cpp:    tzz[cellID] = (2.0 / 3.0) * TKE - 2.0 * (NU_T * Szz[cellID]);
TURBGeneralData.cpp:    txy[cellID] = -2.0 * (NU_T * Sxy[cellID]);
TURBGeneralData.cpp:    txz[cellID] = -2.0 * (NU_T * Sxz[cellID]);
TURBGeneralData.cpp:    tyz[cellID] = -2.0 * (NU_T * Syz[cellID]);
TURBGeneralData.cpp:    // linearized index: cellID = i + j*(nx-1) + k*(nx-1)*(ny-1);
TURBGeneralData.cpp:    //  i,j,k -> inverted linearized index
TURBGeneralData.cpp:    int k = (int)(cellID / ((nx - 1) * (ny - 1)));
TURBGeneralData.cpp:    int j = (int)((cellID - k * (nx - 1) * (ny - 1)) / (nx - 1));
TURBGeneralData.cpp:    int i = cellID - j * (nx - 1) - k * (nx - 1) * (ny - 1);
TURBGeneralData.cpp:     - Diagonal componants of the velocity gradient tensor naturally fall at the cell-center
TURBGeneralData.cpp:     - Off-diagonal componants of the  velocity gradient tensor require extra interpolation
TURBGeneralData.cpp:       of the velocity field to get the derivative at the cell-center  
TURBGeneralData.cpp:     - Derivative with respect to z need to be adjusted for non-uniform z-grid
TURBGeneralData.cpp:    Gxx[cellID] = (m_WGD->u[faceID + 1] - m_WGD->u[faceID]) / (m_WGD->dx);
TURBGeneralData.cpp:    Gyx[cellID] = ((m_WGD->v[faceID + 1] + m_WGD->v[faceID + 1 + nx])
TURBGeneralData.cpp:                   - (m_WGD->v[faceID - 1] - m_WGD->v[faceID - 1 + nx]))
TURBGeneralData.cpp:                  / (4.0 * m_WGD->dx);
TURBGeneralData.cpp:    Gzx[cellID] = ((m_WGD->w[faceID + 1] + m_WGD->w[faceID + 1 + nx * ny])
TURBGeneralData.cpp:                   - (m_WGD->w[faceID - 1] + m_WGD->w[faceID - 1 + nx * ny]))
TURBGeneralData.cpp:                  / (4.0 * m_WGD->dx);
TURBGeneralData.cpp:    Gxy[cellID] = ((m_WGD->u[faceID + nx] + m_WGD->u[faceID + 1 + nx])
TURBGeneralData.cpp:                   - (m_WGD->u[faceID - nx] + m_WGD->u[faceID + 1 - nx]))
TURBGeneralData.cpp:                  / (4.0 * m_WGD->dy);
TURBGeneralData.cpp:    Gyy[cellID] = (m_WGD->v[faceID + nx] - m_WGD->v[faceID]) / (m_WGD->dy);
TURBGeneralData.cpp:    Gzy[cellID] = ((m_WGD->w[faceID + nx] + m_WGD->w[faceID + nx + nx * ny])
TURBGeneralData.cpp:                   - (m_WGD->w[faceID - nx] + m_WGD->w[faceID - nx + nx * ny]))
TURBGeneralData.cpp:                  / (4.0 * m_WGD->dy);
TURBGeneralData.cpp:      Gxz[cellID] = ((m_WGD->u[faceID + nx * ny] + m_WGD->u[faceID + 1 + nx * ny])
TURBGeneralData.cpp:                     - (m_WGD->u[faceID - nx * ny] + m_WGD->u[faceID + 1 - nx * ny]))
TURBGeneralData.cpp:                    / (4.0 * m_WGD->dz);
TURBGeneralData.cpp:      Gyz[cellID] = ((m_WGD->v[faceID + nx * ny] + m_WGD->v[faceID + nx + nx * ny])
TURBGeneralData.cpp:                     - (m_WGD->v[faceID - nx * ny] + m_WGD->v[faceID + nx - nx * ny]))
TURBGeneralData.cpp:                    / (4.0 * m_WGD->dz);
TURBGeneralData.cpp:      Gzz[cellID] = (m_WGD->w[faceID + nx * ny] - m_WGD->w[faceID]) / (m_WGD->dz);
TURBGeneralData.cpp:      Gxz[cellID] = (0.5 * (m_WGD->z[k] - m_WGD->z[k - 1]) / (m_WGD->z[k + 1] - m_WGD->z[k])
TURBGeneralData.cpp:                       * ((m_WGD->u[faceID + nx * ny] + m_WGD->u[faceID + 1 + nx * ny])
TURBGeneralData.cpp:                          - (m_WGD->u[faceID] + m_WGD->u[faceID + 1]))
TURBGeneralData.cpp:                     + 0.5 * (m_WGD->z[k + 1] - m_WGD->z[k]) / (m_WGD->z[k] - m_WGD->z[k - 1])
TURBGeneralData.cpp:                         * ((m_WGD->u[faceID] + m_WGD->u[faceID + 1])
TURBGeneralData.cpp:                            - (m_WGD->u[faceID - nx * ny] + m_WGD->u[faceID + 1 - nx * ny])))
TURBGeneralData.cpp:                    / (m_WGD->z[k + 1] - m_WGD->z[k - 1]);
TURBGeneralData.cpp:      Gyz[cellID] = (0.5 * (m_WGD->z[k] - m_WGD->z[k - 1]) / (m_WGD->z[k + 1] - m_WGD->z[k])
TURBGeneralData.cpp:                       * ((m_WGD->v[faceID + nx * ny] + m_WGD->v[faceID + nx + nx * ny])
TURBGeneralData.cpp:                          - (m_WGD->v[faceID] + m_WGD->v[faceID + nx]))
TURBGeneralData.cpp:                     + 0.5 * (m_WGD->z[k + 1] - m_WGD->z[k]) / (m_WGD->z[k] - m_WGD->z[k - 1])
TURBGeneralData.cpp:                         * ((m_WGD->v[faceID] + m_WGD->v[faceID + nx])
TURBGeneralData.cpp:                            - (m_WGD->v[faceID - nx * ny] + m_WGD->v[faceID + nx - nx * ny])))
TURBGeneralData.cpp:                    / (m_WGD->z[k + 1] - m_WGD->z[k - 1]);
TURBGeneralData.cpp:      Gzz[cellID] = (m_WGD->w[faceID + nx * ny] - m_WGD->w[faceID]) / (m_WGD->dz_array[k]);
TURBGeneralData.cpp:    wallVec.at(i)->setWallsVelocityDeriv(m_WGD, this);
TURBGeneralData.cpp:    txx[cellID] = (2.0 / 3.0) * TKE - 2.0 * (NU_T * Sxx);
TURBGeneralData.cpp:    tyy[cellID] = (2.0 / 3.0) * TKE - 2.0 * (NU_T * Syy);
TURBGeneralData.cpp:    tzz[cellID] = (2.0 / 3.0) * TKE - 2.0 * (NU_T * Szz);
TURBGeneralData.cpp:    txy[cellID] = -2.0 * (NU_T * Sxy);
TURBGeneralData.cpp:    txz[cellID] = -2.0 * (NU_T * Sxz);
TURBGeneralData.cpp:    tyz[cellID] = -2.0 * (NU_T * Syz);
TURBGeneralData.cpp:  // x-comp of the divergence of the stress tensor
TURBGeneralData.cpp:  // y-comp of the divergence of the stress tensor
TURBGeneralData.cpp:  // z-comp of the divergence of the stress tensor
TURBGeneralData.cpp:  // o-comp of the divergence of the stress tensor
TURBGeneralData.cpp:    // linearized index: cellID = i + j*(nx-1) + k*(nx-1)*(ny-1);
TURBGeneralData.cpp:    //  i,j,k -> inverted linearized index
TURBGeneralData.cpp:    int k = (int)(cellID / ((nx - 1) * (ny - 1)));
TURBGeneralData.cpp:    tmp_dtoxdx[cellID] = (tox[cellID + 1] - tox[cellID - 1]) / (2.0 * m_WGD->dx);
TURBGeneralData.cpp:    tmp_dtoydy[cellID] = (toy[cellID + (nx - 1)] - toy[cellID - (nx - 1)]) / (2.0 * m_WGD->dy);
TURBGeneralData.cpp:      tmp_dtozdz[cellID] = (toz[cellID + (nx - 1) * (ny - 1)] - toz[cellID - (nx - 1) * (ny - 1)])
TURBGeneralData.cpp:                           / (2.0 * m_WGD->dz);
TURBGeneralData.cpp:      tmp_dtozdz[cellID] = ((m_WGD->z[k] - m_WGD->z[k - 1]) / (m_WGD->z[k + 1] - m_WGD->z[k])
TURBGeneralData.cpp:                              * (toz[cellID + (nx - 1) * (ny - 1)] - toz[cellID])
TURBGeneralData.cpp:                            + (m_WGD->z[k + 1] - m_WGD->z[k]) / (m_WGD->z[k] - m_WGD->z[k - 1])
TURBGeneralData.cpp:                                * (toz[cellID] - toz[cellID - (nx - 1) * (ny - 1)]))
TURBGeneralData.cpp:                           / (m_WGD->z[k + 1] - m_WGD->z[k - 1]);
TURBGeneralData.cpp:    wallVec.at(i)->setWallsStressDeriv(m_WGD, this, tox, toy, toz);
TURBGeneralData.cpp:    if (txx[cellID] < -stressBound)
TURBGeneralData.cpp:      txx[cellID] = -stressBound;
TURBGeneralData.cpp:    if (txy[cellID] < -stressBound)
TURBGeneralData.cpp:      txy[cellID] = -stressBound;
TURBGeneralData.cpp:    if (txz[cellID] < -stressBound)
TURBGeneralData.cpp:      txz[cellID] = -stressBound;
TURBGeneralData.cpp:    if (tyy[cellID] < -stressBound)
TURBGeneralData.cpp:      tyy[cellID] = -stressBound;
TURBGeneralData.cpp:    if (tyz[cellID] < -stressBound)
TURBGeneralData.cpp:      tyz[cellID] = -stressBound;
TURBGeneralData.cpp:    if (tzz[cellID] < -stressBound)
TURBGeneralData.cpp:      tzz[cellID] = -stressBound;
TURBGeneralData.h: * This file is part of QES-Winds
TURBGeneralData.h: * GPL-3.0 License
TURBGeneralData.h: * QES-Winds is free software: you can redistribute it and/or modify
TURBGeneralData.h: * QES-Winds is distributed in the hope that it will be useful,
TURBGeneralData.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
TURBGeneralData.h:  //nt - number of time instance in data
TURBGeneralData.h:    0 - solid object, 1 - fluid
TURBGeneralData.h:    2 - stairstep terrain-wall, 3 - cut-cell terrain
TURBGeneralData.h:    4 - stairstep building-wall, 5 - cut-cell building
TURBOutput.cpp: * This file is part of QES-Winds
TURBOutput.cpp: * GPL-3.0 License
TURBOutput.cpp: * QES-Winds is free software: you can redistribute it and/or modify
TURBOutput.cpp: * QES-Winds is distributed in the hope that it will be useful,
TURBOutput.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
TURBOutput.cpp:  int nx = tgd_->nx;
TURBOutput.cpp:  int ny = tgd_->ny;
TURBOutput.cpp:  int nz = tgd_->nz;
TURBOutput.cpp:  // unused: long numcell_cout = (nx-1)*(ny-1)*(nz-1);
TURBOutput.cpp:  createAttVector("times", "date time", "-", dim_vect_tstr, &timestamp);
TURBOutput.cpp:  // set cell-centered data dimensions
TURBOutput.cpp:  NcDim NcDim_x_cc = addDimension("x_cc", nx - 1);
TURBOutput.cpp:  NcDim NcDim_y_cc = addDimension("y_cc", ny - 1);
TURBOutput.cpp:  NcDim NcDim_z_cc = addDimension("z_cc", nz - 1);
TURBOutput.cpp:  createAttVector("x_cc", "x-distance", "m", dim_vect_x, &(tgd_->x_cc));
TURBOutput.cpp:  createAttVector("y_cc", "y-distance", "m", dim_vect_y, &(tgd_->y_cc));
TURBOutput.cpp:  createAttVector("z_cc", "z-distance", "m", dim_vect_z, &(tgd_->z_cc));
TURBOutput.cpp:  createAttVector("iturbflag", "icell turb flag", "--", dim_vect_cc, &(tgd_->iturbflag));
TURBOutput.cpp:  // create attributes for strain-rate stress tensor
TURBOutput.cpp:    createAttVector("Sxx", "uu-component of strain-rate tensor", "s-1", dim_vect_cc, &(tgd_->Sxx));
TURBOutput.cpp:    createAttVector("Syy", "vv-component of strain-rate tensor", "s-1", dim_vect_cc, &(tgd_->Syy));
TURBOutput.cpp:    createAttVector("Szz", "ww-component of strain-rate tensor", "s-1", dim_vect_cc, &(tgd_->Szz));
TURBOutput.cpp:    createAttVector("Sxy", "uv-component of strain-rate tensor", "s-1", dim_vect_cc, &(tgd_->Sxy));
TURBOutput.cpp:    createAttVector("Sxz", "uw-component of strain-rate tensor", "s-1", dim_vect_cc, &(tgd_->Sxz));
TURBOutput.cpp:    createAttVector("Syz", "vw-component of strain-rate tensor", "s-1", dim_vect_cc, &(tgd_->Syz));
TURBOutput.cpp:  createAttVector("Gxx", "velocity gradient tensor: Gxx = dudx", "s-1", dim_vect_cc, &(tgd_->Gxx));
TURBOutput.cpp:  createAttVector("Gyx", "velocity gradient tensor: Gyx = dvdx", "s-1", dim_vect_cc, &(tgd_->Gyx));
TURBOutput.cpp:  createAttVector("Gzx", "velocity gradient tensor: Gzx = dwdx", "s-1", dim_vect_cc, &(tgd_->Gzx));
TURBOutput.cpp:  createAttVector("Gxy", "velocity gradient tensor: Gxy = dudy", "s-1", dim_vect_cc, &(tgd_->Gxy));
TURBOutput.cpp:  createAttVector("Gyy", "velocity gradient tensor: Gyy = dvdy", "s-1", dim_vect_cc, &(tgd_->Gyy));
TURBOutput.cpp:  createAttVector("Gzy", "velocity gradient tensor: Gzy = dwdy", "s-1", dim_vect_cc, &(tgd_->Gzy));
TURBOutput.cpp:  createAttVector("Gxz", "velocity gradient tensor: Gxz = dudz", "s-1", dim_vect_cc, &(tgd_->Gxz));
TURBOutput.cpp:  createAttVector("Gyz", "velocity gradient tensor: Gyz = dvdz", "s-1", dim_vect_cc, &(tgd_->Gyz));
TURBOutput.cpp:  createAttVector("Gzz", "velocity gradient tensor: Gzz = dwdz", "s-1", dim_vect_cc, &(tgd_->Gzz));
TURBOutput.cpp:  createAttVector("L", "mixing length", "m", dim_vect_cc, &(tgd_->Lm));
TURBOutput.cpp:  createAttVector("txx", "uu-component of stress tensor", "m2s-2", dim_vect_cc, &(tgd_->txx));
TURBOutput.cpp:  createAttVector("tyy", "vv-component of stress tensor", "m2s-2", dim_vect_cc, &(tgd_->tyy));
TURBOutput.cpp:  createAttVector("tzz", "ww-component of stress tensor", "m2s-2", dim_vect_cc, &(tgd_->tzz));
TURBOutput.cpp:  createAttVector("txy", "uv-component of stress tensor", "m2s-2", dim_vect_cc, &(tgd_->txy));
TURBOutput.cpp:  createAttVector("txz", "uw-component of stress tensor", "m2s-2", dim_vect_cc, &(tgd_->txz));
TURBOutput.cpp:  createAttVector("tyz", "vw-component of stress tensor", "m2s-2", dim_vect_cc, &(tgd_->tyz));
TURBOutput.cpp:  createAttVector("tke", "turbulent kinetic energy", "m2s-2", dim_vect_cc, &(tgd_->tke));
TURBOutput.cpp:  createAttVector("CoEps", "dissipation rate", "m2s-3", dim_vect_cc, &(tgd_->CoEps));
TURBOutput.cpp:  createAttVector("div_tau_x", "x-component of stress-tensor divergence", "ms-2", dim_vect_cc, &(tgd_->div_tau_x));
TURBOutput.cpp:  createAttVector("div_tau_y", "y-component of stress-tensor divergence", "ms-2", dim_vect_cc, &(tgd_->div_tau_y));
TURBOutput.cpp:  createAttVector("div_tau_z", "z-component of stress-tensor divergence", "ms-2", dim_vect_cc, &(tgd_->div_tau_z));
TURBOutput.cpp:// Save output at cell-centered values
TURBOutput.h: * This file is part of QES-Winds
TURBOutput.h: * GPL-3.0 License
TURBOutput.h: * QES-Winds is free software: you can redistribute it and/or modify
TURBOutput.h: * QES-Winds is distributed in the hope that it will be useful,
TURBOutput.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
TURBParams.h: * This file is part of QES-Winds
TURBParams.h: * GPL-3.0 License
TURBParams.h: * QES-Winds is free software: you can redistribute it and/or modify
TURBParams.h: * QES-Winds is distributed in the hope that it will be useful,
TURBParams.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
TURBParams.h:    // defaults for local mixing sample rates -- used with ray
TURBParams.h:      mlSamplesPerAirCell = 500;// other ray-traced methods
TURBParams.h:      std::cout << "Setting samples per air cell for ray-traced mixing length to "
TURBParams.h:      std::cout << "[WARNING] unknown local mixing method -> "
TURBParams.h:      std::cout << "[WARNING] no local mixing file provided -> "
TURBWallBuilding.cpp: * This file is part of QES-Winds
TURBWallBuilding.cpp: * GPL-3.0 License
TURBWallBuilding.cpp: * QES-Winds is free software: you can redistribute it and/or modify
TURBWallBuilding.cpp: * QES-Winds is distributed in the hope that it will be useful,
TURBWallBuilding.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
TURBWallBuilding.cpp:  if (WID->simParams->meshTypeFlag == 1) {
TURBWallBuilding.cpp:    // [FM] temporary fix -> use stairstep within the cut-cell
TURBWallBuilding.cpp:    if (WID->turbParams->buildingWallFlag == 1) {
TURBWallBuilding.cpp:    } else if (WID->turbParams->buildingWallFlag == 2) {
TURBWallBuilding.cpp:  if (comp_wall_velocity_deriv) (this->*comp_wall_velocity_deriv)(WGD, TGD);
TURBWallBuilding.cpp:  if (comp_wall_stress_deriv) (this->*comp_wall_stress_deriv)(WGD, TGD, tox, toy, toz);
TURBWallBuilding.cpp:  int nx = WGD->nx;
TURBWallBuilding.cpp:  int ny = WGD->ny;
TURBWallBuilding.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWallBuilding.cpp:    TGD->Gxz[it->cellID] = 0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dz_array[k] * log(0.5 * WGD->dz_array[k] / WGD->z0));
TURBWallBuilding.cpp:    TGD->Gyz[it->cellID] = 0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + nx])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dz_array[k] * log(0.5 * WGD->dz_array[k] / WGD->z0));
TURBWallBuilding.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWallBuilding.cpp:    TGD->Gxz[it->cellID] = 0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dz_array[k] * log(0.5 * WGD->dz_array[k] / WGD->z0));
TURBWallBuilding.cpp:    TGD->Gyz[it->cellID] = 0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + WGD->nx])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dz_array[k] * log(0.5 * WGD->dz_array[k] / WGD->z0));
TURBWallBuilding.cpp:    TGD->Gyx[it->cellID] = 0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + nx])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dx * log(0.5 * WGD->dx / WGD->z0));
TURBWallBuilding.cpp:    TGD->Gzx[it->cellID] = 0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dx * log(0.5 * WGD->dx / WGD->z0));
TURBWallBuilding.cpp:    TGD->Gyx[it->cellID] = 0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + nx])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dx * log(0.5 * WGD->dx / WGD->z0));
TURBWallBuilding.cpp:    TGD->Gzx[it->cellID] = 0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dx * log(0.5 * WGD->dx / WGD->z0));
TURBWallBuilding.cpp:    TGD->Gxy[it->cellID] = 0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dy * log(0.5 * WGD->dy / WGD->z0));
TURBWallBuilding.cpp:    TGD->Gzy[it->cellID] = 0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dy * log(0.5 * WGD->dy / WGD->z0));
TURBWallBuilding.cpp:    TGD->Gxy[it->cellID] = 0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dy * log(0.5 * WGD->dy / WGD->z0));
TURBWallBuilding.cpp:    TGD->Gzy[it->cellID] = 0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny])
TURBWallBuilding.cpp:                           / (0.5 * WGD->dy * log(0.5 * WGD->dy / WGD->z0));
TURBWallBuilding.h: * This file is part of QES-Winds
TURBWallBuilding.h: * GPL-3.0 License
TURBWallBuilding.h: * QES-Winds is free software: you can redistribute it and/or modify
TURBWallBuilding.h: * QES-Winds is distributed in the hope that it will be useful,
TURBWallBuilding.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
TURBWall.cpp: * This file is part of QES-Winds
TURBWall.cpp: * GPL-3.0 License
TURBWall.cpp: * QES-Winds is free software: you can redistribute it and/or modify
TURBWall.cpp: * QES-Winds is distributed in the hope that it will be useful,
TURBWall.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
TURBWall.cpp:  int nx = WGD->nx;
TURBWall.cpp:  int ny = WGD->ny;
TURBWall.cpp:  int nz = WGD->nz;
TURBWall.cpp:  // -> need to treat the wall all at once because of strain-rate tensor
TURBWall.cpp:  for (int i = 1; i < nx - 2; i++) {
TURBWall.cpp:    for (int j = 1; j < ny - 2; j++) {
TURBWall.cpp:      for (int k = 1; k < nz - 2; k++) {
TURBWall.cpp:        int cellID = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
TURBWall.cpp:        if (WGD->icellflag[cellID] != 0 && WGD->icellflag[cellID] != 2) {
TURBWall.cpp:          if (WGD->icellflag[cellID - (nx - 1) * (ny - 1)] == cellflag) {
TURBWall.cpp:          if (WGD->icellflag[cellID - 1] == cellflag) {
TURBWall.cpp:          if (WGD->icellflag[cellID + 1] == cellflag) {
TURBWall.cpp:          if (WGD->icellflag[cellID - (nx - 1)] == cellflag) {
TURBWall.cpp:          if (WGD->icellflag[cellID + (nx - 1)] == cellflag) {
TURBWall.cpp:  for (auto i = 1; i < nx - 1; i++) {
TURBWall.cpp:    for (auto j = 1; j < ny - 1; j++) {
TURBWall.cpp:      for (auto k = 1; k < nz - 2; k++) {
TURBWall.cpp:        int cellID = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
TURBWall.cpp:        if (WGD->icellflag[cellID] != 0 && WGD->icellflag[cellID] != 2) {
TURBWall.cpp:          if (WGD->icellflag[cellID - (nx - 1) * (ny - 1)] == cellflag) {
TURBWall.cpp:          if (WGD->icellflag[cellID + (nx - 1) * (ny - 1)] == cellflag) {
TURBWall.cpp:          if (WGD->icellflag[cellID - 1] == cellflag) {
TURBWall.cpp:          if (WGD->icellflag[cellID + 1] == cellflag) {
TURBWall.cpp:          if (WGD->icellflag[cellID - (nx - 1)] == cellflag) {
TURBWall.cpp:          if (WGD->icellflag[cellID + (nx - 1)] == cellflag) {
TURBWall.cpp:    TGD->iturbflag.at(it->cellID) = cellflag;
TURBWall.cpp:    TGD->iturbflag.at(it->cellID) = cellflag;
TURBWall.cpp:    TGD->iturbflag.at(it->cellID) = cellflag;
TURBWall.cpp:    TGD->iturbflag.at(it->cellID) = cellflag;
TURBWall.cpp:    TGD->iturbflag.at(it->cellID) = cellflag;
TURBWall.cpp:    TGD->iturbflag.at(it->cellID) = cellflag;
TURBWall.cpp:    TGD->iturbflag.at(idcell) = cellflag;
TURBWall.cpp:  int nx = WGD->nx;
TURBWall.cpp:  int ny = WGD->ny;
TURBWall.cpp:  int nz = WGD->nz;
TURBWall.cpp:  for (int k = 0; k < nz - 2; k++) {
TURBWall.cpp:    for (int j = 1; j < ny - 2; j++) {
TURBWall.cpp:      for (int i = 1; i < nx - 2; i++) {
TURBWall.cpp:        int id = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
TURBWall.cpp:        if (WGD->icellflag[id] == cellflag) {
TURBWall.cpp:    TGD->iturbflag.at(idcell) = cellflag;
TURBWall.cpp:  int nx = TGD->nx;
TURBWall.cpp:  int ny = TGD->ny;
TURBWall.cpp:  int k = (int)(id_cc / ((nx - 1) * (ny - 1)));
TURBWall.cpp:  int j = (int)((id_cc - k * (nx - 1) * (ny - 1)) / (nx - 1));
TURBWall.cpp:  int i = id_cc - j * (nx - 1) - k * (nx - 1) * (ny - 1);
TURBWall.cpp:  // wind gradients in x-direction
TURBWall.cpp:  // dudx =[u(i+1,j,k)-u(i,j,k)]/(Delta x)
TURBWall.cpp:  dudx = (WGD->u[id_fc + 1] - WGD->u[id_fc]) / (TGD->x_fc[i + 1] - TGD->x_fc[i]);
TURBWall.cpp:  // Three cases: 1) wall behind (i-1), 2) wall in front (i+1) 3) no wall in x-direction
TURBWall.cpp:  if (WGD->icellflag[id_cc - 1] == flag2check) {
TURBWall.cpp:    vp = ((TGD->y_cc[j] - TGD->y_fc[j]) * WGD->v[idp]
TURBWall.cpp:          + (TGD->y_fc[j + 1] - TGD->y_cc[j]) * WGD->v[idm])
TURBWall.cpp:         / (TGD->y_fc[j + 1] - TGD->y_fc[j]);
TURBWall.cpp:    dvdx = vp / ((TGD->x_cc[i] - TGD->x_fc[i]) * log((TGD->x_cc[i] - TGD->x_fc[i]) / z0));
TURBWall.cpp:    wp = ((TGD->z_cc[k] - TGD->z_fc[k]) * WGD->w[idp]
TURBWall.cpp:          + (TGD->z_fc[k + 1] - TGD->z_cc[k]) * WGD->w[idm])
TURBWall.cpp:         / (TGD->z_fc[k + 1] - TGD->z_fc[k]);
TURBWall.cpp:    dwdx = wp / ((TGD->x_cc[i] - TGD->x_fc[i]) * log((TGD->x_cc[i] - TGD->x_fc[i]) / z0));
TURBWall.cpp:  } else if (WGD->icellflag[id_cc + 1] == flag2check) {
TURBWall.cpp:    // dvdx=-v_hat/(0.5dx*log(0.5dx/z0))
TURBWall.cpp:    vp = ((TGD->y_cc[j] - TGD->y_fc[j]) * WGD->v[idp]
TURBWall.cpp:          + (TGD->y_fc[j + 1] - TGD->y_cc[j]) * WGD->v[idm])
TURBWall.cpp:         / (TGD->y_fc[j + 1] - TGD->y_fc[j]);
TURBWall.cpp:    dvdx = -vp / ((TGD->x_fc[i + 1] - TGD->x_cc[i]) * log((TGD->x_fc[i + 1] - TGD->x_cc[i]) / z0));
TURBWall.cpp:    // dwdx=-w_hat/(0.5dx*log(0.5dx/z0))
TURBWall.cpp:    wp = ((TGD->z_cc[k] - TGD->z_fc[k]) * WGD->w[idp]
TURBWall.cpp:          + (TGD->z_fc[k + 1] - TGD->z_cc[k]) * WGD->w[idm])
TURBWall.cpp:         / (TGD->z_fc[k + 1] - TGD->z_fc[k]);
TURBWall.cpp:    dwdx = -wp / ((TGD->x_fc[i + 1] - TGD->x_cc[i]) * log((TGD->x_fc[i + 1] - TGD->x_cc[i]) / z0));
TURBWall.cpp:    vp = ((TGD->y_cc[j] - TGD->y_fc[j]) * WGD->v[idp]
TURBWall.cpp:          + (TGD->y_fc[j + 1] - TGD->y_cc[j]) * WGD->v[idm])
TURBWall.cpp:         / (TGD->y_fc[j + 1] - TGD->y_fc[j]);
TURBWall.cpp:    // v_hat-
TURBWall.cpp:    idp = id_fc - 1 + nx;// i-1,j+1,k
TURBWall.cpp:    idm = id_fc - 1;// i-1,j,k
TURBWall.cpp:    vm = ((TGD->y_cc[j] - TGD->y_fc[j]) * WGD->v[idp]
TURBWall.cpp:          + (TGD->y_fc[j + 1] - TGD->y_cc[j]) * WGD->v[idm])
TURBWall.cpp:         / (TGD->y_fc[j + 1] - TGD->y_fc[j]);
TURBWall.cpp:    dvdx = (vp - vm) / (TGD->x_cc[i + 1] - TGD->x_cc[i - 1]);
TURBWall.cpp:    wp = ((TGD->z_cc[k] - TGD->z_fc[k]) * WGD->w[idp]
TURBWall.cpp:          + (TGD->z_fc[k + 1] - TGD->z_cc[k]) * WGD->w[idm])
TURBWall.cpp:         / (TGD->z_fc[k + 1] - TGD->z_fc[k]);
TURBWall.cpp:    // w_hat-
TURBWall.cpp:    idp = id_fc - 1 + nx * ny;// i-1,j,k+1
TURBWall.cpp:    idm = id_fc - 1;// i-1,j,k
TURBWall.cpp:    wm = ((TGD->z_cc[k] - TGD->z_fc[k]) * WGD->w[idp]
TURBWall.cpp:          + (TGD->z_fc[k + 1] - TGD->z_cc[k]) * WGD->w[idm])
TURBWall.cpp:         / (TGD->z_fc[k + 1] - TGD->z_fc[k]);
TURBWall.cpp:    dwdx = (wp - wm) / (TGD->x_cc[i + 1] - TGD->x_cc[i - 1]);
TURBWall.cpp:  // wind gradients in Y-direction
TURBWall.cpp:  // dvdy = [v(i,j+1,k)-v(i,j,k)]/(Delta y)
TURBWall.cpp:  dvdy = (WGD->v[id_fc + nx] - WGD->v[id_fc]) / (TGD->y_fc[j + 1] - TGD->y_fc[j]);
TURBWall.cpp:  // Three cases: 1) wall right (j-1), 2) wall left (j+1) 3) no wall in y-direction
TURBWall.cpp:  if (WGD->icellflag[id_cc - (nx - 1)] == flag2check) {
TURBWall.cpp:    up = ((TGD->x_cc[i] - TGD->x_fc[i]) * WGD->u[idp]
TURBWall.cpp:          + (TGD->x_fc[i + 1] - TGD->x_cc[i]) * WGD->u[idm])
TURBWall.cpp:         / (TGD->x_fc[i + 1] - TGD->x_fc[i]);
TURBWall.cpp:    dudy = up / ((TGD->y_cc[j] - TGD->y_fc[j]) * log((TGD->y_cc[j] - TGD->y_fc[j]) / z0));
TURBWall.cpp:    wp = ((TGD->z_cc[k] - TGD->z_fc[k]) * WGD->w[idp]
TURBWall.cpp:          + (TGD->z_fc[k + 1] - TGD->z_cc[k]) * WGD->w[idm])
TURBWall.cpp:         / (TGD->z_fc[k + 1] - TGD->z_fc[k]);
TURBWall.cpp:    dwdy = wp / ((TGD->y_cc[j] - TGD->y_fc[j]) * log((TGD->y_cc[j] - TGD->y_fc[j]) / z0));
TURBWall.cpp:  } else if (WGD->icellflag[id_cc + (nx - 1)] == flag2check) {
TURBWall.cpp:    // dudy=-u_hat/(0.5dy*log(0.5dy/z0))
TURBWall.cpp:    up = ((TGD->x_cc[i] - TGD->x_fc[i]) * WGD->u[idp]
TURBWall.cpp:          + (TGD->x_fc[i + 1] - TGD->x_cc[i]) * WGD->u[idm])
TURBWall.cpp:         / (TGD->x_fc[i + 1] - TGD->x_fc[i]);
TURBWall.cpp:    dudy = -up / ((TGD->y_fc[j + 1] - TGD->y_cc[j]) * log((TGD->y_fc[j + 1] - TGD->y_cc[j]) / z0));
TURBWall.cpp:    // dwdy=-w_hat/(0.5dy*log(0.5dy/z0))
TURBWall.cpp:    wp = ((TGD->z_cc[k] - TGD->z_fc[k]) * WGD->w[idp]
TURBWall.cpp:          + (TGD->z_fc[k + 1] - TGD->z_cc[k]) * WGD->w[idm])
TURBWall.cpp:         / (TGD->z_fc[k + 1] - TGD->z_fc[k]);
TURBWall.cpp:    dwdy = -wp / ((TGD->y_fc[i + 1] - TGD->y_cc[i]) * log((TGD->y_fc[i + 1] - TGD->y_cc[i]) / z0));
TURBWall.cpp:    up = ((TGD->x_cc[i] - TGD->x_fc[i]) * WGD->u[idp]
TURBWall.cpp:          + (TGD->x_fc[i + 1] - TGD->x_cc[i]) * WGD->u[idm])
TURBWall.cpp:         / (TGD->x_fc[i + 1] - TGD->x_fc[i]);
TURBWall.cpp:    // u_hat-
TURBWall.cpp:    idp = id_fc + 1 - nx;// i+1,j-1,k
TURBWall.cpp:    idm = id_fc - nx;// i,j-1,k
TURBWall.cpp:    um = ((TGD->x_cc[i] - TGD->x_fc[i]) * WGD->u[idp]
TURBWall.cpp:          + (TGD->x_fc[i + 1] - TGD->x_cc[i]) * WGD->u[idm])
TURBWall.cpp:         / (TGD->x_fc[i + 1] - TGD->x_fc[i]);
TURBWall.cpp:    dudy = (up - um) / (TGD->y_cc[j + 1] - TGD->y_cc[j - 1]);
TURBWall.cpp:    wp = ((TGD->z_cc[k - 1] - TGD->z_fc[k]) * WGD->w[idp]
TURBWall.cpp:          + (TGD->z_fc[k + 1] - TGD->z_cc[k]) * WGD->w[idm])
TURBWall.cpp:         / (TGD->z_fc[k + 1] - TGD->z_fc[k]);
TURBWall.cpp:    // w_hat-
TURBWall.cpp:    idp = id_fc - nx + nx * ny;// i,j-1,k+1
TURBWall.cpp:    idm = id_fc - nx;// i,j-1,k
TURBWall.cpp:    wp = ((TGD->z_cc[k] - TGD->z_fc[k]) * WGD->w[idp]
TURBWall.cpp:          + (TGD->z_fc[k + 1] - TGD->z_cc[k]) * WGD->w[idm])
TURBWall.cpp:         / (TGD->z_fc[k + 1] - TGD->z_fc[k]);
TURBWall.cpp:    dwdy = (wp - wm) / (TGD->y_cc[j + 1] - TGD->y_cc[j - 1]);
TURBWall.cpp:  // wind gradients in Z-direction
TURBWall.cpp:  // dwdz = [w(i,j,k+1)-w(i,j,k)]/(Delta z)
TURBWall.cpp:  dwdz = (WGD->w[id_fc + nx * ny] - WGD->w[id_fc]) / (TGD->z_fc[k + 1] - TGD->z_fc[k]);
TURBWall.cpp:  // Three cases: 1) wall below (k-1), 2) wall above (k+1) 3) no wall in y-direction
TURBWall.cpp:  if (WGD->icellflag[id_cc - (nx - 1) * (ny - 1)] == flag2check) {
TURBWall.cpp:    up = ((TGD->x_cc[i] - TGD->x_fc[i]) * WGD->u[idp]
TURBWall.cpp:          + (TGD->x_fc[i + 1] - TGD->x_cc[i]) * WGD->u[idm])
TURBWall.cpp:         / (TGD->x_fc[i + 1] - TGD->x_fc[i]);
TURBWall.cpp:    dudz = up / ((TGD->z_cc[k] - TGD->z_fc[k]) * log((TGD->z_cc[k] - TGD->z_fc[k]) / z0));
TURBWall.cpp:    vp = ((TGD->y_cc[j] - TGD->y_fc[j]) * WGD->v[idp]
TURBWall.cpp:          + (TGD->y_fc[j + 1] - TGD->y_cc[j]) * WGD->v[idm])
TURBWall.cpp:         / (TGD->y_fc[j + 1] - TGD->y_fc[j]);
TURBWall.cpp:    dvdz = vp / ((TGD->z_cc[k] - TGD->z_fc[k]) * log((TGD->z_cc[k] - TGD->z_fc[k]) / z0));
TURBWall.cpp:  } else if (WGD->icellflag[id_cc + (nx - 1) * (ny - 1)] == flag2check) {
TURBWall.cpp:    // dudz=-u_hat/(0.5dz*log(0.5dz/z0))
TURBWall.cpp:    up = ((TGD->x_cc[i] - TGD->x_fc[i]) * WGD->u[idp]
TURBWall.cpp:          + (TGD->x_fc[i + 1] - TGD->x_cc[i]) * WGD->u[idm])
TURBWall.cpp:         / (TGD->x_fc[i + 1] - TGD->x_fc[i]);
TURBWall.cpp:    dudz = -up / ((TGD->z_fc[k + 1] - TGD->z_cc[k]) * log((TGD->z_fc[k + 1] - TGD->z_cc[k]) / z0));
TURBWall.cpp:    // dvdz=-v_hat/(0.5dz*log(0.5dz/z0))
TURBWall.cpp:    vp = ((TGD->y_cc[j] - TGD->y_fc[j]) * WGD->v[idp]
TURBWall.cpp:          + (TGD->y_fc[j + 1] - TGD->y_cc[j]) * WGD->v[idm])
TURBWall.cpp:         / (TGD->y_fc[j + 1] - TGD->y_fc[j]);
TURBWall.cpp:    dvdz = -vp / ((TGD->z_fc[k + 1] - TGD->z_cc[k]) * log((TGD->z_fc[k + 1] - TGD->z_cc[k]) / z0));
TURBWall.cpp:    up = ((TGD->x_cc[i] - TGD->x_fc[i]) * WGD->u[idp]
TURBWall.cpp:          + (TGD->x_fc[i + 1] - TGD->x_cc[i]) * WGD->u[idm])
TURBWall.cpp:         / (TGD->x_fc[i + 1] - TGD->x_fc[i]);
TURBWall.cpp:    // u_hat-
TURBWall.cpp:    idp = id_fc + 1 - nx * ny;// i+1,j,k-1
TURBWall.cpp:    idm = id_fc - nx * ny;// i,j,k-1
TURBWall.cpp:    um = ((TGD->x_cc[i] - TGD->x_fc[i]) * WGD->u[idp]
TURBWall.cpp:          + (TGD->x_fc[i + 1] - TGD->x_cc[i]) * WGD->u[idm])
TURBWall.cpp:         / (TGD->x_fc[i + 1] - TGD->x_fc[i]);
TURBWall.cpp:    dudz = (up - um) / (TGD->z_cc[k + 1] - TGD->z_cc[k - 1]);
TURBWall.cpp:    vp = ((TGD->y_cc[j] - TGD->y_fc[j]) * WGD->v[idp]
TURBWall.cpp:          + (TGD->y_fc[j + 1] - TGD->y_cc[j]) * WGD->v[idm])
TURBWall.cpp:         / (TGD->y_fc[j + 1] - TGD->y_fc[j]);
TURBWall.cpp:    // v_hat-
TURBWall.cpp:    idp = id_fc + nx - nx * ny;// i,j+1,k-1
TURBWall.cpp:    idm = id_fc - nx * ny;// i,j,k-1
TURBWall.cpp:    vm = ((TGD->y_cc[j] - TGD->y_fc[j]) * WGD->v[idp]
TURBWall.cpp:          + (TGD->y_fc[j + 1] - TGD->y_cc[j]) * WGD->v[idm])
TURBWall.cpp:         / (TGD->y_fc[j + 1] - TGD->y_fc[j]);
TURBWall.cpp:    dvdz = (vp - vm) / (TGD->z_cc[k + 1] - TGD->z_cc[k - 1]);
TURBWall.cpp:  // Strain-rate tensor
TURBWall.cpp:  TGD->Sxx[id_cc] = dudx;
TURBWall.cpp:  TGD->Syy[id_cc] = dvdy;
TURBWall.cpp:  TGD->Szz[id_cc] = dwdz;
TURBWall.cpp:  // off-diagonal terms
TURBWall.cpp:  TGD->Sxy[id_cc] = 0.5 * (dudy + dvdx);
TURBWall.cpp:  TGD->Syz[id_cc] = 0.5 * (dvdz + dwdy);
TURBWall.cpp:  TGD->Sxz[id_cc] = 0.5 * (dudz + dwdx);
TURBWall.cpp:  int nx = WGD->nx;
TURBWall.cpp:  int ny = WGD->ny;
TURBWall.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWall.cpp:    TGD->Gxz[it->cellID] = (0.5 * (WGD->u[it->faceID + nx * ny] + WGD->u[it->faceID + 1 + nx * ny])
TURBWall.cpp:                            - 0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1]))
TURBWall.cpp:                           / (WGD->z[k + 1] - WGD->z[k]);
TURBWall.cpp:    TGD->Gyz[it->cellID] = (0.5 * (WGD->v[it->faceID + nx * ny] + WGD->v[it->faceID + nx + nx * ny])
TURBWall.cpp:                            - 0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + nx]))
TURBWall.cpp:                           / (WGD->z[k + 1] - WGD->z[k]);
TURBWall.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWall.cpp:    TGD->Gxz[it->cellID] = (0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1])
TURBWall.cpp:                            - 0.5 * (WGD->u[it->faceID - nx * ny] + WGD->u[it->faceID + 1 - nx * ny]))
TURBWall.cpp:                           / (WGD->z[k] - WGD->z[k - 1]);
TURBWall.cpp:    TGD->Gyz[it->cellID] = (0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + nx])
TURBWall.cpp:                            - 0.5 * (WGD->v[it->faceID - nx * ny] + WGD->v[it->faceID + nx - nx * ny]))
TURBWall.cpp:                           / (WGD->z[k] - WGD->z[k - 1]);
TURBWall.cpp:    TGD->Gyx[it->cellID] = (0.5 * (WGD->v[it->faceID + 1] + WGD->v[it->faceID + 1 + nx])
TURBWall.cpp:                            - 0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + nx]))
TURBWall.cpp:                           / WGD->dx;
TURBWall.cpp:    TGD->Gzx[it->cellID] = (0.5 * (WGD->w[it->faceID + 1] + WGD->w[it->faceID + 1 + nx * ny])
TURBWall.cpp:                            - 0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny]))
TURBWall.cpp:                           / WGD->dx;
TURBWall.cpp:    TGD->Gyx[it->cellID] = (0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + nx])
TURBWall.cpp:                            - 0.5 * (WGD->v[it->faceID - 1] + WGD->v[it->faceID - 1 + nx]))
TURBWall.cpp:                           / WGD->dx;
TURBWall.cpp:    TGD->Gzx[it->cellID] = (0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny])
TURBWall.cpp:                            - 0.5 * (WGD->w[it->faceID - 1] + WGD->w[it->faceID - 1 + nx * ny]))
TURBWall.cpp:                           / WGD->dx;
TURBWall.cpp:    TGD->Gxy[it->cellID] = (0.5 * (WGD->u[it->faceID + nx] + WGD->u[it->faceID + 1 + nx])
TURBWall.cpp:                            - 0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1]))
TURBWall.cpp:                           / WGD->dy;
TURBWall.cpp:    TGD->Gzy[it->cellID] = (0.5 * (WGD->w[it->faceID + nx] + WGD->w[it->faceID + nx + nx * ny])
TURBWall.cpp:                            - 0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny]))
TURBWall.cpp:                           / WGD->dy;
TURBWall.cpp:    TGD->Gxy[it->cellID] = (0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1])
TURBWall.cpp:                            - 0.5 * (WGD->u[it->faceID - nx] + WGD->u[it->faceID + 1 - nx]))
TURBWall.cpp:                           / WGD->dy;
TURBWall.cpp:    TGD->Gzy[it->cellID] = (0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny])
TURBWall.cpp:                            - 0.5 * (WGD->w[it->faceID - nx] + WGD->w[it->faceID - nx + nx * ny]))
TURBWall.cpp:                           / WGD->dy;
TURBWall.cpp:  int nx = WGD->nx;
TURBWall.cpp:  int ny = WGD->ny;
TURBWall.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWall.cpp:    TGD->tmp_dtozdz[it->cellID] = (toz[it->cellID + (nx - 1) * (ny - 1)] - toz[it->cellID])
TURBWall.cpp:                                  / (WGD->z[k + 1] - WGD->z[k]);
TURBWall.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWall.cpp:    TGD->tmp_dtozdz[it->cellID] = (toz[it->cellID] - toz[it->cellID - (nx - 1) * (ny - 1)])
TURBWall.cpp:                                  / (WGD->z[k + 1] - WGD->z[k]);
TURBWall.cpp:    TGD->tmp_dtoxdx[it->cellID] = (tox[it->cellID + 1] - tox[it->cellID]) / WGD->dx;
TURBWall.cpp:    TGD->tmp_dtoxdx[it->cellID] = (toy[it->cellID] - tox[it->cellID - 1]) / WGD->dx;
TURBWall.cpp:    TGD->tmp_dtoydy[it->cellID] = (toy[it->cellID + (nx - 1)] - toy[it->cellID]) / WGD->dy;
TURBWall.cpp:    TGD->tmp_dtoydy[it->cellID] = (toy[it->cellID] - toy[it->cellID - (nx - 1)]) / WGD->dy;
TURBWall.h: * This file is part of QES-Winds
TURBWall.h: * GPL-3.0 License
TURBWall.h: * QES-Winds is free software: you can redistribute it and/or modify
TURBWall.h: * QES-Winds is distributed in the hope that it will be useful,
TURBWall.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
TURBWall.h:  // cells above wall (for stair-step methods for Wall BC)
TURBWall.h:  // cut-cell cells
TURBWallTerrain.cpp: * This file is part of QES-Winds
TURBWallTerrain.cpp: * GPL-3.0 License
TURBWallTerrain.cpp: * QES-Winds is free software: you can redistribute it and/or modify
TURBWallTerrain.cpp: * QES-Winds is distributed in the hope that it will be useful,
TURBWallTerrain.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
TURBWallTerrain.cpp:  if (WID->simParams->meshTypeFlag == 1) {
TURBWallTerrain.cpp:    // [FM] temporary fix -> use stairstep within the cut-cell
TURBWallTerrain.cpp:    if (WID->turbParams->terrainWallFlag == 1) {
TURBWallTerrain.cpp:    } else if (WID->turbParams->terrainWallFlag == 2) {
TURBWallTerrain.cpp:  if (comp_wall_velocity_deriv) (this->*comp_wall_velocity_deriv)(WGD, TGD);
TURBWallTerrain.cpp:  if (comp_wall_stress_deriv) (this->*comp_wall_stress_deriv)(WGD, TGD, tox, toy, toz);
TURBWallTerrain.cpp:  int nx = WGD->nx;
TURBWallTerrain.cpp:  int ny = WGD->ny;
TURBWallTerrain.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWallTerrain.cpp:    int j = (int)((it->cellID - k * (nx - 1) * (ny - 1)) / (nx - 1));
TURBWallTerrain.cpp:    int i = it->cellID - j * (nx - 1) - k * (nx - 1) * (ny - 1);
TURBWallTerrain.cpp:    float z0 = (WGD->z0_domain_u[i + j * nx] + WGD->z0_domain_u[i + 1 + j * nx]
TURBWallTerrain.cpp:                + WGD->z0_domain_v[i + j * nx] + WGD->z0_domain_v[i + (j + 1) * nx])
TURBWallTerrain.cpp:    TGD->Gxz[it->cellID] = 0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dz_array[k] * log(0.5 * WGD->dz_array[k] / z0));
TURBWallTerrain.cpp:    TGD->Gyz[it->cellID] = 0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + nx])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dz_array[k] * log(0.5 * WGD->dz_array[k] / z0));
TURBWallTerrain.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWallTerrain.cpp:    int j = (int)((it->cellID - k * (nx - 1) * (ny - 1)) / (nx - 1));
TURBWallTerrain.cpp:    int i = it->cellID - j * (nx - 1) - k * (nx - 1) * (ny - 1);
TURBWallTerrain.cpp:    float z0 = (WGD->z0_domain_u[i + j * nx] + WGD->z0_domain_u[i + 1 + j * nx]
TURBWallTerrain.cpp:                + WGD->z0_domain_v[i + j * nx] + WGD->z0_domain_v[i + (j + 1) * nx])
TURBWallTerrain.cpp:    TGD->Gxz[it->cellID] = 0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dz_array[k] * log(0.5 * WGD->dz_array[k] / z0));
TURBWallTerrain.cpp:    TGD->Gyz[it->cellID] = 0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + nx])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dz_array[k] * log(0.5 * WGD->dz_array[k] / z0));
TURBWallTerrain.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWallTerrain.cpp:    int j = (int)((it->cellID - k * (nx - 1) * (ny - 1)) / (nx - 1));
TURBWallTerrain.cpp:    int i = it->cellID - j * (nx - 1) - k * (nx - 1) * (ny - 1);
TURBWallTerrain.cpp:    float z0 = (WGD->z0_domain_u[i + j * nx] + WGD->z0_domain_u[i + 1 + j * nx]
TURBWallTerrain.cpp:                + WGD->z0_domain_v[i + j * nx] + WGD->z0_domain_v[i + (j + 1) * nx])
TURBWallTerrain.cpp:    TGD->Gyx[it->cellID] = 0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + nx])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dx * log(0.5 * WGD->dx / z0));
TURBWallTerrain.cpp:    TGD->Gzx[it->cellID] = 0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dx * log(0.5 * WGD->dx / z0));
TURBWallTerrain.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWallTerrain.cpp:    int j = (int)((it->cellID - k * (nx - 1) * (ny - 1)) / (nx - 1));
TURBWallTerrain.cpp:    int i = it->cellID - j * (nx - 1) - k * (nx - 1) * (ny - 1);
TURBWallTerrain.cpp:    float z0 = (WGD->z0_domain_u[i + j * nx] + WGD->z0_domain_u[i + 1 + j * nx]
TURBWallTerrain.cpp:                + WGD->z0_domain_v[i + j * nx] + WGD->z0_domain_v[i + (j + 1) * nx])
TURBWallTerrain.cpp:    TGD->Gyx[it->cellID] = 0.5 * (WGD->v[it->faceID] + WGD->v[it->faceID + nx])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dx * log(0.5 * WGD->dx / z0));
TURBWallTerrain.cpp:    TGD->Gzx[it->cellID] = 0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dx * log(0.5 * WGD->dx / z0));
TURBWallTerrain.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWallTerrain.cpp:    int j = (int)((it->cellID - k * (nx - 1) * (ny - 1)) / (nx - 1));
TURBWallTerrain.cpp:    int i = it->cellID - j * (nx - 1) - k * (nx - 1) * (ny - 1);
TURBWallTerrain.cpp:    float z0 = (WGD->z0_domain_u[i + j * nx] + WGD->z0_domain_u[i + 1 + j * nx]
TURBWallTerrain.cpp:                + WGD->z0_domain_v[i + j * nx] + WGD->z0_domain_v[i + (j + 1) * nx])
TURBWallTerrain.cpp:    TGD->Gxy[it->cellID] = 0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dy * log(0.5 * WGD->dy / z0));
TURBWallTerrain.cpp:    TGD->Gzy[it->cellID] = 0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dy * log(0.5 * WGD->dy / z0));
TURBWallTerrain.cpp:    int k = (int)(it->cellID / ((nx - 1) * (ny - 1)));
TURBWallTerrain.cpp:    int j = (int)((it->cellID - k * (nx - 1) * (ny - 1)) / (nx - 1));
TURBWallTerrain.cpp:    int i = it->cellID - j * (nx - 1) - k * (nx - 1) * (ny - 1);
TURBWallTerrain.cpp:    float z0 = (WGD->z0_domain_u[i + j * nx] + WGD->z0_domain_u[i + 1 + j * nx]
TURBWallTerrain.cpp:                + WGD->z0_domain_v[i + j * nx] + WGD->z0_domain_v[i + (j + 1) * nx])
TURBWallTerrain.cpp:    TGD->Gxy[it->cellID] = 0.5 * (WGD->u[it->faceID] + WGD->u[it->faceID + 1])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dy * log(0.5 * WGD->dy / z0));
TURBWallTerrain.cpp:    TGD->Gzy[it->cellID] = 0.5 * (WGD->w[it->faceID] + WGD->w[it->faceID + nx * ny])
TURBWallTerrain.cpp:                           / (0.5 * WGD->dy * log(0.5 * WGD->dy / z0));
TURBWallTerrain.h: * This file is part of QES-Winds
TURBWallTerrain.h: * GPL-3.0 License
TURBWallTerrain.h: * QES-Winds is free software: you can redistribute it and/or modify
TURBWallTerrain.h: * QES-Winds is distributed in the hope that it will be useful,
TURBWallTerrain.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
UpwindCavity.cpp: * This file is part of QES-Winds
UpwindCavity.cpp: * GPL-3.0 License
UpwindCavity.cpp: * QES-Winds is free software: you can redistribute it and/or modify
UpwindCavity.cpp: * QES-Winds is distributed in the hope that it will be useful,
UpwindCavity.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
UpwindCavity.cpp: * More information: "Improvements to a fast-response urban wind model, M. Nelson et al. (2008)"
UpwindCavity.cpp:  int index_building_face = i_building_cent + j_building_cent * WGD->nx + (k_end)*WGD->nx * WGD->ny;
UpwindCavity.cpp:  u0_h = WGD->u0[index_building_face];// u velocity at the height of building at the centroid
UpwindCavity.cpp:  v0_h = WGD->v0[index_building_face];// v velocity at the height of building at the centroid
UpwindCavity.cpp:  for (auto id = 0; id < polygonVertices.size() - 1; id++) {
UpwindCavity.cpp:    xf1[id] = 0.5 * (polygonVertices[id].x_poly - polygonVertices[id + 1].x_poly) * cos(upwind_dir)
UpwindCavity.cpp:              + 0.5 * (polygonVertices[id].y_poly - polygonVertices[id + 1].y_poly) * sin(upwind_dir);
UpwindCavity.cpp:    yf1[id] = -0.5 * (polygonVertices[id].x_poly - polygonVertices[id + 1].x_poly) * sin(upwind_dir)
UpwindCavity.cpp:              + 0.5 * (polygonVertices[id].y_poly - polygonVertices[id + 1].y_poly) * cos(upwind_dir);
UpwindCavity.cpp:    xf2[id] = 0.5 * (polygonVertices[id + 1].x_poly - polygonVertices[id].x_poly) * cos(upwind_dir)
UpwindCavity.cpp:              + 0.5 * (polygonVertices[id + 1].y_poly - polygonVertices[id].y_poly) * sin(upwind_dir);
UpwindCavity.cpp:    yf2[id] = -0.5 * (polygonVertices[id + 1].x_poly - polygonVertices[id].x_poly) * sin(upwind_dir)
UpwindCavity.cpp:              + 0.5 * (polygonVertices[id + 1].y_poly - polygonVertices[id].y_poly) * cos(upwind_dir);
UpwindCavity.cpp:    upwind_rel_dir[id] = atan2(yf2[id] - yf1[id], xf2[id] - xf1[id]) + 0.5 * M_PI;
UpwindCavity.cpp:      upwind_rel_dir[id] -= 2 * M_PI;
UpwindCavity.cpp:    if (abs(upwind_rel_dir[id]) > M_PI - tol) {
UpwindCavity.cpp:      perpendicular_dir[id] = atan2(polygonVertices[id + 1].y_poly - polygonVertices[id].y_poly,
UpwindCavity.cpp:                                    polygonVertices[id + 1].x_poly - polygonVertices[id].x_poly)
UpwindCavity.cpp:      if (perpendicular_dir[id] <= -M_PI) {
UpwindCavity.cpp:        effective_gamma[id] = perpendicular_dir[id] - M_PI;
UpwindCavity.cpp:        effective_gamma[id] = perpendicular_dir[id] - 0.5 * M_PI;
UpwindCavity.cpp:      } else if (perpendicular_dir[id] < -0.75 * M_PI) {
UpwindCavity.cpp:      } else if (perpendicular_dir[id] < -0.25 * M_PI) {
UpwindCavity.cpp:      vh_rotation = -u0_h * sin(effective_gamma[id]) + v0_h * cos(effective_gamma[id]);
UpwindCavity.cpp:      face_length.push_back(sqrt(pow(xf2[id] - xf1[id], 2.0) + pow(yf2[id] - yf1[id], 2.0)));
UpwindCavity.cpp:      Lf_face.push_back(abs(WGD->lengthf_coeff * face_length[counter] * cos(upwind_rel_dir[id]) / (1 + 0.8 * face_length[counter] / H)));
UpwindCavity.cpp:      // High-rise Modified Vortex Parameterization (HMVP) (Bagal et al. (2004))
UpwindCavity.cpp:      if (WID->simParams->upwindCavityFlag == 3) {
UpwindCavity.cpp:      for (auto k = k_start; k < WGD->z.size(); k++) {
UpwindCavity.cpp:        if (height_factor * retarding_height + base_height <= WGD->z[k]) {
UpwindCavity.cpp:      upwind_i_start = MAX_S(std::round(MIN_S(polygonVertices[id].x_poly, polygonVertices[id + 1].x_poly) / WGD->dx)
UpwindCavity.cpp:                               - std::round(1.5 * Lf_face[counter] / WGD->dx) - 1,
UpwindCavity.cpp:      upwind_i_end = MIN_S(std::round(MAX_S(polygonVertices[id].x_poly, polygonVertices[id + 1].x_poly) / WGD->dx)
UpwindCavity.cpp:                             + std::round(1.5 * Lf_face[counter] / WGD->dx),
UpwindCavity.cpp:                           WGD->nx - 2);
UpwindCavity.cpp:      upwind_j_start = MAX_S(std::round(MIN_S(polygonVertices[id].y_poly, polygonVertices[id + 1].y_poly) / WGD->dy)
UpwindCavity.cpp:                               - std::round(1.5 * Lf_face[counter] / WGD->dy) - 1,
UpwindCavity.cpp:      upwind_j_end = MIN_S(std::round(MAX_S(polygonVertices[id].y_poly, polygonVertices[id + 1].y_poly) / WGD->dy)
UpwindCavity.cpp:                             + std::round(1.5 * Lf_face[counter] / WGD->dy),
UpwindCavity.cpp:                           WGD->ny - 2);
UpwindCavity.cpp:      x_average = 0.5 * (polygonVertices[id].x_poly + polygonVertices[id + 1].x_poly);// x-location of middle of the face
UpwindCavity.cpp:      y_average = 0.5 * (polygonVertices[id].y_poly + polygonVertices[id + 1].y_poly);// y-location of middle of the face
UpwindCavity.cpp:        z_front = WGD->z[k] - base_height;// Height from the base of the building
UpwindCavity.cpp:            x_u = (i * WGD->dx - x_average) * cos(upwind_dir) + ((j + 0.5) * WGD->dy - y_average) * sin(upwind_dir);// x-location of u velocity
UpwindCavity.cpp:            y_u = -(i * WGD->dx - x_average) * sin(upwind_dir) + ((j + 0.5) * WGD->dy - y_average) * cos(upwind_dir);// y-location of u velocity
UpwindCavity.cpp:            x_v = ((i + 0.5) * WGD->dx - x_average) * cos(upwind_dir) + (j * WGD->dy - y_average) * sin(upwind_dir);// x-location of v velocity
UpwindCavity.cpp:            y_v = -((i + 0.5) * WGD->dx - x_average) * sin(upwind_dir) + (j * WGD->dy - y_average) * cos(upwind_dir);// y-location of v velocity
UpwindCavity.cpp:            x_w = ((i + 0.5) * WGD->dx - x_average) * cos(upwind_dir) + ((j + 0.5) * WGD->dy - y_average) * sin(upwind_dir);// x-location of w velocity
UpwindCavity.cpp:            y_w = -((i + 0.5) * WGD->dx - x_average) * sin(upwind_dir) + ((j + 0.5) * WGD->dy - y_average) * cos(upwind_dir);// y-location of w velocity
UpwindCavity.cpp:              x_intersect_u = ((xf2[id] - xf1[id]) / (yf2[id] - yf1[id])) * (y_u - yf1[id]) + xf1[id];
UpwindCavity.cpp:              x_ellipse_u = -Lf_face[counter] * sqrt((1 - pow(y_u / abs(yf2[id]), 2.0)) * (1 - pow(z_front / (height_factor * vortex_height), 2.0)));
UpwindCavity.cpp:              xrz_u = -Lf_face[counter] * sqrt((1 - pow(y_u / abs(yf2[id]), 2.0)) * (1 - pow(z_front / (height_factor * retarding_height), 2.0)));
UpwindCavity.cpp:              icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
UpwindCavity.cpp:              icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
UpwindCavity.cpp:              if (WID->simParams->upwindCavityFlag == 1)// Rockle parameterization
UpwindCavity.cpp:                if ((x_u - x_intersect_u >= x_ellipse_u) && (x_u - x_intersect_u <= 0.1 * WGD->dxy)
UpwindCavity.cpp:                    && (WGD->icellflag[icell_cent] != 0) && (WGD->icellflag[icell_cent] != 2)) {
UpwindCavity.cpp:                  WGD->u0[icell_face] = 0.0;
UpwindCavity.cpp:                if ((x_u - x_intersect_u >= xrz_u) && (x_u - x_intersect_u < rz_end)
UpwindCavity.cpp:                    && (WGD->icellflag[icell_cent] != 0) && (WGD->icellflag[icell_cent] != 2)) {
UpwindCavity.cpp:                  if (WID->simParams->upwindCavityFlag == 3)// High-rise Modified Vortex Parameterization (HMVP) (Bagal et al. (2004))
UpwindCavity.cpp:                    WGD->u0[icell_face] *= ((x_u - x_intersect_u - xrz_u) * (retarding_factor - 1.0) / (rz_end - xrz_u) + 1.0);
UpwindCavity.cpp:                    WGD->u0[icell_face] *= retarding_factor;
UpwindCavity.cpp:                if ((x_u - x_intersect_u >= length_factor * x_ellipse_u) && (x_u - x_intersect_u <= 0.1 * WGD->dxy)
UpwindCavity.cpp:                    && (WGD->icellflag[icell_cent] != 0) && (WGD->icellflag[icell_cent] != 2)) {
UpwindCavity.cpp:                  u_rotation = WGD->u0[icell_face] * cos(effective_gamma[id]);
UpwindCavity.cpp:                  v_rotation = WGD->u0[icell_face] * sin(effective_gamma[id]);
UpwindCavity.cpp:                    v_rotation = -vh_rotation * (-height_factor * cos(M_PI * z_front / (0.5 * vortex_height)) + 0.05)
UpwindCavity.cpp:                                 * (-height_factor * sin(M_PI * abs(x_u - x_intersect_u) / (length_factor * Lf_face[counter])));
UpwindCavity.cpp:                    u_rotation = -uh_rotation * (-height_factor * cos(M_PI * z_front / (0.5 * vortex_height)) + 0.05)
UpwindCavity.cpp:                                 * (-height_factor * sin(M_PI * abs(x_u - x_intersect_u) / (length_factor * Lf_face[counter])));
UpwindCavity.cpp:                  WGD->u0[icell_face] = u_rotation * cos(-effective_gamma[id]) + v_rotation * sin(-effective_gamma[id]);
UpwindCavity.cpp:              x_intersect_v = ((xf2[id] - xf1[id]) / (yf2[id] - yf1[id])) * (y_v - yf1[id]) + xf1[id];
UpwindCavity.cpp:              x_ellipse_v = -Lf_face[counter] * sqrt((1 - pow(y_v / abs(yf2[id]), 2.0)) * (1 - pow(z_front / (height_factor * vortex_height), 2.0)));
UpwindCavity.cpp:              xrz_v = -Lf_face[counter] * sqrt((1 - pow(y_v / abs(yf2[id]), 2.0)) * (1 - pow(z_front / (height_factor * retarding_height), 2.0)));
UpwindCavity.cpp:              icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
UpwindCavity.cpp:              icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
UpwindCavity.cpp:              if (WID->simParams->upwindCavityFlag == 1)// Rockle parameterization
UpwindCavity.cpp:                if ((x_v - x_intersect_v >= x_ellipse_v) && (x_v - x_intersect_v <= 0.1 * WGD->dxy)
UpwindCavity.cpp:                    && (WGD->icellflag[icell_cent] != 0) && (WGD->icellflag[icell_cent] != 2)) {
UpwindCavity.cpp:                  WGD->v0[icell_face] = 0.0;
UpwindCavity.cpp:                if ((x_v - x_intersect_v >= xrz_v) && (x_v - x_intersect_v < rz_end)
UpwindCavity.cpp:                    && (WGD->icellflag[icell_cent] != 0) && (WGD->icellflag[icell_cent] != 2)) {
UpwindCavity.cpp:                  if (WID->simParams->upwindCavityFlag == 3)// High-rise Modified Vortex Parameterization (HMVP) (Bagal et al. (2004))
UpwindCavity.cpp:                    WGD->v0[icell_face] *= ((x_v - x_intersect_v - xrz_v) * (retarding_factor - 1.0) / (rz_end - xrz_v) + 1.0);
UpwindCavity.cpp:                    WGD->v0[icell_face] *= retarding_factor;
UpwindCavity.cpp:                if ((x_v - x_intersect_v >= length_factor * x_ellipse_v) && (x_v - x_intersect_v <= 0.1 * WGD->dxy)
UpwindCavity.cpp:                    && (WGD->icellflag[icell_cent] != 0) && (WGD->icellflag[icell_cent] != 2)) {
UpwindCavity.cpp:                  u_rotation = WGD->v0[icell_face] * sin(effective_gamma[id]);
UpwindCavity.cpp:                  v_rotation = WGD->v0[icell_face] * cos(effective_gamma[id]);
UpwindCavity.cpp:                    v_rotation = -vh_rotation * (-height_factor * cos(M_PI * z_front / (0.5 * vortex_height)) + 0.05)
UpwindCavity.cpp:                                 * (-height_factor * sin(M_PI * abs(x_v - x_intersect_v) / (length_factor * Lf_face[counter])));
UpwindCavity.cpp:                    u_rotation = -uh_rotation * (-height_factor * cos(M_PI * z_front / (0.5 * vortex_height)) + 0.05)
UpwindCavity.cpp:                                 * (-height_factor * sin(M_PI * abs(x_v - x_intersect_v) / (length_factor * Lf_face[counter])));
UpwindCavity.cpp:                  WGD->v0[icell_face] = -u_rotation * sin(-effective_gamma[id]) + v_rotation * cos(-effective_gamma[id]);
UpwindCavity.cpp:              x_intersect_w = ((xf2[id] - xf1[id]) / (yf2[id] - yf1[id])) * (y_w - yf1[id]) + xf1[id];
UpwindCavity.cpp:              x_ellipse_w = -Lf_face[counter] * sqrt((1 - pow(y_w / abs(yf2[id]), 2.0)) * (1 - pow(z_front / (height_factor * vortex_height), 2.0)));
UpwindCavity.cpp:              icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
UpwindCavity.cpp:              icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
UpwindCavity.cpp:              if (WID->simParams->upwindCavityFlag == 1)// Rockle parameterization
UpwindCavity.cpp:                if ((x_w - x_intersect_w >= x_ellipse_w) && (x_w - x_intersect_w <= 0.1 * WGD->dxy)
UpwindCavity.cpp:                    && (WGD->icellflag[icell_cent] != 0) && (WGD->icellflag[icell_cent] != 2)) {
UpwindCavity.cpp:                  WGD->w0[icell_face] = 0.0;
UpwindCavity.cpp:                  if (i < WGD->nx - 1 && j < WGD->ny - 1 && k < WGD->nz - 2
UpwindCavity.cpp:                      && (WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
UpwindCavity.cpp:                    WGD->icellflag[icell_cent] = 3;
UpwindCavity.cpp:                if ((x_w - x_intersect_w >= x_ellipse_w) && (x_w - x_intersect_w < length_factor * x_ellipse_w)
UpwindCavity.cpp:                    && (WGD->icellflag[icell_cent] != 0) && (WGD->icellflag[icell_cent] != 2)) {
UpwindCavity.cpp:                  WGD->w0[icell_face] *= retarding_factor;
UpwindCavity.cpp:                  if (i < WGD->nx - 1 && j < WGD->ny - 1 && k < WGD->nz - 2
UpwindCavity.cpp:                      && (WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
UpwindCavity.cpp:                    WGD->icellflag[icell_cent] = 3;
UpwindCavity.cpp:                if ((x_w - x_intersect_w >= length_factor * x_ellipse_w)
UpwindCavity.cpp:                    && (x_w - x_intersect_w <= 0.1 * WGD->dxy) && (WGD->icellflag[icell_cent] != 0) && (WGD->icellflag[icell_cent] != 2)) {
UpwindCavity.cpp:                  WGD->w0[icell_face] = -sqrt(pow(u0_h, 2.0) + pow(v0_h, 2.0))
UpwindCavity.cpp:                                        * (0.1 * cos(M_PI * abs(x_w - x_intersect_w) / (length_factor * Lf_face[counter])) - 0.05);
UpwindCavity.cpp:                  if (i < WGD->nx - 1 && j < WGD->ny - 1 && k < WGD->nz - 2
UpwindCavity.cpp:                      && (WGD->icellflag[icell_cent] != 7) && (WGD->icellflag[icell_cent] != 8)) {
UpwindCavity.cpp:                    WGD->icellflag[icell_cent] = 3;
Wall.cpp: * This file is part of QES-Winds
Wall.cpp: * GPL-3.0 License
Wall.cpp: * QES-Winds is free software: you can redistribute it and/or modify
Wall.cpp: * QES-Winds is distributed in the hope that it will be useful,
Wall.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Wall.cpp:  float dx = WGD->dx;
Wall.cpp:  float dy = WGD->dy;
Wall.cpp:  float dz = WGD->dz;
Wall.cpp:  int nx = WGD->nx;
Wall.cpp:  int ny = WGD->ny;
Wall.cpp:  int nz = WGD->nz;
Wall.cpp:  for (auto i = 0; i < nx - 1; i++) {
Wall.cpp:    for (auto j = 0; j < ny - 1; j++) {
Wall.cpp:      for (auto k = 1; k < nz - 1; k++) {
Wall.cpp:        int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
Wall.cpp:        if (WGD->e[icell_cent] < 0.05) {
Wall.cpp:          WGD->e[icell_cent] = 0.0;
Wall.cpp:        if (WGD->f[icell_cent] < 0.05) {
Wall.cpp:          WGD->f[icell_cent] = 0.0;
Wall.cpp:        if (WGD->g[icell_cent] < 0.05) {
Wall.cpp:          WGD->g[icell_cent] = 0.0;
Wall.cpp:        if (WGD->h[icell_cent] < 0.05) {
Wall.cpp:          WGD->h[icell_cent] = 0.0;
Wall.cpp:        if (WGD->m[icell_cent] < 0.05) {
Wall.cpp:          WGD->m[icell_cent] = 0.0;
Wall.cpp:        if (WGD->n[icell_cent] < 0.05) {
Wall.cpp:          WGD->n[icell_cent] = 0.0;
Wall.cpp:        if (WGD->e[icell_cent] > 1.0) {
Wall.cpp:          WGD->e[icell_cent] = 1.0;
Wall.cpp:        if (WGD->f[icell_cent] > 1.0) {
Wall.cpp:          WGD->f[icell_cent] = 1.0;
Wall.cpp:        if (WGD->g[icell_cent] > 1.0) {
Wall.cpp:          WGD->g[icell_cent] = 1.0;
Wall.cpp:        if (WGD->h[icell_cent] > 1.0) {
Wall.cpp:          WGD->h[icell_cent] = 1.0;
Wall.cpp:        if (WGD->m[icell_cent] > 1.0) {
Wall.cpp:          WGD->m[icell_cent] = 1.0;
Wall.cpp:        if (WGD->n[icell_cent] > 1.0) {
Wall.cpp:          WGD->n[icell_cent] = 1.0;
Wall.cpp:  for (auto i = 0; i < nx - 1; i++) {
Wall.cpp:    for (auto j = 0; j < ny - 1; j++) {
Wall.cpp:      for (auto k = 1; k < nz - 1; k++) {
Wall.cpp:        int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
Wall.cpp:        if ((WGD->icellflag[icell_cent] == 7 || WGD->icellflag[icell_cent] == 0) && WGD->building_volume_frac[icell_cent] <= 0.1) {
Wall.cpp:          WGD->icellflag[icell_cent] = 0;
Wall.cpp:          WGD->e[icell_cent] = 1.0;
Wall.cpp:          WGD->f[icell_cent] = 1.0;
Wall.cpp:          WGD->g[icell_cent] = 1.0;
Wall.cpp:          WGD->h[icell_cent] = 1.0;
Wall.cpp:          WGD->m[icell_cent] = 1.0;
Wall.cpp:          WGD->n[icell_cent] = 1.0;
Wall.cpp:  for (auto i = 0; i < nx - 1; i++) {
Wall.cpp:    for (auto j = 0; j < ny - 1; j++) {
Wall.cpp:      for (auto k = 1; k < nz - 1; k++) {
Wall.cpp:        int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
Wall.cpp:        if (WGD->e[icell_cent] == 0.0 && WGD->f[icell_cent] == 0.0 && WGD->g[icell_cent] == 0.0
Wall.cpp:            && WGD->h[icell_cent] == 0.0 && WGD->m[icell_cent] == 0.0 && WGD->n[icell_cent] == 0.0 && WGD->icellflag[icell_cent] == 7) {
Wall.cpp:          WGD->icellflag[icell_cent] = 0;
Wall.cpp:          WGD->e[icell_cent] = 1.0;
Wall.cpp:          WGD->f[icell_cent] = 1.0;
Wall.cpp:          WGD->g[icell_cent] = 1.0;
Wall.cpp:          WGD->h[icell_cent] = 1.0;
Wall.cpp:          WGD->m[icell_cent] = 1.0;
Wall.cpp:          WGD->n[icell_cent] = 1.0;
Wall.cpp:  for (auto i = 0; i < nx - 1; i++) {
Wall.cpp:    for (auto j = 0; j < ny - 1; j++) {
Wall.cpp:      for (auto k = 1; k < nz - 2; k++) {
Wall.cpp:        int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
Wall.cpp:        if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
Wall.cpp:          if (WGD->icellflag[icell_cent - (nx - 1) * (ny - 1)] == 0 || WGD->icellflag[icell_cent - (nx - 1) * (ny - 1)] == 2) {
Wall.cpp:            // WGD->wall_below_indices.push_back(icell_face);
Wall.cpp:            WGD->n[icell_cent] = 0.0;
Wall.cpp:          if (WGD->icellflag[icell_cent + (nx - 1) * (ny - 1)] == 0 || WGD->icellflag[icell_cent + (nx - 1) * (ny - 1)] == 2) {
Wall.cpp:            // WGD->wall_above_indices.push_back(icell_face);
Wall.cpp:            WGD->m[icell_cent] = 0.0;
Wall.cpp:          if (WGD->icellflag[icell_cent - 1] == 0 || WGD->icellflag[icell_cent - 1] == 2) {
Wall.cpp:              // WGD->wall_back_indices.push_back(icell_face);
Wall.cpp:              WGD->f[icell_cent] = 0.0;
Wall.cpp:          if (WGD->icellflag[icell_cent + 1] == 0 || WGD->icellflag[icell_cent + 1] == 2) {
Wall.cpp:            // WGD->wall_front_indices.push_back(icell_face);
Wall.cpp:            WGD->e[icell_cent] = 0.0;
Wall.cpp:          if (WGD->icellflag[icell_cent - (nx - 1)] == 0 || WGD->icellflag[icell_cent - (nx - 1)] == 2) {
Wall.cpp:              // WGD->wall_right_indices.push_back(icell_face);
Wall.cpp:              WGD->h[icell_cent] = 0.0;
Wall.cpp:          if (WGD->icellflag[icell_cent + (nx - 1)] == 0 || WGD->icellflag[icell_cent + (nx - 1)] == 2) {
Wall.cpp:            // WGD->wall_left_indices.push_back(icell_face);
Wall.cpp:            WGD->g[icell_cent] = 0.0;
Wall.cpp:        if (WGD->icellflag[icell_cent] == 1 || WGD->icellflag[icell_cent] == 7) {
Wall.cpp:          if (WGD->icellflag[icell_cent - (nx - 1) * (ny - 1)] == 7 || (WGD->icellflag[icell_cent - (nx - 1) * (ny - 1)] == 8 && WGD->n[icell_cent] == 1)) {
Wall.cpp:            WGD->n[icell_cent] = WGD->m[icell_cent - (nx - 1) * (ny - 1)];
Wall.cpp:          if (WGD->icellflag[icell_cent + (nx - 1) * (ny - 1)] == 7 || (WGD->icellflag[icell_cent + (nx - 1) * (ny - 1)] == 8 && WGD->m[icell_cent] == 1)) {
Wall.cpp:            WGD->m[icell_cent] = WGD->n[icell_cent + (nx - 1) * (ny - 1)];
Wall.cpp:          if (WGD->icellflag[icell_cent - 1] == 7 || (WGD->icellflag[icell_cent - 1] == 8 && WGD->f[icell_cent] == 1)) {
Wall.cpp:              WGD->f[icell_cent] = WGD->e[icell_cent - 1];
Wall.cpp:          if (WGD->icellflag[icell_cent + 1] == 7 || (WGD->icellflag[icell_cent + 1] == 8 && WGD->e[icell_cent] == 1)) {
Wall.cpp:            WGD->e[icell_cent] = WGD->f[icell_cent + 1];
Wall.cpp:          if (WGD->icellflag[icell_cent - (nx - 1)] == 7 || (WGD->icellflag[icell_cent - (nx - 1)] == 8 && WGD->h[icell_cent] == 1)) {
Wall.cpp:              WGD->h[icell_cent] = WGD->g[icell_cent - (nx - 1)];
Wall.cpp:          if (WGD->icellflag[icell_cent + (nx - 1)] == 7 || (WGD->icellflag[icell_cent + (nx - 1)] == 8 && WGD->g[icell_cent] == 1)) {
Wall.cpp:            WGD->g[icell_cent] = WGD->h[icell_cent + (nx - 1)];
Wall.cpp:        if (WGD->icellflag[icell_cent] == 1 || WGD->icellflag[icell_cent] == 8) {
Wall.cpp:          if (WGD->icellflag[icell_cent - (nx - 1) * (ny - 1)] == 7 || WGD->icellflag[icell_cent - (nx - 1) * (ny - 1)] == 8) {
Wall.cpp:            WGD->n[icell_cent] = WGD->m[icell_cent - (nx - 1) * (ny - 1)];
Wall.cpp:          if (WGD->icellflag[icell_cent + (nx - 1) * (ny - 1)] == 7 || WGD->icellflag[icell_cent + (nx - 1) * (ny - 1)] == 8) {
Wall.cpp:            WGD->m[icell_cent] = WGD->n[icell_cent + (nx - 1) * (ny - 1)];
Wall.cpp:          if (WGD->icellflag[icell_cent - 1] == 7 || WGD->icellflag[icell_cent - 1] == 8) {
Wall.cpp:              WGD->f[icell_cent] = WGD->e[icell_cent - 1];
Wall.cpp:          if (WGD->icellflag[icell_cent + 1] == 7 || WGD->icellflag[icell_cent + 1] == 8) {
Wall.cpp:            WGD->e[icell_cent] = WGD->f[icell_cent + 1];
Wall.cpp:          if (WGD->icellflag[icell_cent - (nx - 1)] == 7 || WGD->icellflag[icell_cent - (nx - 1)] == 8) {
Wall.cpp:              WGD->h[icell_cent] = WGD->g[icell_cent - (nx - 1)];
Wall.cpp:          if (WGD->icellflag[icell_cent + (nx - 1)] == 7 || WGD->icellflag[icell_cent + (nx - 1)] == 8) {
Wall.cpp:            WGD->g[icell_cent] = WGD->h[icell_cent + (nx - 1)];
Wall.cpp:  for (auto i = 0; i < nx - 1; i++) {
Wall.cpp:    for (auto j = 0; j < ny - 1; j++) {
Wall.cpp:      for (auto k = 1; k < nz - 1; k++) {
Wall.cpp:        int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
Wall.cpp:        if (WGD->e[icell_cent] == 0.0 && WGD->f[icell_cent] == 0.0 && WGD->g[icell_cent] == 0.0
Wall.cpp:            && WGD->h[icell_cent] == 0.0 && WGD->m[icell_cent] == 0.0 && WGD->n[icell_cent] == 0.0 && (WGD->icellflag[icell_cent] == 7 || WGD->icellflag[icell_cent] == 0)) {
Wall.cpp:          WGD->icellflag[icell_cent] = 0;
Wall.cpp:          WGD->e[icell_cent] = 1.0;
Wall.cpp:          WGD->f[icell_cent] = 1.0;
Wall.cpp:          WGD->g[icell_cent] = 1.0;
Wall.cpp:          WGD->h[icell_cent] = 1.0;
Wall.cpp:          WGD->m[icell_cent] = 1.0;
Wall.cpp:          WGD->n[icell_cent] = 1.0;
Wall.cpp:        if (WGD->e[icell_cent] == 0.0 && WGD->f[icell_cent] == 0.0 && WGD->g[icell_cent] == 0.0
Wall.cpp:            && WGD->h[icell_cent] == 0.0 && WGD->m[icell_cent] == 0.0 && WGD->n[icell_cent] == 0.0 && (WGD->icellflag[icell_cent] == 8 || WGD->icellflag[icell_cent] == 2)) {
Wall.cpp:          WGD->icellflag[icell_cent] = 2;
Wall.cpp:          WGD->e[icell_cent] = 1.0;
Wall.cpp:          WGD->f[icell_cent] = 1.0;
Wall.cpp:          WGD->g[icell_cent] = 1.0;
Wall.cpp:          WGD->h[icell_cent] = 1.0;
Wall.cpp:          WGD->m[icell_cent] = 1.0;
Wall.cpp:          WGD->n[icell_cent] = 1.0;
Wall.cpp:  for (auto i = 0; i < nx - 1; i++) {
Wall.cpp:    for (auto j = 0; j < ny - 1; j++) {
Wall.cpp:      for (auto k = 1; k < nz - 2; k++) {
Wall.cpp:        int icell_cent = i + j * (nx - 1) + k * (nx - 1) * (ny - 1);
Wall.cpp:        if (WGD->icellflag[icell_cent] != 0 && WGD->icellflag[icell_cent] != 2) {
Wall.cpp:          if (WGD->icellflag[icell_cent - (nx - 1) * (ny - 1)] == 0 || WGD->icellflag[icell_cent - (nx - 1) * (ny - 1)] == 2) {
Wall.cpp:            WGD->wall_below_indices.push_back(icell_face);
Wall.cpp:            WGD->n[icell_cent] = 0.0;
Wall.cpp:          if (WGD->icellflag[icell_cent + (nx - 1) * (ny - 1)] == 0 || WGD->icellflag[icell_cent + (nx - 1) * (ny - 1)] == 2) {
Wall.cpp:            WGD->wall_above_indices.push_back(icell_face);
Wall.cpp:            WGD->m[icell_cent] = 0.0;
Wall.cpp:          if (WGD->icellflag[icell_cent - 1] == 0 || WGD->icellflag[icell_cent - 1] == 2) {
Wall.cpp:              WGD->wall_back_indices.push_back(icell_face);
Wall.cpp:              WGD->f[icell_cent] = 0.0;
Wall.cpp:          if (WGD->icellflag[icell_cent + 1] == 0 || WGD->icellflag[icell_cent + 1] == 2) {
Wall.cpp:            WGD->wall_front_indices.push_back(icell_face);
Wall.cpp:            WGD->e[icell_cent] = 0.0;
Wall.cpp:          if (WGD->icellflag[icell_cent - (nx - 1)] == 0 || WGD->icellflag[icell_cent - (nx - 1)] == 2) {
Wall.cpp:              WGD->wall_right_indices.push_back(icell_face);
Wall.cpp:              WGD->h[icell_cent] = 0.0;
Wall.cpp:          if (WGD->icellflag[icell_cent + (nx - 1)] == 0 || WGD->icellflag[icell_cent + (nx - 1)] == 2) {
Wall.cpp:            WGD->wall_left_indices.push_back(icell_face);
Wall.cpp:            WGD->g[icell_cent] = 0.0;
Wall.cpp:  float dx = WGD->dx;
Wall.cpp:  float dy = WGD->dy;
Wall.cpp:  float dz = WGD->dz;
Wall.cpp:  int nx = WGD->nx;
Wall.cpp:  int ny = WGD->ny;
Wall.cpp:  int nz = WGD->nz;
Wall.cpp:  const float z0 = WGD->z0;
Wall.cpp:  std::vector<float> &u0 = WGD->u0;
Wall.cpp:  std::vector<float> &v0 = WGD->v0;
Wall.cpp:  std::vector<float> &w0 = WGD->w0;
Wall.cpp:  int wall_size = WGD->wall_right_indices.size() + WGD->wall_left_indices.size()
Wall.cpp:                  + WGD->wall_above_indices.size() + WGD->wall_below_indices.size()
Wall.cpp:                  + WGD->wall_front_indices.size() + WGD->wall_back_indices.size();
Wall.cpp:  for (size_t i = 0; i < WGD->wall_below_indices.size(); i++) {
Wall.cpp:      wind_dir = atan2(v0[WGD->wall_below_indices[i] + nx * ny], u0[WGD->wall_below_indices[i] + nx * ny]);
Wall.cpp:      vel_mag2 = sqrt(pow(u0[WGD->wall_below_indices[i] + nx * ny], 2.0) + pow(v0[WGD->wall_below_indices[i] + nx * ny], 2.0));
Wall.cpp:      vel_mag1 = vel_mag2 - (ustar_wall / WGD->vk) * log(dist2 / dist1);
Wall.cpp:      w0[WGD->wall_below_indices[i]] = 0;// normal component of velocity set to zero
Wall.cpp:      u0[WGD->wall_below_indices[i]] = vel_mag1 * cos(wind_dir);
Wall.cpp:      v0[WGD->wall_below_indices[i]] = vel_mag1 * sin(wind_dir);
Wall.cpp:      new_ustar = WGD->vk * vel_mag1 / log(dist1 / z0);
Wall.cpp:    index[i] = WGD->wall_below_indices[i];
Wall.cpp:  for (size_t i = 0; i < WGD->wall_above_indices.size(); i++) {
Wall.cpp:      wind_dir = atan2(v0[WGD->wall_above_indices[i] - nx * ny], u0[WGD->wall_above_indices[i] - nx * ny]);
Wall.cpp:      vel_mag2 = sqrt(pow(u0[WGD->wall_above_indices[i] - nx * ny], 2.0) + pow(v0[WGD->wall_above_indices[i] - nx * ny], 2.0));
Wall.cpp:      vel_mag1 = vel_mag2 - (ustar_wall / WGD->vk) * log(dist2 / dist1);
Wall.cpp:      w0[WGD->wall_above_indices[i]] = 0;// normal component of velocity set to zero
Wall.cpp:      u0[WGD->wall_above_indices[i]] = vel_mag1 * cos(wind_dir);
Wall.cpp:      v0[WGD->wall_above_indices[i]] = vel_mag1 * sin(wind_dir);
Wall.cpp:      new_ustar = WGD->vk * vel_mag1 / log(dist1 / z0);
Wall.cpp:    j = i + WGD->wall_below_indices.size();
Wall.cpp:    index[j] = WGD->wall_above_indices[i];
Wall.cpp:  for (size_t i = 0; i < WGD->wall_back_indices.size(); i++) {
Wall.cpp:      wind_dir = atan2(w0[WGD->wall_back_indices[i] + 1], v0[WGD->wall_back_indices[i] + 1]);
Wall.cpp:      vel_mag2 = sqrt(pow(v0[WGD->wall_back_indices[i] + 1], 2.0) + pow(w0[WGD->wall_back_indices[i] + 1], 2.0));
Wall.cpp:      vel_mag1 = vel_mag2 - (ustar_wall / WGD->vk) * log(dist2 / dist1);
Wall.cpp:      u0[WGD->wall_back_indices[i]] = 0;// normal component of velocity set to zero
Wall.cpp:      v0[WGD->wall_back_indices[i]] = vel_mag1 * cos(wind_dir);
Wall.cpp:      w0[WGD->wall_back_indices[i]] = vel_mag1 * sin(wind_dir);
Wall.cpp:      new_ustar = WGD->vk * vel_mag1 / log(dist1 / z0);
Wall.cpp:    j = i + WGD->wall_below_indices.size() + WGD->wall_above_indices.size();
Wall.cpp:    index[j] = WGD->wall_back_indices[i];
Wall.cpp:  for (size_t i = 0; i < WGD->wall_front_indices.size(); i++) {
Wall.cpp:      wind_dir = atan2(w0[WGD->wall_front_indices[i] - 1], v0[WGD->wall_front_indices[i] - 1]);
Wall.cpp:      vel_mag2 = sqrt(pow(v0[WGD->wall_front_indices[i] - 1], 2.0) + pow(w0[WGD->wall_front_indices[i] - 1], 2.0));
Wall.cpp:      vel_mag1 = vel_mag2 - (ustar_wall / WGD->vk) * log(dist2 / dist1);
Wall.cpp:      u0[WGD->wall_front_indices[i]] = 0;// normal component of velocity set to zero
Wall.cpp:      v0[WGD->wall_front_indices[i]] = vel_mag1 * cos(wind_dir);
Wall.cpp:      w0[WGD->wall_front_indices[i]] = vel_mag1 * sin(wind_dir);
Wall.cpp:      new_ustar = WGD->vk * vel_mag1 / log(dist1 / z0);
Wall.cpp:    j = i + WGD->wall_below_indices.size() + WGD->wall_above_indices.size() + WGD->wall_back_indices.size();
Wall.cpp:    index[j] = WGD->wall_front_indices[i];
Wall.cpp:  for (size_t i = 0; i < WGD->wall_right_indices.size(); i++) {
Wall.cpp:      wind_dir = atan2(w0[WGD->wall_right_indices[i] + nx], u0[WGD->wall_right_indices[i] + nx]);
Wall.cpp:      vel_mag2 = sqrt(pow(u0[WGD->wall_right_indices[i] + nx], 2.0) + pow(w0[WGD->wall_right_indices[i] + nx], 2.0));
Wall.cpp:      vel_mag1 = vel_mag2 - (ustar_wall / WGD->vk) * log(dist2 / dist1);
Wall.cpp:      v0[WGD->wall_right_indices[i]] = 0;// normal component of velocity set to zero
Wall.cpp:      u0[WGD->wall_right_indices[i]] = vel_mag1 * cos(wind_dir);
Wall.cpp:      w0[WGD->wall_right_indices[i]] = vel_mag1 * sin(wind_dir);
Wall.cpp:      new_ustar = WGD->vk * vel_mag1 / log(dist1 / z0);
Wall.cpp:    j = i + WGD->wall_below_indices.size() + WGD->wall_above_indices.size() + WGD->wall_back_indices.size() + WGD->wall_front_indices.size();
Wall.cpp:    index[j] = WGD->wall_right_indices[i];
Wall.cpp:  for (size_t i = 0; i < WGD->wall_left_indices.size(); i++) {
Wall.cpp:      wind_dir = atan2(w0[WGD->wall_left_indices[i] - nx], u0[WGD->wall_left_indices[i] - nx]);
Wall.cpp:      vel_mag2 = sqrt(pow(u0[WGD->wall_left_indices[i] - nx], 2.0) + pow(w0[WGD->wall_left_indices[i] - nx], 2.0));
Wall.cpp:      vel_mag1 = vel_mag2 - (ustar_wall / WGD->vk) * log(dist2 / dist1);
Wall.cpp:      v0[WGD->wall_left_indices[i]] = 0;// normal component of velocity set to zero
Wall.cpp:      u0[WGD->wall_left_indices[i]] = vel_mag1 * cos(wind_dir);
Wall.cpp:      w0[WGD->wall_left_indices[i]] = vel_mag1 * sin(wind_dir);
Wall.cpp:      new_ustar = WGD->vk * vel_mag1 / log(dist1 / z0);
Wall.cpp:    j = i + WGD->wall_below_indices.size() + WGD->wall_above_indices.size() + WGD->wall_back_indices.size() + WGD->wall_front_indices.size() + WGD->wall_right_indices.size();
Wall.cpp:    index[j] = WGD->wall_left_indices[i];
Wall.cpp:  for (auto k = 0; k < WGD->nz - 1; k++) {
Wall.cpp:    for (auto j = 1; j < WGD->ny - 1; j++) {
Wall.cpp:      for (auto i = 1; i < WGD->nx - 1; i++) {
Wall.cpp:        int icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Wall.cpp:        int icell_face = i + j * WGD->nx + k * WGD->nx * WGD->ny;
Wall.cpp:        if (WGD->icellflag[icell_cent] == 0 || WGD->icellflag[icell_cent] == 2) {
Wall.cpp:          WGD->u0[icell_face] = 0.0;// Set velocity inside the building to zero
Wall.cpp:          WGD->u0[icell_face + 1] = 0.0;
Wall.cpp:          WGD->v0[icell_face] = 0.0;// Set velocity inside the building to zero
Wall.cpp:          WGD->v0[icell_face + WGD->nx] = 0.0;
Wall.cpp:          WGD->w0[icell_face] = 0.0;// Set velocity inside the building to zero
Wall.cpp:          WGD->w0[icell_face + WGD->nx * WGD->ny] = 0.0;
Wall.cpp:        if (WGD->icellflag[icell_cent] == 7 || WGD->icellflag[icell_cent] == 8) {
Wall.cpp:          WGD->u0[icell_face] = pow(WGD->dx, 2.0) * WGD->f[icell_cent] * WGD->u0[icell_face];
Wall.cpp:          WGD->v0[icell_face] = pow(WGD->dy, 2.0) * WGD->h[icell_cent] * WGD->v0[icell_face];
Wall.cpp:          WGD->w0[icell_face] = (WGD->dz_array[k] * 0.5 * (WGD->dz_array[k] + WGD->dz_array[k - 1])) * WGD->n[icell_cent] * WGD->w0[icell_face];
Wall.cpp:          if (WGD->icellflag[icell_cent + 1] != 7 && WGD->icellflag[icell_cent + 1] != 8) {
Wall.cpp:            WGD->u0[icell_face + 1] = pow(WGD->dx, 2.0) * WGD->e[icell_cent] * WGD->u0[icell_face + 1];
Wall.cpp:          if (WGD->icellflag[icell_cent + (WGD->nx - 1)] != 7 && WGD->icellflag[icell_cent + (WGD->nx - 1)] != 8) {
Wall.cpp:            WGD->v0[icell_face + WGD->nx] = pow(WGD->dy, 2.0) * WGD->g[icell_cent] * WGD->v0[icell_face + WGD->nx];
Wall.cpp:          if (WGD->icellflag[icell_cent + (WGD->nx - 1) * (WGD->ny - 1)] != 7 && WGD->icellflag[icell_cent - (WGD->nx - 1) * (WGD->ny - 1)] != 8) {
Wall.cpp:            WGD->w0[icell_face + (WGD->nx * WGD->ny)] = (WGD->dz_array[k] * 0.5 * (WGD->dz_array[k] + WGD->dz_array[k + 1])) * WGD->m[icell_cent] * WGD->w0[icell_face + (WGD->nx * WGD->ny)];
Wall.cpp:  for (auto k = 1; k < WGD->nz - 2; k++) {
Wall.cpp:    for (auto j = 0; j < WGD->ny - 1; j++) {
Wall.cpp:      for (auto i = 0; i < WGD->nx - 1; i++) {
Wall.cpp:        int icell_cent = i + j * (WGD->nx - 1) + k * (WGD->nx - 1) * (WGD->ny - 1);
Wall.cpp:        WGD->e[icell_cent] = WGD->e[icell_cent] / (WGD->dx * WGD->dx);
Wall.cpp:        WGD->f[icell_cent] = WGD->f[icell_cent] / (WGD->dx * WGD->dx);
Wall.cpp:        WGD->g[icell_cent] = WGD->g[icell_cent] / (WGD->dy * WGD->dy);
Wall.cpp:        WGD->h[icell_cent] = WGD->h[icell_cent] / (WGD->dy * WGD->dy);
Wall.cpp:        WGD->m[icell_cent] = WGD->m[icell_cent] / (WGD->dz_array[k] * 0.5 * (WGD->dz_array[k] + WGD->dz_array[k + 1]));
Wall.cpp:        WGD->n[icell_cent] = WGD->n[icell_cent] / (WGD->dz_array[k] * 0.5 * (WGD->dz_array[k] + WGD->dz_array[k - 1]));
Wall.h: * This file is part of QES-Winds
Wall.h: * GPL-3.0 License
Wall.h: * QES-Winds is free software: you can redistribute it and/or modify
Wall.h: * QES-Winds is distributed in the hope that it will be useful,
Wall.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
Wall.h:   * function for stair-step method and sets related coefficients to
WINDSGeneralData.cpp: * This file is part of QES-Winds
WINDSGeneralData.cpp: * GPL-3.0 License
WINDSGeneralData.cpp: * QES-Winds is free software: you can redistribute it and/or modify
WINDSGeneralData.cpp: * QES-Winds is distributed in the hope that it will be useful,
WINDSGeneralData.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
WINDSGeneralData.cpp:  if (WID->simParams->upwindCavityFlag == 1) {
WINDSGeneralData.cpp:  if (WID->simParams->wakeFlag > 1) {
WINDSGeneralData.cpp:  // converting the domain rotation to radians from degrees -- input
WINDSGeneralData.cpp:  theta = (WID->simParams->domainRotation * pi / 180.0);
WINDSGeneralData.cpp:  // Pull Domain Size information from the WINDSInputData structure --
WINDSGeneralData.cpp:  domainInfo = *(WID->simParams->domain);
WINDSGeneralData.cpp:  gridInfo = *(WID->simParams->grid);
WINDSGeneralData.cpp:  dx = gridInfo[0];// Grid resolution in x-direction
WINDSGeneralData.cpp:  dy = gridInfo[1];// Grid resolution in y-direction
WINDSGeneralData.cpp:  dz = gridInfo[2];// Grid resolution in z-direction
WINDSGeneralData.cpp:  numcell_cout = (nx - 1) * (ny - 1) * (nz - 2);// Total number of cell-centered values in domain
WINDSGeneralData.cpp:  numcell_cout_2d = (nx - 1) * (ny - 1);// Total number of horizontal cell-centered values in domain
WINDSGeneralData.cpp:  numcell_cent = (nx - 1) * (ny - 1) * (nz - 1);// Total number of cell-centered values in domain
WINDSGeneralData.cpp:  numcell_face = nx * ny * nz;// Total number of face-centered values in domain
WINDSGeneralData.cpp:  if (WID->simParams->wrfInputData) {
WINDSGeneralData.cpp:    WRFInput *wrf_ptr = WID->simParams->wrfInputData;
WINDSGeneralData.cpp:    std::cout << "Size of WRF station/sensor profile data: " << wrf_ptr->statData.size() << std::endl;
WINDSGeneralData.cpp:    WID->metParams->sensors.resize(wrf_ptr->statData.size());
WINDSGeneralData.cpp:    for (auto i = 0; i < wrf_ptr->statData.size(); i++) {
WINDSGeneralData.cpp:                << wrf_ptr->statData[i].xCoord << ", "
WINDSGeneralData.cpp:                << wrf_ptr->statData[i].yCoord << ")" << std::endl;
WINDSGeneralData.cpp:      if (!WID->metParams->sensors[i])
WINDSGeneralData.cpp:        WID->metParams->sensors[i] = new Sensor();
WINDSGeneralData.cpp:      WID->metParams->sensors[i]->site_xcoord = wrf_ptr->statData[i].xCoord;
WINDSGeneralData.cpp:      WID->metParams->sensors[i]->site_ycoord = wrf_ptr->statData[i].yCoord;
WINDSGeneralData.cpp:      WID->metParams->sensors[i]->TS.resize(1);
WINDSGeneralData.cpp:      if (!WID->metParams->sensors[i]->TS[0])
WINDSGeneralData.cpp:        WID->metParams->sensors[i]->TS[0] = new TimeSeries;
WINDSGeneralData.cpp:      // WRF profile data -- sensor blayer flag is 4
WINDSGeneralData.cpp:      WID->metParams->sensors[i]->TS[0]->site_blayer_flag = 4;
WINDSGeneralData.cpp:      WID->metParams->sensors[i]->TS[0]->site_z0 = wrf_ptr->statData[i].z0;
WINDSGeneralData.cpp:      // 1 time series for now - how do we deal with this for
WINDSGeneralData.cpp:        int profDataSz = wrf_ptr->statData[i].profiles[t].size();
WINDSGeneralData.cpp:        WID->metParams->sensors[i]->TS[0]->site_wind_dir.resize(profDataSz);
WINDSGeneralData.cpp:        WID->metParams->sensors[i]->TS[0]->site_z_ref.resize(profDataSz);
WINDSGeneralData.cpp:        WID->metParams->sensors[i]->TS[0]->site_U_ref.resize(profDataSz);
WINDSGeneralData.cpp:        for (size_t p = 0; p < wrf_ptr->statData[i].profiles[t].size(); p++) {
WINDSGeneralData.cpp:          std::cout << "\t" << wrf_ptr->statData[i].profiles[t][p].zCoord
WINDSGeneralData.cpp:                    << ", " << wrf_ptr->statData[i].profiles[t][p].ws
WINDSGeneralData.cpp:                    << ", " << wrf_ptr->statData[i].profiles[t][p].wd << std::endl;
WINDSGeneralData.cpp:          WID->metParams->sensors[i]->TS[0]->site_z_ref[p] = wrf_ptr->statData[i].profiles[t][p].zCoord;
WINDSGeneralData.cpp:          WID->metParams->sensors[i]->TS[0]->site_U_ref[p] = wrf_ptr->statData[i].profiles[t][p].ws;
WINDSGeneralData.cpp:          WID->metParams->sensors[i]->TS[0]->site_wind_dir[p] = wrf_ptr->statData[i].profiles[t][p].wd;
WINDSGeneralData.cpp:     - does not support halo for UTM coord (site coord == 2)
WINDSGeneralData.cpp:     - does not support halo for lon/lat coord (site coord == 3)
WINDSGeneralData.cpp:    if (WID->metParams->sensorName.size() > 0) {
WINDSGeneralData.cpp:      for (auto i = 0; i < WID->metParams->sensorName.size(); i++) {
WINDSGeneralData.cpp:        WID->metParams->sensors.push_back(new Sensor(WID->metParams->sensorName[i]));// Create new sensor object
WINDSGeneralData.cpp:    if (WID->simParams->totalTimeIncrements > 0) {
WINDSGeneralData.cpp:      for (auto i = 0; i < WID->metParams->sensors[0]->TS.size(); i++) {
WINDSGeneralData.cpp:        sensortime.push_back(WID->metParams->sensors[0]->TS[i]->timeEpoch);
WINDSGeneralData.cpp:      for (auto i = 0; i < WID->metParams->sensors.size(); i++) {
WINDSGeneralData.cpp:        for (auto j = 0; j < WID->metParams->sensors[i]->TS.size(); j++) {
WINDSGeneralData.cpp:            if (WID->metParams->sensors[i]->TS[j]->timeEpoch != sensortime[k]) {
WINDSGeneralData.cpp:            sensortime.push_back(WID->metParams->sensors[i]->TS[j]->timeEpoch);
WINDSGeneralData.cpp:            sensortime_id.push_back(sensortime.size() - 1);
WINDSGeneralData.cpp:    if (WID->simParams->totalTimeIncrements == 0) {
WINDSGeneralData.cpp:      totalTimeIncrements = WID->simParams->totalTimeIncrements;
WINDSGeneralData.cpp:    for (size_t i = 0; i < WID->metParams->sensors.size(); i++) {
WINDSGeneralData.cpp:      if (WID->metParams->sensors[i]->site_coord_flag == 1) {
WINDSGeneralData.cpp:        WID->metParams->sensors[i]->site_xcoord += WID->simParams->halo_x;
WINDSGeneralData.cpp:        WID->metParams->sensors[i]->site_ycoord += WID->simParams->halo_y;
WINDSGeneralData.cpp:  if (WID->metParams->z0_domain_flag == 0)// Uniform z0 for the whole domain
WINDSGeneralData.cpp:        z0_domain_u[id] = WID->metParams->sensors[0]->TS[0]->site_z0;
WINDSGeneralData.cpp:        z0_domain_v[id] = WID->metParams->sensors[0]->TS[0]->site_z0;
WINDSGeneralData.cpp:  if (WID->buildings)
WINDSGeneralData.cpp:    z0 = WID->buildings->wallRoughness;
WINDSGeneralData.cpp:  dz_array.resize(nz - 1, 0.0);
WINDSGeneralData.cpp:  z.resize(nz - 1);
WINDSGeneralData.cpp:  z_face.resize(nz - 1);
WINDSGeneralData.cpp:  if (WID->simParams->verticalStretching == 0) {// Uniform vertical grid
WINDSGeneralData.cpp:  } else if (WID->simParams->verticalStretching == 1) {// Stretched vertical grid
WINDSGeneralData.cpp:      dz_array[k] = WID->simParams->dz_value[k - 1];// Read in custom dz values and set them to dz_array
WINDSGeneralData.cpp:  z[0] = -0.5 * dz_array[0];
WINDSGeneralData.cpp:    z_face[k] = z_face[k - 1] + dz_array[k];// Location of face centers in z-dir
WINDSGeneralData.cpp:    z[k] = 0.5 * (z_face[k - 1] + z_face[k]);// Location of cell centers in z-dir
WINDSGeneralData.cpp:  // horizontal grid (x-direction)
WINDSGeneralData.cpp:  x.resize(nx - 1);
WINDSGeneralData.cpp:  for (auto i = 0; i < nx - 1; i++) {
WINDSGeneralData.cpp:    x[i] = (i + 0.5) * dx;// Location of face centers in x-dir
WINDSGeneralData.cpp:  // horizontal grid (y-direction)
WINDSGeneralData.cpp:  y.resize(ny - 1);
WINDSGeneralData.cpp:  for (auto j = 0; j < ny - 1; j++) {
WINDSGeneralData.cpp:    y[j] = (j + 0.5) * dy;// Location of face centers in y-dir
WINDSGeneralData.cpp:  // Resize the canopy-related vectors
WINDSGeneralData.cpp:  // canopy_top.resize( (nx-1)*(ny-1), 0.0 );
WINDSGeneralData.cpp:  // canopy_top_index.resize( (nx-1)*(ny-1), 0 );
WINDSGeneralData.cpp:  // canopy_z0.resize( (nx-1)*(ny-1), 0.0 );
WINDSGeneralData.cpp:  // canopy_ustar.resize( (nx-1)*(ny-1), 0.0 );
WINDSGeneralData.cpp:  // canopy_d.resize( (nx-1)*(ny-1), 0.0 );
WINDSGeneralData.cpp:  ibuilding_flag.resize(numcell_cent, -1);
WINDSGeneralData.cpp:  terrain_id.resize((nx - 1) * (ny - 1), 1);
WINDSGeneralData.cpp:  for (int j = 0; j < ny - 1; j++) {
WINDSGeneralData.cpp:    for (int i = 0; i < nx - 1; i++) {
WINDSGeneralData.cpp:      int icell_cent = i + j * (nx - 1);
WINDSGeneralData.cpp:  int halo_index_x = (WID->simParams->halo_x / dx);
WINDSGeneralData.cpp:  // WID->simParams->halo_x = halo_index_x*dx;
WINDSGeneralData.cpp:  int halo_index_y = (WID->simParams->halo_y / dy);
WINDSGeneralData.cpp:  // WID->simParams->halo_y = halo_index_y*dy;
WINDSGeneralData.cpp:  if (WID->simParams->DTE_heightField) {
WINDSGeneralData.cpp:    for (int i = 0; i < nx - 2 * halo_index_x - 1; i++) {
WINDSGeneralData.cpp:      for (int j = 0; j < ny - 2 * halo_index_y - 1; j++) {
WINDSGeneralData.cpp:        idx = ii + jj * (nx - 1);
WINDSGeneralData.cpp:        terrain[idx] = WID->simParams->DTE_mesh->getHeight(i * dx + dx * 0.5f, j * dy + dy * 0.5f);
WINDSGeneralData.cpp:        for (size_t k = 0; k < z.size() - 1; k++) {
WINDSGeneralData.cpp:    for (int i = halo_index_x; i < nx - halo_index_x - 1; i++) {
WINDSGeneralData.cpp:      for (int j = ny - halo_index_y - 1; j < ny; j++) {
WINDSGeneralData.cpp:        id = i + (ny - halo_index_y - 1) * nx;
WINDSGeneralData.cpp:    for (int j = halo_index_y; j < ny - halo_index_y - 1; j++) {
WINDSGeneralData.cpp:      for (int i = nx - halo_index_x - 1; i < nx; i++) {
WINDSGeneralData.cpp:        id = (nx - halo_index_x - 1) + j * nx;
WINDSGeneralData.cpp:      for (int j = ny - halo_index_y - 1; j < ny; j++) {
WINDSGeneralData.cpp:        id = halo_index_x + (ny - halo_index_y - 1) * nx;
WINDSGeneralData.cpp:    for (int i = nx - halo_index_x - 1; i < nx - 1; i++) {
WINDSGeneralData.cpp:        id = (nx - halo_index_x - 1) + halo_index_y * nx;
WINDSGeneralData.cpp:      for (int j = ny - halo_index_y - 1; j < ny - 1; j++) {
WINDSGeneralData.cpp:        id = (nx - halo_index_x - 1) + (ny - halo_index_y - 2) * nx;
WINDSGeneralData.cpp:    for (int i = 0; i < nx - 2 * halo_index_x - 1; i++) {
WINDSGeneralData.cpp:      for (int j = 0; j < ny - 2 * halo_index_y - 1; j++) {
WINDSGeneralData.cpp:        idx = ii + jj * (nx - 1);
WINDSGeneralData.cpp:        for (size_t k = 0; k < z.size() - 1; k++) {
WINDSGeneralData.cpp:    for (int i = halo_index_x; i < nx - halo_index_x - 1; i++) {
WINDSGeneralData.cpp:        id = i + halo_index_y * (nx - 1);
WINDSGeneralData.cpp:        icell_cent = i + j * (nx - 1);
WINDSGeneralData.cpp:      for (int j = ny - halo_index_y - 1; j < ny - 1; j++) {
WINDSGeneralData.cpp:        id = i + (ny - halo_index_y - 2) * (nx - 1);
WINDSGeneralData.cpp:        icell_cent = i + j * (nx - 1);
WINDSGeneralData.cpp:    for (int j = halo_index_y; j < ny - halo_index_y - 1; j++) {
WINDSGeneralData.cpp:        id = halo_index_x + j * (nx - 1);
WINDSGeneralData.cpp:        icell_cent = i + j * (nx - 1);
WINDSGeneralData.cpp:      for (int i = nx - halo_index_x - 1; i < nx - 1; i++) {
WINDSGeneralData.cpp:        id = (nx - halo_index_x - 2) + j * (nx - 1);
WINDSGeneralData.cpp:        icell_cent = i + j * (nx - 1);
WINDSGeneralData.cpp:        id = halo_index_x + halo_index_y * (nx - 1);
WINDSGeneralData.cpp:        icell_cent = i + j * (nx - 1);
WINDSGeneralData.cpp:      for (int j = ny - halo_index_y - 1; j < ny - 1; j++) {
WINDSGeneralData.cpp:        id = halo_index_x + (ny - halo_index_y - 2) * (nx - 1);
WINDSGeneralData.cpp:        icell_cent = i + j * (nx - 1);
WINDSGeneralData.cpp:    for (int i = nx - halo_index_x - 1; i < nx - 1; i++) {
WINDSGeneralData.cpp:        id = (nx - halo_index_x - 2) + halo_index_y * (nx - 1);
WINDSGeneralData.cpp:        icell_cent = i + j * (nx - 1);
WINDSGeneralData.cpp:      for (int j = ny - halo_index_y - 1; j < ny - 1; j++) {
WINDSGeneralData.cpp:        id = (nx - halo_index_x - 2) + (ny - halo_index_y - 2) * (nx - 1);
WINDSGeneralData.cpp:        icell_cent = i + j * (nx - 1);
WINDSGeneralData.cpp:  assert(WID->metParams->sensors.size() > 0);// extra
WINDSGeneralData.cpp:  std::cout << "Sensors have been loaded (total sensors = " << WID->metParams->sensors.size() << ")." << std::endl;
WINDSGeneralData.cpp:  if (WID->simParams->DTE_heightField) {
WINDSGeneralData.cpp:    if (WID->simParams->meshTypeFlag == 0 && WID->simParams->readCoefficientsFlag == 0) {
WINDSGeneralData.cpp:      for (int i = 0; i < nx - 1; i++) {
WINDSGeneralData.cpp:        for (int j = 0; j < ny - 1; j++) {
WINDSGeneralData.cpp:          int idx = i + j * (nx - 1);
WINDSGeneralData.cpp:          for (size_t k = 0; k < z.size() - 1; k++) {
WINDSGeneralData.cpp:            // Stair-step (original QUIC)    //
WINDSGeneralData.cpp:            icell_cent = i + j * (nx - 1) + (k + 1) * (nx - 1) * (ny - 1);
WINDSGeneralData.cpp:      std::chrono::duration<float> elapsed_stair = finish_stair - start_stair;
WINDSGeneralData.cpp:      std::cout << "Elapsed time for terrain with stair-step: " << elapsed_stair.count() << " s\n";
WINDSGeneralData.cpp:    if (WID->simParams->meshTypeFlag == 1 && WID->simParams->readCoefficientsFlag == 0) {
WINDSGeneralData.cpp:      //        Cut-cell method       //
WINDSGeneralData.cpp:      // Calling calculateCoefficient function to calculate area fraction coefficients for cut-cells
WINDSGeneralData.cpp:      WID->simParams->DTE_heightField->setCells(cells, this, WID);
WINDSGeneralData.cpp:      std::chrono::duration<float> elapsed_cut = finish_cut - start_cut;
WINDSGeneralData.cpp:      std::cout << "Elapsed time for terrain with cut-cell: " << elapsed_cut.count() << " s\n";
WINDSGeneralData.cpp:  // onto a single vector of Building* -- this vector is called
WINDSGeneralData.cpp:  // too -- could be RectBuilding, PolyBuilding, whatever is derived
WINDSGeneralData.cpp:  if (WID->buildings) {
WINDSGeneralData.cpp:    if (WID->buildings->SHPData) {
WINDSGeneralData.cpp:      WID->buildings->SHPData->getLocalDomain(shpDomainSize);
WINDSGeneralData.cpp:      WID->buildings->SHPData->getMinExtent(minExtent);
WINDSGeneralData.cpp:      if (WID->simParams->UTMx != 0.0 && WID->simParams->UTMy != 0.0) {
WINDSGeneralData.cpp:        minExtent[0] -= (minExtent[0] - WID->simParams->UTMx);
WINDSGeneralData.cpp:        minExtent[1] -= (minExtent[1] - WID->simParams->UTMy);
WINDSGeneralData.cpp:      for (auto pIdx = 0u; pIdx < WID->buildings->SHPData->m_polygons.size(); pIdx++) {
WINDSGeneralData.cpp:        for (auto lIdx = 0u; lIdx < WID->buildings->SHPData->m_polygons[pIdx].size(); lIdx++) {
WINDSGeneralData.cpp:          WID->buildings->SHPData->m_polygons[pIdx][lIdx].x_poly -= minExtent[0];
WINDSGeneralData.cpp:          WID->buildings->SHPData->m_polygons[pIdx][lIdx].y_poly -= minExtent[1];
WINDSGeneralData.cpp:        if (WID->simParams->DTE_heightField && WID->simParams->DTE_mesh) {
WINDSGeneralData.cpp:          min_height = WID->simParams->DTE_mesh->getHeight(WID->buildings->SHPData->m_polygons[pIdx][0].x_poly,
WINDSGeneralData.cpp:                                                           WID->buildings->SHPData->m_polygons[pIdx][0].y_poly);
WINDSGeneralData.cpp:          for (auto lIdx = 1u; lIdx < WID->buildings->SHPData->m_polygons[pIdx].size(); lIdx++) {
WINDSGeneralData.cpp:            corner_height = WID->simParams->DTE_mesh->getHeight(WID->buildings->SHPData->m_polygons[pIdx][lIdx].x_poly,
WINDSGeneralData.cpp:                                                                WID->buildings->SHPData->m_polygons[pIdx][lIdx].y_poly);
WINDSGeneralData.cpp:        for (auto lIdx = 0u; lIdx < WID->buildings->SHPData->m_polygons[pIdx].size(); lIdx++) {
WINDSGeneralData.cpp:          WID->buildings->SHPData->m_polygons[pIdx][lIdx].x_poly += WID->simParams->halo_x;
WINDSGeneralData.cpp:          WID->buildings->SHPData->m_polygons[pIdx][lIdx].y_poly += WID->simParams->halo_y;
WINDSGeneralData.cpp:        allBuildingsV.push_back(new PolyBuilding(WID->buildings->SHPData->m_polygons[pIdx],
WINDSGeneralData.cpp:                                                 WID->buildings->SHPData->m_features[WID->buildings->shpHeightField][pIdx] * WID->buildings->heightFactor,
WINDSGeneralData.cpp:        allBuildingsV[bId]->setPolyBuilding(this);
WINDSGeneralData.cpp:        allBuildingsV[bId]->setCellFlags(WID, this, bId);
WINDSGeneralData.cpp:        effective_height.push_back(allBuildingsV[bId]->height_eff);
WINDSGeneralData.cpp:    for (size_t i = 0; i < WID->buildings->buildings.size(); i++) {
WINDSGeneralData.cpp:      allBuildingsV.push_back(WID->buildings->buildings[i]);
WINDSGeneralData.cpp:      int j = allBuildingsV.size() - 1;
WINDSGeneralData.cpp:      for (auto pIdx = 0u; pIdx < allBuildingsV[j]->polygonVertices.size(); pIdx++) {
WINDSGeneralData.cpp:        allBuildingsV[j]->polygonVertices[pIdx].x_poly += WID->simParams->halo_x;
WINDSGeneralData.cpp:        allBuildingsV[j]->polygonVertices[pIdx].y_poly += WID->simParams->halo_y;
WINDSGeneralData.cpp:      if (WID->simParams->DTE_heightField && WID->simParams->DTE_mesh) {
WINDSGeneralData.cpp:        min_height = WID->simParams->DTE_mesh->getHeight(allBuildingsV[j]->polygonVertices[0].x_poly,
WINDSGeneralData.cpp:                                                         allBuildingsV[j]->polygonVertices[0].y_poly);
WINDSGeneralData.cpp:        for (size_t lIdx = 1; lIdx < allBuildingsV[j]->polygonVertices.size(); lIdx++) {
WINDSGeneralData.cpp:          corner_height = WID->simParams->DTE_mesh->getHeight(allBuildingsV[j]->polygonVertices[lIdx].x_poly,
WINDSGeneralData.cpp:                                                              allBuildingsV[j]->polygonVertices[lIdx].y_poly);
WINDSGeneralData.cpp:        allBuildingsV[j]->base_height = min_height;
WINDSGeneralData.cpp:        // allBuildingsV[j]->base_height = 0.0;
WINDSGeneralData.cpp:      allBuildingsV[j]->ID = j;
WINDSGeneralData.cpp:      allBuildingsV[j]->setPolyBuilding(this);
WINDSGeneralData.cpp:      allBuildingsV[j]->setCellFlags(WID, this, j);
WINDSGeneralData.cpp:      effective_height.push_back(allBuildingsV[j]->height_eff);
WINDSGeneralData.cpp:    std::chrono::duration<float> elapsed_cut = buildingsetup_finish - buildingsetup_start;
WINDSGeneralData.cpp:  if (WID->canopies) {
WINDSGeneralData.cpp:    canopy->setCanopyElements(WID, this);
WINDSGeneralData.cpp:  wall->defineWalls(this);
WINDSGeneralData.cpp:  wall->solverCoefficients(this);
WINDSGeneralData.cpp:  std::chrono::duration<float> elapsed_wall = wallsetup_finish - wallsetup_start;
WINDSGeneralData.cpp:  if (WID->simParams->readCoefficientsFlag == 1) {
WINDSGeneralData.cpp:    NetCDFInput *NCDFInput = new NetCDFInput(WID->simParams->coeffFile);
WINDSGeneralData.cpp:    NCDFInput->getDimensionSize("x", ncnx);
WINDSGeneralData.cpp:    NCDFInput->getDimensionSize("y", ncny);
WINDSGeneralData.cpp:    NCDFInput->getDimensionSize("z", ncnz);
WINDSGeneralData.cpp:    NCDFInput->getDimensionSize("t", ncnt);
WINDSGeneralData.cpp:              static_cast<unsigned long>(ncnz - 1),
WINDSGeneralData.cpp:              static_cast<unsigned long>(ncny - 1),
WINDSGeneralData.cpp:              static_cast<unsigned long>(ncnx - 1) };
WINDSGeneralData.cpp:    NCDFInput->getVariableData("icellflag", start, count, icellflag);
WINDSGeneralData.cpp:    NCDFInput->getVariableData("e", start, count, e);
WINDSGeneralData.cpp:    NCDFInput->getVariableData("f", start, count, f);
WINDSGeneralData.cpp:    NCDFInput->getVariableData("g", start, count, g);
WINDSGeneralData.cpp:    NCDFInput->getVariableData("h", start, count, h);
WINDSGeneralData.cpp:    NCDFInput->getVariableData("m", start, count, m);
WINDSGeneralData.cpp:    NCDFInput->getVariableData("n", start, count, n);
WINDSGeneralData.cpp:  std::cout << "[WINDS Data] \t Loading QES-winds fields " << std::endl;
WINDSGeneralData.cpp:  // nx,ny - face centered value (consistant with QES-Winds)
WINDSGeneralData.cpp:  input->getDimensionSize("x_face", nx);
WINDSGeneralData.cpp:  input->getDimensionSize("y_face", ny);
WINDSGeneralData.cpp:  // nz - face centered value + bottom ghost (consistant with QES-Winds)
WINDSGeneralData.cpp:  input->getDimensionSize("z_face", nz);
WINDSGeneralData.cpp:  // nt - number of time instance in data
WINDSGeneralData.cpp:  input->getDimensionSize("t", nt);
WINDSGeneralData.cpp:  numcell_cout = (nx - 1) * (ny - 1) * (nz - 2); /**< Total number of cell-centered values in domain */
WINDSGeneralData.cpp:  numcell_cout_2d = (nx - 1) * (ny - 1); /**< Total number of horizontal cell-centered values in domain */
WINDSGeneralData.cpp:  numcell_cent = (nx - 1) * (ny - 1) * (nz - 1); /**< Total number of cell-centered values in domain */
WINDSGeneralData.cpp:  numcell_face = nx * ny * nz; /**< Total number of face-centered values in domain */
WINDSGeneralData.cpp:  x.resize(nx - 1);
WINDSGeneralData.cpp:  y.resize(ny - 1);
WINDSGeneralData.cpp:  z.resize(nz - 1);
WINDSGeneralData.cpp:  z_face.resize(nz - 1);
WINDSGeneralData.cpp:  dz_array.resize(nz - 1, 0.0);
WINDSGeneralData.cpp:  input->getVariableData("x", x);
WINDSGeneralData.cpp:  dx = x[1] - x[0]; /**< Grid resolution in x-direction */
WINDSGeneralData.cpp:  input->getVariableData("y", y);
WINDSGeneralData.cpp:  dy = y[1] - y[0]; /**< Grid resolution in x-direction */
WINDSGeneralData.cpp:  input->getVariableData("z", z);
WINDSGeneralData.cpp:  input->getVariable("dz_array", NcVar_dz);
WINDSGeneralData.cpp:    input->getVariableData("dz_array", dz_array);
WINDSGeneralData.cpp:    dz = z[1] - z[0];
WINDSGeneralData.cpp:  input->getVariable("z_face", NcVar_zface);
WINDSGeneralData.cpp:    input->getVariableData("z_face", z_face);
WINDSGeneralData.cpp:      z_face[k] = z_face[k - 1] + dz_array[k]; /**< Location of face centers in z-dir */
WINDSGeneralData.cpp:  input->getVariableData("t", t);
WINDSGeneralData.cpp:  input->getVariable("times", NcVar_times);
WINDSGeneralData.cpp:      // ptime test= from_iso_extended_string(WID->metParams->sensors[i]->TS[t]->timeStamp);
WINDSGeneralData.cpp:      timestamp.push_back(bt::from_iso_extended_string("2020-01-01T00:00"));
WINDSGeneralData.cpp:  count_2d = { static_cast<unsigned long>(ny - 1),
WINDSGeneralData.cpp:               static_cast<unsigned long>(nx - 1) };
WINDSGeneralData.cpp:  // terrain (cell-center)
WINDSGeneralData.cpp:  terrain.resize((ny - 1) * (nx - 1), 0.0);
WINDSGeneralData.cpp:  input->getVariable("terrain", NcVar_terrain);
WINDSGeneralData.cpp:  if (!NcVar_terrain.isNull()) {// => terrain data in QES-Winds file
WINDSGeneralData.cpp:    input->getVariableData("terrain", start, count_2d, terrain);
WINDSGeneralData.cpp:    std::cout << "[WINDS Data] \t no terrain data found -> assumed flat" << std::endl;
WINDSGeneralData.cpp:  icellflag.resize(numcell_cent, -1);
WINDSGeneralData.cpp:  ibuilding_flag.resize(numcell_cent, -1);
WINDSGeneralData.cpp:               static_cast<unsigned long>(nz - 1),
WINDSGeneralData.cpp:               static_cast<unsigned long>(ny - 1),
WINDSGeneralData.cpp:               static_cast<unsigned long>(nx - 1) };
WINDSGeneralData.cpp:  // cell-center variables
WINDSGeneralData.cpp:  input->getVariableData("icellflag", start, count_cc, icellflag);
WINDSGeneralData.cpp:  input->getVariable("e", NcVar_SORcoeff);
WINDSGeneralData.cpp:    input->getVariableData("e", start, count_cc, e);
WINDSGeneralData.cpp:    input->getVariableData("f", start, count_cc, f);
WINDSGeneralData.cpp:    input->getVariableData("g", start, count_cc, g);
WINDSGeneralData.cpp:    input->getVariableData("h", start, count_cc, h);
WINDSGeneralData.cpp:    input->getVariableData("m", start, count_cc, m);
WINDSGeneralData.cpp:    input->getVariableData("n", start, count_cc, n);
WINDSGeneralData.cpp:    std::cout << "[WINDS Data] \t no SORcoeff data found -> assumed e,f,g,h,m,n=1" << std::endl;
WINDSGeneralData.cpp:  // face-center variables
WINDSGeneralData.cpp:  input->getVariableData("u", start, count_fc, u);
WINDSGeneralData.cpp:  input->getVariableData("v", start, count_fc, v);
WINDSGeneralData.cpp:  input->getVariableData("w", start, count_fc, w);
WINDSGeneralData.cpp:  wall->defineWalls(this);
WINDSGeneralData.cpp:  WID->metParams->sensors[0]->inputWindProfile(WID, this, timeIndex, solveType);
WINDSGeneralData.cpp:      int icell_face = i + j * nx + (nz - 2) * nx * ny;
WINDSGeneralData.cpp:    canopy->applyCanopyVegetation(this);
WINDSGeneralData.cpp:  if (WID->simParams->upwindCavityFlag > 0) {
WINDSGeneralData.cpp:      allBuildingsV[building_id[i]]->upwindCavity(WID, this);
WINDSGeneralData.cpp:  //   Far-Wake and Cavity Parameterizations     ///
WINDSGeneralData.cpp:  if (WID->simParams->wakeFlag > 0) {
WINDSGeneralData.cpp:      allBuildingsV[building_id[i]]->polygonWake(WID, this, building_id[i]);
WINDSGeneralData.cpp:  if (WID->simParams->streetCanyonFlag == 1) {
WINDSGeneralData.cpp:      allBuildingsV[building_id[i]]->streetCanyon(this);
WINDSGeneralData.cpp:  } else if (WID->simParams->streetCanyonFlag == 2) {
WINDSGeneralData.cpp:      allBuildingsV[building_id[i]]->streetCanyonModified(this);
WINDSGeneralData.cpp:  if (WID->simParams->sidewallFlag > 0) {
WINDSGeneralData.cpp:      allBuildingsV[building_id[i]]->sideWall(WID, this);
WINDSGeneralData.cpp:  if (WID->simParams->rooftopFlag > 0) {
WINDSGeneralData.cpp:      allBuildingsV[building_id[i]]->rooftop(WID, this);
WINDSGeneralData.cpp:    canopy->applyCanopyWake(this);
WINDSGeneralData.cpp:  /*if (WID->simParams->streetCanyonFlag > 0 && WID->simParams->streetIntersectionFlag > 0 && allBuildingsV.size() > 0)
WINDSGeneralData.cpp:    allBuildingsV[0]->streetIntersection (WID, this);
WINDSGeneralData.cpp:    allBuildingsV[0]->poisson (WID, this);
WINDSGeneralData.cpp:  // wall->wallLogBC (this);
WINDSGeneralData.cpp:  wall->setVelocityZero(this);
WINDSGeneralData.cpp:  std::chrono::duration<float> elapsed_param = finish_param - start_param;
WINDSGeneralData.cpp:  int rpad = PBWIDTH - lpad;
WINDSGeneralData.cpp:  std::cout << "-------------------------------------------------------------------" << std::endl;
WINDSGeneralData.cpp:  std::cout << "-------------------------------------------------------------------" << std::endl;
WINDSGeneralData.cpp:    effective_height_R.resize(building_id.size() - building_id.size() / 2);
WINDSGeneralData.cpp:    building_id_R.resize(building_id.size() - building_id.size() / 2);
WINDSGeneralData.cpp:    sensortime_R.resize(sensortime_id.size() - sensortime_id.size() / 2);
WINDSGeneralData.cpp:    sensortime_id_R.resize(sensortime_id.size() - sensortime_id.size() / 2);
WINDSGeneralData.cpp:  uhc = (ustar / vk) * (log((canopy_top - d1) / z0) + psi_m);
WINDSGeneralData.cpp:  fi = ((canopy_atten * uhc * vk) / ustar) - canopy_top / (canopy_top - d1);
WINDSGeneralData.cpp:      uhc = (ustar / vk) * (log((canopy_top - d) / z0) + psi_m);
WINDSGeneralData.cpp:      fnew = ((canopy_atten * uhc * vk) / ustar) - canopy_top / (canopy_top - d);
WINDSGeneralData.h: * This file is part of QES-Winds
WINDSGeneralData.h: * GPL-3.0 License
WINDSGeneralData.h: * QES-Winds is free software: you can redistribute it and/or modify
WINDSGeneralData.h: * QES-Winds is distributed in the hope that it will be useful,
WINDSGeneralData.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
WINDSGeneralData.h:   * Saves user-defined data to file.
WINDSGeneralData.h:  //////// Variables and constants needed only in other functions-- Behnam
WINDSGeneralData.h:  long numcell_cent; /**< Total number of cell-centered values in domain */
WINDSGeneralData.h:  long numcell_face; /**< Total number of face-centered values in domain */
WINDSGeneralData.h:                        4 = Cavity, 5 = Farwake, 6 = Street canyon, 7 = Building cut-cells,
WINDSGeneralData.h:                        8 = Terrain cut-cells, 9 = Sidewall, 10 = Rooftop,
WINDSGeneralData.h:  /** Building cut-cell (rectangular building) */
WINDSInputData.h: * This file is part of QES-Winds
WINDSInputData.h: * GPL-3.0 License
WINDSInputData.h: * QES-Winds is free software: you can redistribute it and/or modify
WINDSInputData.h: * QES-Winds is distributed in the hope that it will be useful,
WINDSInputData.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
WINDSOutputVisualization.cpp: * This file is part of QES-Winds
WINDSOutputVisualization.cpp: * GPL-3.0 License
WINDSOutputVisualization.cpp: * QES-Winds is free software: you can redistribute it and/or modify
WINDSOutputVisualization.cpp: * QES-Winds is distributed in the hope that it will be useful,
WINDSOutputVisualization.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
WINDSOutputVisualization.cpp:  std::vector<std::string> fileOP = WID->fileOptions->outputFields;
WINDSOutputVisualization.cpp:  int nx = WGD_->nx;
WINDSOutputVisualization.cpp:  int ny = WGD_->ny;
WINDSOutputVisualization.cpp:  int nz = WGD_->nz;
WINDSOutputVisualization.cpp:  long numcell_cout = (nx - 1) * (ny - 1) * (nz - 2);
WINDSOutputVisualization.cpp:  z_out.resize(nz - 2);
WINDSOutputVisualization.cpp:  for (auto k = 1; k < nz - 1; k++) {
WINDSOutputVisualization.cpp:    z_out[k - 1] = WGD_->z[k];// Location of face centers in z-dir
WINDSOutputVisualization.cpp:  x_out.resize(nx - 1);
WINDSOutputVisualization.cpp:  for (auto i = 0; i < nx - 1; i++) {
WINDSOutputVisualization.cpp:    x_out[i] = (i + 0.5) * WGD_->dx;// Location of face centers in x-dir
WINDSOutputVisualization.cpp:  y_out.resize(ny - 1);
WINDSOutputVisualization.cpp:  for (auto j = 0; j < ny - 1; j++) {
WINDSOutputVisualization.cpp:    y_out[j] = (j + 0.5) * WGD_->dy;// Location of face centers in y-dir
WINDSOutputVisualization.cpp:  // set cell-centered data dimensions
WINDSOutputVisualization.cpp:  NcDim NcDim_x = addDimension("x", WGD_->nx - 1);
WINDSOutputVisualization.cpp:  NcDim NcDim_y = addDimension("y", WGD_->ny - 1);
WINDSOutputVisualization.cpp:  NcDim NcDim_z = addDimension("z", WGD_->nz - 2);
WINDSOutputVisualization.cpp:  createAttVector("times", "date time", "-", dim_vect_tstr, &timestamp);
WINDSOutputVisualization.cpp:  createAttVector("x", "x-distance", "m", dim_vect_x, &x_out);
WINDSOutputVisualization.cpp:  createAttVector("y", "y-distance", "m", dim_vect_y, &y_out);
WINDSOutputVisualization.cpp:  createAttVector("z", "z-distance", "m", dim_vect_z, &z_out);
WINDSOutputVisualization.cpp:  createAttVector("terrain", "terrain height", "m", dim_vect_2d, &(WGD_->terrain));
WINDSOutputVisualization.cpp:  createAttVector("u", "x-component velocity", "m s-1", dim_vect_3d, &u_out);
WINDSOutputVisualization.cpp:  createAttVector("v", "y-component velocity", "m s-1", dim_vect_3d, &v_out);
WINDSOutputVisualization.cpp:  createAttVector("w", "z-component velocity", "m s-1", dim_vect_3d, &w_out);
WINDSOutputVisualization.cpp:  createAttVector("mag", "velocity magnitude", "m s-1", dim_vect_3d, &mag_out);
WINDSOutputVisualization.cpp:  createAttVector("icell", "icell flag value", "--", dim_vect_3d, &icellflag_out);
WINDSOutputVisualization.cpp:  createAttVector("icellInitial", "icell flag value", "--", dim_vect_3d, &icellflag2_out);
WINDSOutputVisualization.cpp:// Save output at cell-centered values
WINDSOutputVisualization.cpp:  int nx = WGD_->nx;
WINDSOutputVisualization.cpp:  int ny = WGD_->ny;
WINDSOutputVisualization.cpp:  int nz = WGD_->nz;
WINDSOutputVisualization.cpp:  // get cell-centered values
WINDSOutputVisualization.cpp:  for (auto k = 1; k < nz - 1; k++) {
WINDSOutputVisualization.cpp:    for (auto j = 0; j < ny - 1; j++) {
WINDSOutputVisualization.cpp:      for (auto i = 0; i < nx - 1; i++) {
WINDSOutputVisualization.cpp:        int icell_cent = i + j * (nx - 1) + (k - 1) * (nx - 1) * (ny - 1);
WINDSOutputVisualization.cpp:        u_out[icell_cent] = 0.5 * (WGD_->u[icell_face + 1] + WGD_->u[icell_face]);
WINDSOutputVisualization.cpp:        v_out[icell_cent] = 0.5 * (WGD_->v[icell_face + nx] + WGD_->v[icell_face]);
WINDSOutputVisualization.cpp:        w_out[icell_cent] = 0.5 * (WGD_->w[icell_face + nx * ny] + WGD_->w[icell_face]);
WINDSOutputVisualization.cpp:        icellflag_out[icell_cent] = WGD_->icellflag[icell_cent + ((nx - 1) * (ny - 1))];
WINDSOutputVisualization.cpp:        icellflag2_out[icell_cent] = WGD_->icellflag_initial[icell_cent + ((nx - 1) * (ny - 1))];
WINDSOutputVisualization.h: * This file is part of QES-Winds
WINDSOutputVisualization.h: * GPL-3.0 License
WINDSOutputVisualization.h: * QES-Winds is free software: you can redistribute it and/or modify
WINDSOutputVisualization.h: * QES-Winds is distributed in the hope that it will be useful,
WINDSOutputVisualization.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
WINDSOutputWorkspace.cpp: * This file is part of QES-Winds
WINDSOutputWorkspace.cpp: * GPL-3.0 License
WINDSOutputWorkspace.cpp: * QES-Winds is free software: you can redistribute it and/or modify
WINDSOutputWorkspace.cpp: * QES-Winds is distributed in the hope that it will be useful,
WINDSOutputWorkspace.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
WINDSOutputWorkspace.cpp:  int nx = WGD_->nx;
WINDSOutputWorkspace.cpp:  int ny = WGD_->ny;
WINDSOutputWorkspace.cpp:  int nz = WGD_->nz;
WINDSOutputWorkspace.cpp:  // Location of face centers in z-dir
WINDSOutputWorkspace.cpp:  z.resize(nz - 1);
WINDSOutputWorkspace.cpp:  dz_array.resize(nz - 1, 0.0);
WINDSOutputWorkspace.cpp:  z_face.resize(nz - 1);
WINDSOutputWorkspace.cpp:  for (auto k = 0; k < nz - 1; k++) {
WINDSOutputWorkspace.cpp:    z[k] = WGD_->z[k];
WINDSOutputWorkspace.cpp:    dz_array[k] = WGD_->dz_array[k];
WINDSOutputWorkspace.cpp:    z_face[k] = WGD_->z_face[k];
WINDSOutputWorkspace.cpp:  // Location of face centers in x-dir
WINDSOutputWorkspace.cpp:  x.resize(nx - 1);
WINDSOutputWorkspace.cpp:  for (auto i = 0; i < nx - 1; i++) {
WINDSOutputWorkspace.cpp:    //x_cc[i] = (i + 0.5) * WGD_->dx;
WINDSOutputWorkspace.cpp:    x[i] = WGD_->x[i];
WINDSOutputWorkspace.cpp:  // Location of face centers in y-dir
WINDSOutputWorkspace.cpp:  y.resize(ny - 1);
WINDSOutputWorkspace.cpp:  for (auto j = 0; j < ny - 1; j++) {
WINDSOutputWorkspace.cpp:    //y_cc[j] = (j + 0.5) * WGD_->dy;
WINDSOutputWorkspace.cpp:    y[j] = WGD_->y[j];
WINDSOutputWorkspace.cpp:  createAttVector("times", "date time", "-", dim_vect_tstr, &timestamp);
WINDSOutputWorkspace.cpp:  // set face-centered data dimensions
WINDSOutputWorkspace.cpp:  NcDim NcDim_x_fc = addDimension("x_face", WGD_->nx);
WINDSOutputWorkspace.cpp:  NcDim NcDim_y_fc = addDimension("y_face", WGD_->ny);
WINDSOutputWorkspace.cpp:  NcDim NcDim_z_fc = addDimension("z_face", WGD_->nz);
WINDSOutputWorkspace.cpp:  createAttVector("u", "x-component velocity", "m s-1", dim_vect_fc, &(WGD_->u));
WINDSOutputWorkspace.cpp:  createAttVector("v", "y-component velocity", "m s-1", dim_vect_fc, &(WGD_->v));
WINDSOutputWorkspace.cpp:  createAttVector("w", "z-component velocity", "m s-1", dim_vect_fc, &(WGD_->w));
WINDSOutputWorkspace.cpp:  // set cell-centered data dimensions
WINDSOutputWorkspace.cpp:  NcDim NcDim_x_cc = addDimension("x_cc", WGD_->nx - 1);
WINDSOutputWorkspace.cpp:  NcDim NcDim_y_cc = addDimension("y_cc", WGD_->ny - 1);
WINDSOutputWorkspace.cpp:  NcDim NcDim_z_cc = addDimension("z_cc", WGD_->nz - 1);
WINDSOutputWorkspace.cpp:  createAttVector("x", "x-distance", "m", dim_vect_x_cc, &x);
WINDSOutputWorkspace.cpp:  createAttVector("y", "y-distance", "m", dim_vect_y_cc, &y);
WINDSOutputWorkspace.cpp:  createAttVector("z", "z-distance", "m", dim_vect_z_cc, &z);
WINDSOutputWorkspace.cpp:  createAttVector("terrain", "terrain height", "m", dim_vect_2d, &(WGD_->terrain));
WINDSOutputWorkspace.cpp:  createAttVector("z0_u", "terrain areo roughness, u", "m", dim_vect_2d, &(WGD_->z0_domain_u));
WINDSOutputWorkspace.cpp:  createAttVector("z0_v", "terrain areo roughness, v", "m", dim_vect_2d, &(WGD_->z0_domain_v));
WINDSOutputWorkspace.cpp:  createAttVector("mixlength", "distance to nearest object", "m", { NcDim_z_cc, NcDim_y_cc, NcDim_x_cc }, &(WGD_->mixingLengths));
WINDSOutputWorkspace.cpp:  createAttVector("icellflag", "icell flag value", "--", dim_vect_cc, &(WGD_->icellflag));
WINDSOutputWorkspace.cpp:  createAttVector("e", "e cut-cell coefficient", "--", dim_vect_cc, &(WGD_->e));
WINDSOutputWorkspace.cpp:  createAttVector("f", "f cut-cell coefficient", "--", dim_vect_cc, &(WGD_->f));
WINDSOutputWorkspace.cpp:  createAttVector("g", "g cut-cell coefficient", "--", dim_vect_cc, &(WGD_->g));
WINDSOutputWorkspace.cpp:  createAttVector("h", "h cut-cell coefficient", "--", dim_vect_cc, &(WGD_->h));
WINDSOutputWorkspace.cpp:  createAttVector("m", "m cut-cell coefficient", "--", dim_vect_cc, &(WGD_->m));
WINDSOutputWorkspace.cpp:  createAttVector("n", "n cut-cell coefficient", "--", dim_vect_cc, &(WGD_->n));
WINDSOutputWorkspace.cpp:  // attribute for the volume fraction (cut-cell)
WINDSOutputWorkspace.cpp:  createAttVector("building_volume_frac", "building volume fraction", "--", dim_vect_cc, &(WGD_->building_volume_frac));
WINDSOutputWorkspace.cpp:  createAttVector("terrain_volume_frac", "terrain volume fraction", "--", dim_vect_cc, &(WGD_->terrain_volume_frac));
WINDSOutputWorkspace.cpp:// Save output at cell-centered values
WINDSOutputWorkspace.cpp:  int nBuildings = WGD_->allBuildingsV.size();
WINDSOutputWorkspace.cpp:  createAttVector("building_cent_x", "x-coordinate of centroid", "m", dim_vect_building, &building_cent_x);
WINDSOutputWorkspace.cpp:  createAttVector("building_cent_y", "y-coordinate of centroid", "m", dim_vect_building, &building_cent_y);
WINDSOutputWorkspace.cpp:  createAttVector("i_start", "x-index start", "--", dim_vect_building, &i_start);
WINDSOutputWorkspace.cpp:  createAttVector("i_end", "x-index end", "--", dim_vect_building, &i_end);
WINDSOutputWorkspace.cpp:  createAttVector("j_start", "y-index start", "--", dim_vect_building, &j_start);
WINDSOutputWorkspace.cpp:  createAttVector("j_end", "y-index end", "--", dim_vect_building, &j_end);
WINDSOutputWorkspace.cpp:  createAttVector("k_start", "z-index end", "--", dim_vect_building, &k_end);
WINDSOutputWorkspace.cpp:  createAttVector("i_cut_start", "x-index start cut-cell", "--", dim_vect_building, &i_cut_start);
WINDSOutputWorkspace.cpp:  createAttVector("i_cut_end", "x-index end cut-cell", "--", dim_vect_building, &i_cut_end);
WINDSOutputWorkspace.cpp:  createAttVector("j_cut_start", "y-index start cut-cell", "--", dim_vect_building, &j_cut_start);
WINDSOutputWorkspace.cpp:  createAttVector("j_cut_end", "y-index end cut-cell", "--", dim_vect_building, &j_cut_end);
WINDSOutputWorkspace.cpp:  createAttVector("k_cut_start", "z-index end cut-cell", "--", dim_vect_building, &k_cut_end);
WINDSOutputWorkspace.cpp:  createAttVector("i_building_cent", "x-index of centroid", "--", dim_vect_building, &i_building_cent);
WINDSOutputWorkspace.cpp:  createAttVector("i_building_cent", "y-index of centroid", "--", dim_vect_building, &i_building_cent);
WINDSOutputWorkspace.cpp:  int nBuildings = WGD_->allBuildingsV.size();
WINDSOutputWorkspace.cpp:      building_rotation[id] = WGD_->allBuildingsV[id]->building_rotation;
WINDSOutputWorkspace.cpp:      canopy_rotation[id] = WGD_->allBuildingsV[id]->canopy_rotation;
WINDSOutputWorkspace.cpp:      L[id] = WGD_->allBuildingsV[id]->L;
WINDSOutputWorkspace.cpp:      W[id] = WGD_->allBuildingsV[id]->W;
WINDSOutputWorkspace.cpp:      H[id] = WGD_->allBuildingsV[id]->H;
WINDSOutputWorkspace.cpp:      height_eff[id] = WGD_->allBuildingsV[id]->height_eff;
WINDSOutputWorkspace.cpp:      base_height[id] = WGD_->allBuildingsV[id]->base_height;
WINDSOutputWorkspace.cpp:      building_cent_x[id] = WGD_->allBuildingsV[id]->building_cent_x;
WINDSOutputWorkspace.cpp:      building_cent_y[id] = WGD_->allBuildingsV[id]->building_cent_y;
WINDSOutputWorkspace.cpp:      i_start[id] = WGD_->allBuildingsV[id]->i_start;
WINDSOutputWorkspace.cpp:      i_end[id] = WGD_->allBuildingsV[id]->i_end;
WINDSOutputWorkspace.cpp:      j_start[id] = WGD_->allBuildingsV[id]->j_start;
WINDSOutputWorkspace.cpp:      j_end[id] = WGD_->allBuildingsV[id]->j_end;
WINDSOutputWorkspace.cpp:      k_end[id] = WGD_->allBuildingsV[id]->k_end;
WINDSOutputWorkspace.cpp:      i_cut_start[id] = WGD_->allBuildingsV[id]->i_cut_start;
WINDSOutputWorkspace.cpp:      i_cut_end[id] = WGD_->allBuildingsV[id]->i_cut_end;
WINDSOutputWorkspace.cpp:      j_cut_start[id] = WGD_->allBuildingsV[id]->j_cut_start;
WINDSOutputWorkspace.cpp:      j_cut_end[id] = WGD_->allBuildingsV[id]->j_cut_end;
WINDSOutputWorkspace.cpp:      k_cut_end[id] = WGD_->allBuildingsV[id]->k_cut_end;
WINDSOutputWorkspace.cpp:      i_building_cent[id] = WGD_->allBuildingsV[id]->i_building_cent;
WINDSOutputWorkspace.cpp:      j_building_cent[id] = WGD_->allBuildingsV[id]->j_building_cent;
WINDSOutputWorkspace.cpp:    length_eff[id] = WGD_->allBuildingsV[id]->length_eff;
WINDSOutputWorkspace.cpp:    width_eff[id] = WGD_->allBuildingsV[id]->width_eff;
WINDSOutputWorkspace.cpp:    upwind_dir[id] = WGD_->allBuildingsV[id]->upwind_dir;
WINDSOutputWorkspace.cpp:    Lr[id] = WGD_->allBuildingsV[id]->Lr;
WINDSOutputWorkspace.h: * This file is part of QES-Winds
WINDSOutputWorkspace.h: * GPL-3.0 License
WINDSOutputWorkspace.h: * QES-Winds is free software: you can redistribute it and/or modify
WINDSOutputWorkspace.h: * QES-Winds is distributed in the hope that it will be useful,
WINDSOutputWorkspace.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
WINDSOutputWRF.cpp:// Save output at cell-centered values
WINDSOutputWRF.cpp:  wrf_->extractWind(WGD_);
WRFInput.cpp: * This file is part of QES-Winds
WRFInput.cpp: * GPL-3.0 License
WRFInput.cpp: * QES-Winds is free software: you can redistribute it and/or modify
WRFInput.cpp: * QES-Winds is distributed in the hope that it will be useful,
WRFInput.cpp: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
WRFInput.cpp:                  ---------------------------------------
WRFInput.cpp:    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
WRFInput.cpp:    Each of these is 8 degrees south-north, apart from zone X which is 12 degrees south-north.
WRFInput.cpp:    - north=0 for northern hemisphere and
WRFInput.cpp:    - north=10000000 (10000km) for southern hemisphere. values must be in metres i.e. north=10000000.
WRFInput.cpp:  e2 = 1.0 - pow((semimin / semimaj), 2.0);
WRFInput.cpp:  ep2 = e2 / (1.0 - e2);
WRFInput.cpp:  cm = zone * 6.0 - 183.0;
WRFInput.cpp:    delam = dlon - cm;
WRFInput.cpp:    if (delam < -180.0) {
WRFInput.cpp:      delam = delam - 360.0;
WRFInput.cpp:    f1 = (1.0 - (e2 / 4.0) - 3.0 * (e4 / 64.0) - 5.0 * (e6 / 256)) * rlat;
WRFInput.cpp:    rm = semimaj * (f1 - f2 + f3 - f4);
WRFInput.cpp:    if (dlat == 90.0 || dlat == -90.0) {
WRFInput.cpp:      rn = semimaj / sqrt(1.0 - e2 * pow(sin(rlat), 2.0));
WRFInput.cpp:      f1 = (1.0 - t + c) * pow(a, 3.0) / 6.0;
WRFInput.cpp:      f2 = 5.0 - 18.0 * t + pow(t, 2.0) + 72.0 * c - 58.0 * ep2;
WRFInput.cpp:      f2 = 5.0 - t + 9.0 * c + 4.0 * pow(c, 2.0);
WRFInput.cpp:      f3 = 61.0 - 58.0 * t + pow(t, 2.0) + 600.0 * c - 330.0 * ep2;
WRFInput.cpp:    xx = xx - east;
WRFInput.cpp:    yy = yy - north;
WRFInput.cpp:    e1 = sqrt(1.0 - e2);
WRFInput.cpp:    e1 = (1.0 - e1) / (1.0 + e1);
WRFInput.cpp:    u = 1.0 - (e2 / 4.0) - 3.0 * (e4 / 64.0) - 5.0 * (e6 / 256.0);
WRFInput.cpp:    f1 = 3.0 * (e1 / 2.0) - 27.0 * pow(e1, 3.0) / 32.0;
WRFInput.cpp:    f2 = (21.0 * pow(e1, 2.0) / 16.0) - 55.0 * pow(e1, 4.0) / 32.0;
WRFInput.cpp:    if (dlat1 >= 90.0 || dlat1 <= -90.0) {
WRFInput.cpp:      dlat1 = std::max(dlat1, -90.0f);
WRFInput.cpp:      f1 = 1.0 - e2 * pow(sin(rlat1), 2.0);
WRFInput.cpp:      r1 = semimaj * (1.0 - e2) / sqrt(pow(f1, 3.0));
WRFInput.cpp:      f3 = 5.0 * 3.0 * t1 + 10.0 * c1 - 4.0 * pow(c1, 2.0) - 9.0 * ep2;
WRFInput.cpp:      f4 = 61.0 + 90.0 * t1 + 298.0 * c1 + 45.0 * pow(t1, 2.0) - 252.0 * ep2 - 3.0 * pow(c1, 2.0);
WRFInput.cpp:      rlat = rlat1 - f1 * (f2 - f3 + f4);
WRFInput.cpp:      f2 = 5.0 - 2.0 * c1 + 28.0 * t1 - 3.0 * pow(c1, 2.0) + 8.0 * ep2 + 24.0 * pow(t1, 2.0);
WRFInput.cpp:      rlon = cmr + (d - f1 + f2) / cos(rlat1);
WRFInput.cpp:      if (dlon < -180.0) {
WRFInput.cpp:        dlon = dlon - 360.0;
WRFInput.cpp:  std::cout << "WRF Input Processor - reading data from " << filename << std::endl;
WRFInput.cpp:  // How is UTM used now?  --Pete
WRFInput.cpp:  gblAttIter->second.getValues(wrfTitle);
WRFInput.cpp:  std::string subStr1 = wrfTitle.substr(vLoc + 2, wrfTitle.length() - 1);
WRFInput.cpp:  gblAttIter = globalAttributes.find("WEST-EAST_GRID_DIMENSION");
WRFInput.cpp:  gblAttIter->second.getValues(xDim + 1);
WRFInput.cpp:  xDim[1] -= 1;
WRFInput.cpp:  gblAttIter = globalAttributes.find("SOUTH-NORTH_GRID_DIMENSION");
WRFInput.cpp:  gblAttIter->second.getValues(yDim + 1);
WRFInput.cpp:  yDim[1] -= 1;
WRFInput.cpp:  atm_nx = xDim[1] - xDim[0] + 1;
WRFInput.cpp:  atm_ny = yDim[1] - yDim[0] + 1;
WRFInput.cpp:  gblAttIter->second.getValues(cellSize);
WRFInput.cpp:  gblAttIter->second.getValues(cellSize + 1);
WRFInput.cpp:    // IMPORTANT -- need to include code to check for fire mesh
WRFInput.cpp:    // Check to verify the fields for the fire mesh exist --
WRFInput.cpp:    std::cout << "(Lat,Long) at Lower Right (LR) = " << fxlat[fm_nx - 1] << ", " << fxlong[fm_nx - 1] << std::endl;
WRFInput.cpp:    std::cout << "(Lat,Long) at Upper Left (UL) = " << fxlat[(fm_ny - 1) * fm_nx] << ", " << fxlong[(fm_ny - 1) * fm_nx] << std::endl;
WRFInput.cpp:    std::cout << "(Lat,Long) at Upper Right (UR) = " << fxlat[fm_nx - 1 + (fm_ny - 1) * fm_nx] << ", " << fxlong[fm_nx - 1 + (fm_ny - 1) * fm_nx] << std::endl;
WRFInput.cpp:    UTMConv(fxlong[fm_nx - 1], fxlat[fm_nx - 1], lrUTMx, lrUTMy, UTMZone, 0);
WRFInput.cpp:    UTMConv(fxlong[(fm_ny - 1) * fm_nx], fxlat[(fm_ny - 1) * fm_nx], ulUTMx, ulUTMy, UTMZone, 0);
WRFInput.cpp:    UTMConv(fxlong[fm_nx - 1 + (fm_ny - 1) * fm_nx], fxlat[fm_nx - 1 + (fm_ny - 1) * fm_nx], urUTMx, urUTMy, UTMZone, 0);
WRFInput.cpp:        // Setting up WRF-based SpatialReference
WRFInput.cpp:        gblAttIter->second.getValues( &lat1 );
WRFInput.cpp:        gblAttIter->second.getValues( &lat2 );
WRFInput.cpp:        gblAttIter->second.getValues( &lat0 );
WRFInput.cpp:        gblAttIter->second.getValues( &lon0 );
WRFInput.cpp:        gblAttIter->second.getValues( &clat );
WRFInput.cpp:        gblAttIter->second.getValues( &clon );
WRFInput.cpp:        // x0_atm = -nx_atm / 2. * dx_atm + e
WRFInput.cpp:        // geotransform_atm = (x0_atm,dx_atm,0,y1_atm,0,-dy_atm)
WRFInput.cpp://    wrfCoordXform->Transform(1, &clon, &clat);
WRFInput.cpp:        //  NC_GLOBAL#CEN_LON=-86.730408
WRFInput.cpp:        // oSRS.SetLCC(30.0, 34.0, 30.533249, -86.730408, 0.0, 0.0);
WRFInput.cpp://    ogrCoordXform1of2->Transform(1, lon2eastings, lat2northings);
WRFInput.cpp://    ogrCoordXform2of2->Transform(1, lon2eastings, lat2northings);
WRFInput.cpp://    ogrCoordXform3->Transform(1, lon2eastings, lat2northings);
WRFInput.cpp:        ogrCoordXform4->Transform(1, lon2eastings, lat2northings);
WRFInput.cpp:    gblAttIter->second.getValues(&clat);
WRFInput.cpp:    gblAttIter->second.getValues(&clon);
WRFInput.cpp:    int nx_fire = fm_nx - srx;
WRFInput.cpp:    int ny_fire = fm_ny - sry;
WRFInput.cpp:    double t_x0_fire = -nx_fire / 2. * dx_fire + lon2eastings[0];
WRFInput.cpp:    // May not need that section above between BEGIN - END
WRFInput.cpp:    // double x0_fire = t_x0_fire; // -fm_nx / 2.0 * dxf + lon2eastings[0];
WRFInput.cpp:    // double y1_fire = t_y1_fire; // -fm_ny / 2.0 * dyf + lat2northings[0];
WRFInput.cpp:  // top grid dimension stored in BOTTOM-TOP_GRID_DIMENSION
WRFInput.cpp:  gblAttIter = globalAttributes.find("BOTTOM-TOP_GRID_DIMENSION");
WRFInput.cpp:  gblAttIter->second.getValues(&atm_nz);
WRFInput.cpp:  // SUBDATASET_12_DESC=[360x41x114x114] PH (32-bit floating-point)
WRFInput.cpp:  // SUBDATASET_13_NAME=NETCDF:"/scratch/Downloads/RXCwrfout_d07_2012-11-11_15-21":PHB
WRFInput.cpp:  // SUBDATASET_13_DESC=[360x41x114x114] PHB (32-bit floating-point)
WRFInput.cpp:  // SUBDATASET_14_NAME=NETCDF:"/scratch/Downloads/RXCwrfout_d07_2012-11-11_15-21":T
WRFInput.cpp:  std::cout << "\tpressure-based height computed." << std::endl;
WRFInput.cpp:  atmCounts[1] = atm_nz - 1;
WRFInput.cpp:  std::vector<double> UStaggered(2 * (atm_nz - 1) * atm_ny * (atm_nx + 1));
WRFInput.cpp:  std::vector<double> VStaggered(2 * (atm_nz - 1) * (atm_ny + 1) * atm_nx);
WRFInput.cpp:  std::vector<double> U(2 * (atm_nz - 1) * atm_ny * atm_nx);
WRFInput.cpp:  std::vector<double> V(2 * (atm_nz - 1) * atm_ny * atm_nx);
WRFInput.cpp:    for (int k = 0; k < (atm_nz - 1); k++) {
WRFInput.cpp:          int l_idx = t * ((atm_nz - 1) * atm_ny * atm_nx) + k * (atm_ny * atm_nx) + j * atm_nx + i;
WRFInput.cpp:          int l_xp1_idx = t * ((atm_nz - 1) * atm_ny * atm_nx) + k * (atm_ny * atm_nx) + j * atm_nx + i + 1;
WRFInput.cpp:          int l_yp1_idx = t * ((atm_nz - 1) * atm_ny * atm_nx) + k * (atm_ny * atm_nx) + (j + 1) * atm_nx + i;
WRFInput.cpp:  std::vector<double> coordZ(2 * (atm_nz - 1) * atm_ny * atm_nx);
WRFInput.cpp:    for (int k = 0; k < (atm_nz - 1); k++) {
WRFInput.cpp:          int l_idx = t * ((atm_nz - 1) * atm_ny * atm_nx) + k * (atm_ny * atm_nx) + j * atm_nx + i;
WRFInput.cpp:          int l_kp1_idx = t * ((atm_nz - 1) * atm_ny * atm_nx) + (k + 1) * (atm_ny * atm_nx) + j * atm_nx + i;
WRFInput.cpp:  std::vector<double> wsData(2 * (atm_nz - 1) * atm_ny * atm_nx);
WRFInput.cpp:    for (int k = 0; k < (atm_nz - 1); k++) {
WRFInput.cpp:          int l_idx = t * ((atm_nz - 1) * atm_ny * atm_nx) + k * (atm_ny * atm_nx) + j * atm_nx + i;
WRFInput.cpp:  std::vector<double> wdData(2 * (atm_nz - 1) * atm_ny * atm_nx);
WRFInput.cpp:    for (int k = 0; k < (atm_nz - 1); k++) {
WRFInput.cpp:          int l_idx = t * ((atm_nz - 1) * atm_ny * atm_nx) + k * (atm_ny * atm_nx) + j * atm_nx + i;
WRFInput.cpp:            wdData[l_idx] = 270.0 - (180.0 / c_PI) * atan(V[l_idx] / U[l_idx]);
WRFInput.cpp:            wdData[l_idx] = 90.0 - (180.0 / c_PI) * atan(V[l_idx] / U[l_idx]);
WRFInput.cpp:  // read LU -- depends on if reading the restart or the output file
WRFInput.cpp:  // These hard-coded values do not seem like they should exist for
WRFInput.cpp:  // ALL cases -- they were in Mattiheu's original code.  We need to
WRFInput.cpp:  // change to something per domain or calculated per domain. -Pete
WRFInput.cpp:        //   lXCoord = geo_xCoord_UTMx - UTMx + halo_x
WRFInput.cpp:        //   lYCoord = geo_yCoord_UTMy - UTMy + halo_y
WRFInput.cpp:        sd.xCoord = utmStatX - domainUTMx;// need halo still    xIdx * atm_dx;  // use actual position
WRFInput.cpp:        sd.yCoord = utmStatY - domainUTMy;// sd.yCoord = yIdx * atm_dy;  // "
WRFInput.cpp:          for (int k = 0; k < (atm_nz - 1); k++) {
WRFInput.cpp:            int l_idx = t * ((atm_nz - 1) * atm_ny * atm_nx) + k * (atm_ny * atm_nx) + yIdx * atm_nx + xIdx;
WRFInput.cpp:              // Use ZSF + FZ0 -- should be built into coordZ it seems
WRFInput.cpp:              std::cout << "profile height at " << k << ": " << coordZ[l_idx] - atm_hgt[yIdx * atm_nx + xIdx] << "\n";
WRFInput.cpp:              profEl.zCoord = coordZ[l_idx] - atm_hgt[yIdx * atm_nx + xIdx];
WRFInput.cpp:    // Read domain dimensions, terrain elevation, wind data, land-use
WRFInput.cpp:    // NC_GLOBAL - WEST-EAST_GRID_DIMENSION,
WRFInput.cpp:    // SOUTH-NORTH_GRID_DIMENSION
WRFInput.cpp:    //   NC_GLOBAL#CEN_LON=-86.730408
WRFInput.cpp:    // From: https://www.openwfm.org/images/archive/e/ec/20101104161506%21Users_guide_chap-wrf-fire.pdf
WRFInput.cpp:    // ZSF - The variable ZSF contains high resolution terrain height
WRFInput.cpp:    // Read the WRF NetCDF file as read-only (default option in the
WRFInput.cpp:    // wrfInputFile( "/scratch/Downloads/RXCwrfout_d07_2012-11-11_15-21", NcFile::read );
WRFInput.cpp:    // external = infile->getDim(name);
WRFInput.cpp:    // input->getDimensionSize("x",grid.nx);
WRFInput.cpp:    // input->getDimensionSize("y",grid.ny);
WRFInput.cpp:    // input->getVariableData("u",start,count,wind.u);
WRFInput.cpp:    // std::cout << "Attribute Name: " << i->first << std::endl;
WRFInput.cpp:    auto gblAttIter = globalAttributes.find("WEST-EAST_GRID_DIMENSION");
WRFInput.cpp:    gblAttIter->second.getValues( xDim+1 );
WRFInput.cpp:    xDim[1] -= 1;
WRFInput.cpp:    gblAttIter = globalAttributes.find("SOUTH-NORTH_GRID_DIMENSION");
WRFInput.cpp:    gblAttIter->second.getValues( yDim+1 );
WRFInput.cpp:    yDim[1] -= 1;
WRFInput.cpp:    nx = xDim[1] - xDim[0] + 1;
WRFInput.cpp:    ny = yDim[1] - yDim[0] + 1;
WRFInput.cpp:    gblAttIter->second.getValues( cellSize );
WRFInput.cpp:    gblAttIter->second.getValues( cellSize+1 );
WRFInput.cpp://    SimData.nx = XEND_New - XSTART_New +1;
WRFInput.cpp://    SimData.ny = YEND_New - YSTART_New +1;
WRFInput.cpp:    //SUBDATASET_214_NAME=NETCDF:"RXCwrfout_d07_2012-11-11_15-21":FXLONG
WRFInput.cpp:    // SUBDATASET_214_DESC=[360x1150x1150] FXLONG (32-bit floating-point)
WRFInput.cpp:    double rangeHt = maxHt - minHt;
WRFInput.cpp:    std::cout << "(Lat,Long) at [nx-1][0] = " << fxlat[fm_nx-1] << ", " << fxlong[nx-1] << std::endl;
WRFInput.cpp:    std::cout << "(Lat,Long) at [0][ny-1] = " << fxlat[(fm_ny-1)*fm_nx] << ", " << fxlong[(fm_ny-1)*fm_nx] << std::endl;
WRFInput.cpp:    std::cout << "(Lat,Long) at [nx-1][ny-1] = " << fxlat[fm_nx-1 + (fm_ny-1)*fm_nx] << ", " << fxlong[fm_nx-1 + (fm_ny-1)*fm_nx] << std::endl;
WRFInput.cpp:    double adfGeoTransform[6] = {  524972.33, dxf, 0, 3376924.26, 0, -dyf };
WRFInput.cpp:    poDriver = GetGDALDriverManager()->GetDriverByName(pszFormat);
WRFInput.cpp:    papszMetadata = poDriver->GetMetadata();
WRFInput.cpp:    poDstDS = poDriver->Create( "WRFOut.tiff", fm_nx, fm_ny, 1, GDT_Byte, papszOptions );
WRFInput.cpp:            // std::cout << "Setting ht: " << ((fmHeight[l_idx]-minHt)/rangeHt) * 255 << std::endl;
WRFInput.cpp:    poDstDS->SetGeoTransform( adfGeoTransform );
WRFInput.cpp://  NC_GLOBAL#CEN_LON=-86.730408
WRFInput.cpp:    oSRS.SetLCC(30.0, 34.0, 30.533249, -86.730408, 0.0, 0.0);
WRFInput.cpp:    poDstDS->SetProjection( pszSRS_WKT );
WRFInput.cpp:    poBand = poDstDS->GetRasterBand(1);
WRFInput.cpp:    poBand->RasterIO( GF_Write, 0, 0, fm_nx, fm_ny,
WRFInput.cpp:            std::cout << "Relief Attr: " << ci->first << std::endl;
WRFInput.cpp:    for (auto l=subsetDim-10-1; l<subsetDim; l++)
WRFInput.cpp:        std::cout << "LUIndex Attr: " << ci->first << std::endl;
WRFInput.cpp:    for (auto l=subsetDim-10-1; l<subsetDim; l++)
WRFInput.cpp:%                     case 1   %%% Urban and built-up land
WRFInput.cpp:%%%%%%%%%%%%%%%%%%%%%%%%%      MODIS-WINTER      %%%%%%%%%%%%%%%%%%%%%%%%%%
WRFInput.cpp:                    case 13   %%% Urban and built-up land
WRFInput.cpp:    case 3   %%% User-defined constant
WRFInput.cpp:        Z0 = repmat(SimData.Z0DataSource, SimData.XEND-SimData.XSTART+1, SimData.YEND-SimData.YSTART+1);
WRFInput.cpp:    std::cout << "PHB Attr: " << ci->first << std::endl;
WRFInput.cpp:    // WRF multi-dim format
WRFInput.cpp:    subsetDim *= (counts[i] - starts[i]);
WRFInput.cpp:    subsetDim *= (counts[i] - starts[i]);
WRFInput.cpp:  // SimData.NbAlt = size(Height,3) - 1;
WRFInput.cpp:  int nbAlt = 40;// zDim - 1 but hack for now -- need to be computed
WRFInput.cpp:            WD[idx] = 270.0 - (180.0 / c_PI) * atan(V[idx] / U[idx]);
WRFInput.cpp:            WD[idx] = 90.0 - (180.0 / c_PI) * atan(V[idx] / U[idx]);
WRFInput.cpp:  // land-use using imresize (bicubic interpolation by default).
WRFInput.cpp:  // Land-use is interpolated with the "nearest point" method as we
WRFInput.cpp:  // Land-use
WRFInput.cpp:  // SimData.Relief = SimData.Relief - SimData.OldTopoMin;  % Lowering minimum altitude to 0
WRFInput.cpp:  // SimData.NbTerrain = numel(SimData.Relief) - size(IndLowRelief,1);
WRFInput.cpp:  // SimData.CoordZ = SimData.CoordZ - SimData.OldTopoMin;
WRFInput.cpp:  case 13:// %%% Urban and built-up land
WRFInput.cpp:  assert(fm_nx != (wgd->nx - 1 - 2 * m_haloX_DimAddition));
WRFInput.cpp:  assert(fm_ny != (wgd->ny - 1 - 2 * m_haloY_DimAddition));
WRFInput.cpp:  if (FWH <= wgd->dz) {
WRFInput.cpp:    std::cout << "Warning: resolution in z-direction is not fine enough to define above ground cells for calculating wind" << std::endl;
WRFInput.cpp:    std::cout << "Try running the model with finer resolution in z-direction" << std::endl;
WRFInput.cpp:  for (auto i = 0; i < fm_nx - 1; i++) {
WRFInput.cpp:    for (auto j = 0; j < fm_ny - 1; j++) {
WRFInput.cpp:      // QES's space - fire mesh and wrf data do not have halo
WRFInput.cpp:      auto qes2DIdx = jQES * (wgd->nx - 1) + iQES;
WRFInput.cpp:      auto tHeight = wgd->terrain[qes2DIdx];
WRFInput.cpp:      for (size_t k = 0; k < wgd->z.size() - 1; k++) {
WRFInput.cpp:        if (float(tHeight + FWH) < wgd->z[k]) {
WRFInput.cpp:      // auto kQES = (int)floor( ((tHeight + FWH)/float(wgd->dz) ));
WRFInput.cpp:      auto qes3DIdx = kQES * (wgd->nx) * (wgd->ny) + jQES * (wgd->nx) + iQES;
WRFInput.cpp:      ufOut[fireMeshIdx] = 0.5 * (wgd->u[qes3DIdx + 1] + wgd->u[qes3DIdx]);
WRFInput.cpp:      vfOut[fireMeshIdx] = 0.5 * (wgd->v[qes3DIdx + wgd->nx] + wgd->v[qes3DIdx]);
WRFInput.h: * This file is part of QES-Winds
WRFInput.h: * GPL-3.0 License
WRFInput.h: * QES-Winds is free software: you can redistribute it and/or modify
WRFInput.h: * QES-Winds is distributed in the hope that it will be useful,
WRFInput.h: * along with QES-Winds. If not, see <https://www.gnu.org/licenses/>.
WRFInput.h:// "One-Way Coupling of the WRF–QUIC Urban Dispersion Modeling
WRFInput.h:   * Reading WRF data - ReadDomainInfo.m
WRFInput.h:   * Read domain dimensions, terrain elevation, wind data, land-use
WRFInput.h:   *     - Horizontal dimensions nx and ny (vertical dimension will be computed later, see part).
WRFInput.h:   *     - Time moments (in units provided by WRF).
WRFInput.h:   *     - Horizontal resolution dx and dy (vertical resolution is set to 1 in this version).
WRFInput.h:   *     - Terrain topography.
WRFInput.h:   *     - Wind data (more details in next subsection).
WRFInput.h:   *     - Land-use categories.
WRFInput.h:   *     - Roughness length.
WRFInput.h:   * Reading wind data - WindFunc.m
WRFInput.h:   *     - WRF wind data altitude (in meters) is obtained from geopotential height (dividing the sum of
WRFInput.h:   *     - Wind components U and V components are extracted.
WRFInput.h:   *     - These three variables are interpolated at each WRF cell center (simple arithmetic mean).
WRFInput.h:   *     - Velocity magnitude is computed as sqrt(U^2 + V^2)
WRFInput.h:   *     - Velocity direction is computed from U and V vector components.
WRFInput.h:   *     - In the last step, velocity magnitude, direction and vertical
WRFInput.h:   * Smoothing domain - Smooth.m
WRFInput.h:   * (it is possible to change the method, see imresize other options: bilinear, nearest point, Lanczos-2 and
WRFInput.h:   * Lanczos-3, which have not been tested yet).
WRFInput.h:   *     - First, new horizontal dimensions and resolutions are computed.
WRFInput.h:   *     - Terrain topography is interpolated to fit the new domain dimensions.
WRFInput.h:   *     - Idem for the wind velocity magnitude, direction and altitude values.
WRFInput.h:   *     - Idem for roughness length.
WRFInput.h:   *     - Land-use categories are interpolated to the "nearest point" as we must not change their values
WRFInput.h:   * Minimizing cell number - MinDomainHeight.m
WRFInput.h:   * Selecting WRF data stations - SetWRFdataPt.m
WRFInput.h:   *     - WRF wind data row and column (horizontal) indices are computed to assert a even distribution.
WRFInput.h:   *     - These horizontal coordinates are associated to each stations.
WRFInput.h:   *     - For each station, a vertical index is computed. It corresponds to wind data altitude contained
WRFInput.h:   *     - The corresponding vertical coordinates (in meters) are associated to each stations, as well as the
WRFInput.h:   *     - Wind speed and direction at these altitudes are associated to each stations.
WRFInput.h:   *     - Finally, maximal vertical coordinate is stored, it will be used to define the domain height (this
WRFInput.h:  //		PHB:description = "base-state geopotential" ;
WRFInput.h:  //		PHB:units = "m2 s-2" ;
WRFInput.h:  //		PH:units = "m2 s-2" ;
