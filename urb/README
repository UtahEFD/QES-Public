QUIC_CUDA Readme

Author: Andrew Larson (lars2865@d.umn.edu)
Edited: April 23rd 2012
Created: 1-12-2009
Revision: 402 (https://wind.d.umn.edu/svn/quicurbCUDA/trunk)
#



Contents
--------

1) To Build
2) Brief Description
3) Usage
4) Key Bindings
5) Limitations
6) Directory Structure
7) OS Specifics
#



To Build
--------


Basic console executables have provided for in the cmake files.
<<NOTE>> This is the default way of building.

Console executables require:
  1)  A fortran compiler (version?)
  2)  A C++ compiler     (version?)
  3)  A CUDA compiler    (v 3.0)
  4)  cmake              (v 2.6>)
  4a) make               (version?)
  5)  Access to libsivelab

For recently developing components and the extra viewers or other tools, the
QUIC_BUILD_DEV option for the cmake compilation process must be set to 'On'.

Extended / Developing executables have the following extra requirements:
  5) OpenGL (version? / dev?)
  6) GLEW   (version? / dev?)
  7) GLUT   (version? / dev?)
  8) GLU    (version? / dev?)

cmake has been introduced to make cross platform compiling easier. cmake must be
installed in order to build this project.

Use the following steps to build the project:
  1) navigate to quicurbCUDA/QUIC_CUDA/
  2) mkdir build
  3) cd build
  4) cmake .. OR cmake -D QUIC_BUILD_DEV=On .. 
     (console)   (new code and viewers with OpenGL, GLEW and GLUT)
  5) make
  
<<NOTE>> One can 'rm -rf build' to rebuild the project from scratch.
<<NOTE>> cmake-ing with the QUIC_BUILD_DEV option on/off causes some rebuilding.
  
Once these steps are complete the following executables are available:
In the console build:
  1) cuda_urb
  2) fortran_urb
  3) cuda_plume
  4) fortran_plume

In the development build:
  5)  setup_urb
  6)  cuda_timer (urb)
  7)  fortran_timer (urb)
  8)  viewer_urb
  9)  viewer_plume
  10) localMixing_stup

See usage for more details about running the built executables.
#



Brief Description
-----------------

The contents herein are CUDA utilizing versions of QUICurb and QUICplume. 

Good descriptions of both can be found at the following URL:

http://www.lanl.gov/projects/quic/quicurb.shtml
#



Usage
-----

Urb executables can be found in /build/Urb/.
Plume executables can be found in /build/Plume/.

To use an executable provide the input directory of the proper input files;
also provide an output directory for any output files generated.

<<NOTE>> Currently, some executables don't handle output well.

Typically, I copy the executable I am working with to the appropriate directory
(i.e. /QUIC_CUDA/Urb or /QUIC_CUDA/Plume). From there I run the executable.
For instance,

  ?/quicurbCUDA/QUIC_CUDA/Urb$ ./cuda_urb Data/Semi-Classic/Semi-Classic_inner/
  OR
  ?/quicurbCUDA/QUIC_CUDA/Plume$ ./viewer_plume Data/Classic
  
<<NOTE>> Left out here are the output directories, which should default to the
         given input directories when absent.
The QUICurb portion provides four main stubs. 

Executables:

--URB--
cuda_urb - Runs the iteration scheme using CUDA. Initial setup can be done with
           the existing fortran implementation or a limited-functionality (LF) C++
           version.
           
fortran_urb - Runs the existing fortran implementation. Useful for timing data
              and for generating data to test against. The fortran is wrapped
              in C/C++.
              
setup_urb - Runs the existing fortran and LF C++ initialization routines. Both
            are timed during the runs. Some commented code is available in the
            stub (/Urb/setup_urb.cpp) that compares the outputs.
            
cuda_timer - Given an input directory with an appropriate timing input file, 
             this executable does multiple runs of cuda_urb on different domain
             sizes. Useful for generating timing data for evaluating performance
             gains as a result of using CUDA rather than serial fortran.
             
fortran_timer - Given an input directory with an appropriate timing input file,
                this executable times the fortran routines over varying domain
                sizes. Paired with cuda_timer, the CUDA and fortran can be easily
                compared of many domain sizes.

viewer_urb - Runs the basic iteration scheme found in cuda_urb, but provides a
             GLUT window where the domain can be viewed as the iteration scheme 
             procedes. Lagrangian value view is the default. Very useful for
             identifying errors.
             
--Plume--
cuda_plume - Runs the CUDA version of plume in the console (no visuals), 
             currently not functioning properly. Needs to be completed.
             
fortran_plume - C/C++ wrap up of the existing fortran code for QUIC_PLUME. May
                not be functioning. Needs work (only just started).
                
viewer_plume - Must recent work has been done here. Uses local mixing and CUDA
               kernels to do advection of particles. Still needing collection
               boxes and other fundamental components.
               
localMixing_stub - originally used for testing the localmixing routines from 
                   balli. May still do that, but some re-design may have left it
                   inoperable.
#



Key Bindings
------------

For the viewers (plume and urb) keybindings are available to help control
various actions. 

See there respective READMEs in /Urb and /Plume.
#



Limitations
-----------

Some limitiations in Urb have been lifted recently. The x-dimension is no longer
restricted, leaving the restrictions to the domain size. At some point in time
domains of 1024x1024x21 and 2048x2048x21 where run on some larger machines. These
runs were with the CUDA/C++ port for iteration. At some point the fortran requires
too much host memory, while the port can continue operating into larger domain
sizes.
#




Directory Structure
-------------------

  +CMake
  | \Modules (CMake specific code for finding modules)
  +common (This is common; should be moved out)
  | +cuda (CUDA kernels and wrappers)
  | +lib
  | +quic (More Urb-specific classes)
  | +tests (Unit tests)
  | +tools (Debugging tools)
  | \util
  +data (Holds problem sets (cityscapes))
  +doc
  +lib (Urb library)
  \src
    +cpp (Holds the main project files for Urb)
    +cuda (CUDA kernels and wrappers)
    +shaders (Open GL shader language)
    +tests (Unit tests--TODO)
    \util (Development tools) 
#




OS Specifics
------------

Linux Specifics:
	Building requires compilers: gfortran, g++, nvcc.
	Building requires libraries:  GL, GLU, GLUT, GLEW, gfortran. 
	  
	A users $LD_LIBRARY_PATH and $PATH variables may require modification to 
	include the proper libraries and files. These should reflect the location of 
	the CUDA SDK so that the proper header files can be found during the 
	compilation process.

OSX Specifics:
	Ask Pete...

XP Specifics:
  Not yet compiled in Windows.
#

